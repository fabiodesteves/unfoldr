/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/[documentId]"],{

/***/ "./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMRectReadOnly: () => (/* binding */ DOMRectReadOnly)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL0RPTVJlY3RSZWFkT25seS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9ET01SZWN0UmVhZE9ubHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi91dGlscy9mcmVlemUnO1xudmFyIERPTVJlY3RSZWFkT25seSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRE9NUmVjdFJlYWRPbmx5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG59KCkpO1xuZXhwb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObservation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObservation.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObservation: () => (/* binding */ ResizeObservation)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverBoxOptions */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\");\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\n\nvar skipNotifyOnElement = function (target) {\n    return !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isSVG)(target)\n        && !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isReplacedElement)(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__.calculateBoxSize)(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDTDtBQUNOO0FBQzNEO0FBQ0EsWUFBWSxxREFBSztBQUNqQixZQUFZLGlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtFQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGlzU1ZHLCBpc1JlcGxhY2VkRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgc2tpcE5vdGlmeU9uRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gIWlzU1ZHKHRhcmdldClcbiAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcbiAgICAgICAgJiYgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT09ICdpbmxpbmUnO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FsY3VsYXRlQm94U2l6ZSh0aGlzLnRhcmdldCwgdGhpcy5vYnNlcnZlZEJveCwgdHJ1ZSk7XG4gICAgICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0UmVwb3J0ZWRTaXplLmlubGluZVNpemUgIT09IHNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZhdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserver.js":
/*!********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserver.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserver: () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverController */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrRUFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsK0VBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLCtFQUF3QjtBQUNoQztBQUNBO0FBQ0EsUUFBUSwrRUFBd0I7QUFDaEM7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5vYnNlcnZlKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFJlc2l6ZU9ic2VydmVyICgpIHsgW3BvbHlmaWxsIGNvZGVdIH0nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverBoxOptions: () => (/* binding */ ResizeObserverBoxOptions)\n/* harmony export */ });\nvar ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcbihmdW5jdGlvbiAoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zKSB7XG4gICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkRFVklDRV9QSVhFTF9DT05URU5UX0JPWFwiXSA9IFwiZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94XCI7XG59KShSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfHwgKFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyA9IHt9KSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverController: () => (/* binding */ ResizeObserverController)\n/* harmony export */ });\n/* harmony import */ var _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/scheduler */ \"./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\");\n/* harmony import */ var _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeObservation */ \"./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\");\n/* harmony import */ var _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResizeObserverDetail */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\");\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\n\n\n\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.push(detail);\n            detail.observationTargets.push(new _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__.ResizeObservation(target, options && options.box));\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(1);\n            _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.splice(_utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNIO0FBQ007QUFDSjtBQUMxRDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFlO0FBQy9DLCtDQUErQyxpRUFBaUI7QUFDaEUsWUFBWSw2REFBVztBQUN2QixZQUFZLHVEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1FQUFlLFFBQVEsbUVBQWU7QUFDckU7QUFDQSxZQUFZLDZEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usb0RBQW9EO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzY2hlZHVsZXIsIHVwZGF0ZUNvdW50IH0gZnJvbSAnLi91dGlscy9zY2hlZHVsZXInO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2YXRpb24gfSBmcm9tICcuL1Jlc2l6ZU9ic2VydmF0aW9uJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckRldGFpbCc7XG5pbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc2l6ZU9ic2VydmVycyc7XG52YXIgb2JzZXJ2ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIGdldE9ic2VydmF0aW9uSW5kZXggPSBmdW5jdGlvbiAob2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAob2JzZXJ2YXRpb25UYXJnZXRzW2ldLnRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuY29ubmVjdCA9IGZ1bmN0aW9uIChyZXNpemVPYnNlcnZlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IG5ldyBSZXNpemVPYnNlcnZlckRldGFpbChyZXNpemVPYnNlcnZlciwgY2FsbGJhY2spO1xuICAgICAgICBvYnNlcnZlck1hcC5zZXQocmVzaXplT2JzZXJ2ZXIsIGRldGFpbCk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIub2JzZXJ2ZSA9IGZ1bmN0aW9uIChyZXNpemVPYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBvYnNlcnZlck1hcC5nZXQocmVzaXplT2JzZXJ2ZXIpO1xuICAgICAgICB2YXIgZmlyc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIDwgMCkge1xuICAgICAgICAgICAgZmlyc3RPYnNlcnZhdGlvbiAmJiByZXNpemVPYnNlcnZlcnMucHVzaChkZXRhaWwpO1xuICAgICAgICAgICAgZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cy5wdXNoKG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3gpKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50KDEpO1xuICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIHRhcmdldCkge1xuICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpO1xuICAgICAgICB2YXIgbGFzdE9ic2VydmF0aW9uID0gZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGggPT09IDE7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBsYXN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnNwbGljZShyZXNpemVPYnNlcnZlcnMuaW5kZXhPZihkZXRhaWwpLCAxKTtcbiAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50KC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChvdCkgeyByZXR1cm4gX3RoaXMudW5vYnNlcnZlKHJlc2l6ZU9ic2VydmVyLCBvdC50YXJnZXQpOyB9KTtcbiAgICAgICAgZGV0YWlsLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIGRldGFpbC5hY3RpdmVUYXJnZXRzLmxlbmd0aCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverDetail: () => (/* binding */ ResizeObserverDetail)\n/* harmony export */ });\nvar ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRGV0YWlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlckRldGFpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVzaXplT2JzZXJ2ZXJEZXRhaWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRGV0YWlsO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverEntry: () => (/* binding */ ResizeObserverEntry)\n/* harmony export */ });\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\n\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__.calculateBoxSizes)(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.borderBoxSize]);\n        this.contentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzFCO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMsOEJBQThCLHFEQUFNO0FBQ3BDLHlDQUF5QyxxREFBTTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUM4QiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJFbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVCb3hTaXplcyB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCkge1xuICAgICAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGJveGVzLmNvbnRlbnRSZWN0O1xuICAgICAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcbiAgICAgICAgdGhpcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXSk7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":
/*!************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverSize: () => (/* binding */ ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    return ResizeObserverSize;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUM2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJTaXplLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU2l6ZShpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG4gICAgICAgIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU2l6ZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   broadcastActiveObservations: () => (/* binding */ broadcastActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculateDepthForNode */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\");\n/* harmony import */ var _calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n\n\n\n\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry(ot.target);\n            var targetDepth = (0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__.calculateDepthForNode)(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = (0,_calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__.calculateBoxSize)(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ0U7QUFDRztBQUNWO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBbUI7QUFDL0MsOEJBQThCLDZFQUFxQjtBQUNuRDtBQUNBLGtDQUFrQyxtRUFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VDIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2Jyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH0gZnJvbSAnLi9jYWxjdWxhdGVEZXB0aEZvck5vZGUnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vY2FsY3VsYXRlQm94U2l6ZSc7XG52YXIgYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaGFsbG93ZXN0RGVwdGggPSBJbmZpbml0eTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG4gICAgICAgIGlmIChyby5hY3RpdmVUYXJnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIHJvLmFjdGl2ZVRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiBwcm9jZXNzVGFyZ2V0KG90KSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvdC50YXJnZXQpO1xuICAgICAgICAgICAgdmFyIHRhcmdldERlcHRoID0gY2FsY3VsYXRlRGVwdGhGb3JOb2RlKG90LnRhcmdldCk7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgb3QubGFzdFJlcG9ydGVkU2l6ZSA9IGNhbGN1bGF0ZUJveFNpemUob3QudGFyZ2V0LCBvdC5vYnNlcnZlZEJveCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCBzaGFsbG93ZXN0RGVwdGgpIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93ZXN0RGVwdGggPSB0YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIHJlc2l6ZU9ic2VydmVyQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICByby5jYWxsYmFjay5jYWxsKHJvLm9ic2VydmVyLCBlbnRyaWVzLCByby5vYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByby5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjYWxsYmFja3NfMSA9IGNhbGxiYWNrczsgX2kgPCBjYWxsYmFja3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzXzFbX2ldO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhbGxvd2VzdERlcHRoO1xufTtcbmV4cG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateBoxSize: () => (/* binding */ calculateBoxSize),\n/* harmony export */   calculateBoxSizes: () => (/* binding */ calculateBoxSizes)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserverBoxOptions */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverSize */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\");\n/* harmony import */ var _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMRectReadOnly */ \"./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n/* harmony import */ var _utils_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n\n\n\n\n\n\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(_utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator && _utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isHidden)(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = (0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isSVG)(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RTtBQUNaO0FBQ047QUFDRjtBQUNWO0FBQ0E7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlEQUFNLGNBQWMsaURBQU07QUFDMUQsd0NBQXdDO0FBQ3hDO0FBQ0EsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsZUFBZSxtRUFBa0I7QUFDakM7QUFDQSxnQkFBZ0IscURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFlO0FBQ3BDLENBQUM7QUFDRDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZEQUFlO0FBQ3hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtFQUF3QjtBQUNyQztBQUNBLGFBQWEsK0VBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbmltcG9ydCB7IERPTVJlY3RSZWFkT25seSB9IGZyb20gJy4uL0RPTVJlY3RSZWFkT25seSc7XG5pbXBvcnQgeyBpc1NWRywgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4uL3V0aWxzL2ZyZWV6ZSc7XG5pbXBvcnQgeyBnbG9iYWwgfSBmcm9tICcuLi91dGlscy9nbG9iYWwnO1xudmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzY3JvbGxSZWdleHAgPSAvYXV0b3xzY3JvbGwvO1xudmFyIHZlcnRpY2FsUmVnZXhwID0gL150Ynx2ZXJ0aWNhbC87XG52YXIgSUUgPSAoL21zaWV8dHJpZGVudC9pKS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIHBhcnNlRGltZW5zaW9uID0gZnVuY3Rpb24gKHBpeGVsKSB7IHJldHVybiBwYXJzZUZsb2F0KHBpeGVsIHx8ICcwJyk7IH07XG52YXIgc2l6ZSA9IGZ1bmN0aW9uIChpbmxpbmVTaXplLCBibG9ja1NpemUsIHN3aXRjaFNpemVzKSB7XG4gICAgaWYgKGlubGluZVNpemUgPT09IHZvaWQgMCkgeyBpbmxpbmVTaXplID0gMDsgfVxuICAgIGlmIChibG9ja1NpemUgPT09IHZvaWQgMCkgeyBibG9ja1NpemUgPSAwOyB9XG4gICAgaWYgKHN3aXRjaFNpemVzID09PSB2b2lkIDApIHsgc3dpdGNoU2l6ZXMgPSBmYWxzZTsgfVxuICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJTaXplKChzd2l0Y2hTaXplcyA/IGJsb2NrU2l6ZSA6IGlubGluZVNpemUpIHx8IDAsIChzd2l0Y2hTaXplcyA/IGlubGluZVNpemUgOiBibG9ja1NpemUpIHx8IDApO1xufTtcbnZhciB6ZXJvQm94ZXMgPSBmcmVlemUoe1xuICAgIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoKSxcbiAgICBib3JkZXJCb3hTaXplOiBzaXplKCksXG4gICAgY29udGVudEJveFNpemU6IHNpemUoKSxcbiAgICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seSgwLCAwLCAwLCAwKVxufSk7XG52YXIgY2FsY3VsYXRlQm94U2l6ZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pIHtcbiAgICBpZiAoZm9yY2VSZWNhbGN1bGF0aW9uID09PSB2b2lkIDApIHsgZm9yY2VSZWNhbGN1bGF0aW9uID0gZmFsc2U7IH1cbiAgICBpZiAoY2FjaGUuaGFzKHRhcmdldCkgJiYgIWZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChpc0hpZGRlbih0YXJnZXQpKSB7XG4gICAgICAgIGNhY2hlLnNldCh0YXJnZXQsIHplcm9Cb3hlcyk7XG4gICAgICAgIHJldHVybiB6ZXJvQm94ZXM7XG4gICAgfVxuICAgIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICB2YXIgc3ZnID0gaXNTVkcodGFyZ2V0KSAmJiB0YXJnZXQub3duZXJTVkdFbGVtZW50ICYmIHRhcmdldC5nZXRCQm94KCk7XG4gICAgdmFyIHJlbW92ZVBhZGRpbmcgPSAhSUUgJiYgY3MuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gICAgdmFyIHN3aXRjaFNpemVzID0gdmVydGljYWxSZWdleHAudGVzdChjcy53cml0aW5nTW9kZSB8fCAnJyk7XG4gICAgdmFyIGNhblNjcm9sbFZlcnRpY2FsbHkgPSAhc3ZnICYmIHNjcm9sbFJlZ2V4cC50ZXN0KGNzLm92ZXJmbG93WSB8fCAnJyk7XG4gICAgdmFyIGNhblNjcm9sbEhvcml6b250YWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dYIHx8ICcnKTtcbiAgICB2YXIgcGFkZGluZ1RvcCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nVG9wKTtcbiAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdSaWdodCk7XG4gICAgdmFyIHBhZGRpbmdCb3R0b20gPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ0JvdHRvbSk7XG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdMZWZ0KTtcbiAgICB2YXIgYm9yZGVyVG9wID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlclRvcFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyUmlnaHRXaWR0aCk7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyTGVmdFdpZHRoKTtcbiAgICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodDtcbiAgICB2YXIgdmVydGljYWxQYWRkaW5nID0gcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b207XG4gICAgdmFyIGhvcml6b250YWxCb3JkZXJBcmVhID0gYm9yZGVyTGVmdCArIGJvcmRlclJpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbEJvcmRlckFyZWEgPSBib3JkZXJUb3AgKyBib3JkZXJCb3R0b207XG4gICAgdmFyIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3MgPSAhY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID8gMCA6IHRhcmdldC5vZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcyA9ICFjYW5TY3JvbGxWZXJ0aWNhbGx5ID8gMCA6IHRhcmdldC5vZmZzZXRXaWR0aCAtIGhvcml6b250YWxCb3JkZXJBcmVhIC0gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgIHZhciB3aWR0aFJlZHVjdGlvbiA9IHJlbW92ZVBhZGRpbmcgPyBob3Jpem9udGFsUGFkZGluZyArIGhvcml6b250YWxCb3JkZXJBcmVhIDogMDtcbiAgICB2YXIgaGVpZ2h0UmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IHZlcnRpY2FsUGFkZGluZyArIHZlcnRpY2FsQm9yZGVyQXJlYSA6IDA7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IHN2ZyA/IHN2Zy53aWR0aCA6IHBhcnNlRGltZW5zaW9uKGNzLndpZHRoKSAtIHdpZHRoUmVkdWN0aW9uIC0gdmVydGljYWxTY3JvbGxiYXJUaGlja25lc3M7XG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBzdmcgPyBzdmcuaGVpZ2h0IDogcGFyc2VEaW1lbnNpb24oY3MuaGVpZ2h0KSAtIGhlaWdodFJlZHVjdGlvbiAtIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3M7XG4gICAgdmFyIGJvcmRlckJveFdpZHRoID0gY29udGVudFdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcgKyB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcyArIGhvcml6b250YWxCb3JkZXJBcmVhO1xuICAgIHZhciBib3JkZXJCb3hIZWlnaHQgPSBjb250ZW50SGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nICsgaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcyArIHZlcnRpY2FsQm9yZGVyQXJlYTtcbiAgICB2YXIgYm94ZXMgPSBmcmVlemUoe1xuICAgICAgICBkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplOiBzaXplKE1hdGgucm91bmQoY29udGVudFdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbyksIE1hdGgucm91bmQoY29udGVudEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW8pLCBzd2l0Y2hTaXplcyksXG4gICAgICAgIGJvcmRlckJveFNpemU6IHNpemUoYm9yZGVyQm94V2lkdGgsIGJvcmRlckJveEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgICAgICBjb250ZW50Qm94U2l6ZTogc2l6ZShjb250ZW50V2lkdGgsIGNvbnRlbnRIZWlnaHQsIHN3aXRjaFNpemVzKSxcbiAgICAgICAgY29udGVudFJlY3Q6IG5ldyBET01SZWN0UmVhZE9ubHkocGFkZGluZ0xlZnQsIHBhZGRpbmdUb3AsIGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodClcbiAgICB9KTtcbiAgICBjYWNoZS5zZXQodGFyZ2V0LCBib3hlcyk7XG4gICAgcmV0dXJuIGJveGVzO1xufTtcbnZhciBjYWxjdWxhdGVCb3hTaXplID0gZnVuY3Rpb24gKHRhcmdldCwgb2JzZXJ2ZWRCb3gsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgIHZhciBfYSA9IGNhbGN1bGF0ZUJveFNpemVzKHRhcmdldCwgZm9yY2VSZWNhbGN1bGF0aW9uKSwgYm9yZGVyQm94U2l6ZSA9IF9hLmJvcmRlckJveFNpemUsIGNvbnRlbnRCb3hTaXplID0gX2EuY29udGVudEJveFNpemUsIGRldmljZVBpeGVsQ29udGVudEJveFNpemUgPSBfYS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplO1xuICAgIHN3aXRjaCAob2JzZXJ2ZWRCb3gpIHtcbiAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuREVWSUNFX1BJWEVMX0NPTlRFTlRfQk9YOlxuICAgICAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgICAgIGNhc2UgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLkJPUkRFUl9CT1g6XG4gICAgICAgICAgICByZXR1cm4gYm9yZGVyQm94U2l6ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Qm94U2l6ZTtcbiAgICB9XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSwgY2FsY3VsYXRlQm94U2l6ZXMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDepthForNode: () => (/* binding */ calculateDepthForNode)\n/* harmony export */ });\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\nvar calculateDepthForNode = function (node) {\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_0__.isHidden)(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9jYWxjdWxhdGVEZXB0aEZvck5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbnZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc0hpZGRlbihub2RlKSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deliverResizeLoopError: () => (/* binding */ deliverResizeLoopError)\n/* harmony export */ });\nvar msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbXNnID0gJ1Jlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4nO1xudmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBldmVudC5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuZXhwb3J0IHsgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gatherActiveObservationsAtDepth: () => (/* binding */ gatherActiveObservationsAtDepth)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateDepthForNode */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\");\n\n\nvar gatherActiveObservationsAtDepth = function (depth) {\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if ((0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__.calculateDepthForNode)(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDSztBQUNoRTtBQUNBLElBQUksbUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDMkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH0gZnJvbSAnLi9jYWxjdWxhdGVEZXB0aEZvck5vZGUnO1xudmFyIGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICByZXNpemVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiBwcm9jZXNzT2JzZXJ2ZXIocm8pIHtcbiAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgICAgICByby5za2lwcGVkVGFyZ2V0cy5zcGxpY2UoMCwgcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoKTtcbiAgICAgICAgcm8ub2JzZXJ2YXRpb25UYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgICAgICAgaWYgKG90LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY3VsYXRlRGVwdGhGb3JOb2RlKG90LnRhcmdldCkgPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICByby5hY3RpdmVUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm8uc2tpcHBlZFRhcmdldHMucHVzaChvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnQgeyBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasActiveObservations: () => (/* binding */ hasActiveObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\nvar hasActiveObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0EsV0FBVyxtRUFBZSxzQkFBc0IscUNBQXFDO0FBQ3JGO0FBQ2lDIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2hhc0FjdGl2ZU9ic2VydmF0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIGhhc0FjdGl2ZU9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKHJvKSB7IHJldHVybiByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCA+IDA7IH0pO1xufTtcbmV4cG9ydCB7IGhhc0FjdGl2ZU9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasSkippedObservations: () => (/* binding */ hasSkippedObservations)\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\nvar hasSkippedObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUMzRDtBQUNBLFdBQVcsbUVBQWUsc0JBQXNCLHNDQUFzQztBQUN0RjtBQUNrQyIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9oYXNTa2lwcGVkT2JzZXJ2YXRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlc2l6ZU9ic2VydmVycyB9IGZyb20gJy4uL3V0aWxzL3Jlc2l6ZU9ic2VydmVycyc7XG52YXIgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKHJvKSB7IHJldHVybiByby5za2lwcGVkVGFyZ2V0cy5sZW5ndGggPiAwOyB9KTtcbn07XG5leHBvcnQgeyBoYXNTa2lwcGVkT2JzZXJ2YXRpb25zIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserver: () => (/* reexport safe */ _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__.ResizeObserver),\n/* harmony export */   ResizeObserverEntry: () => (/* reexport safe */ _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry),\n/* harmony export */   ResizeObserverSize: () => (/* reexport safe */ _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverSize)\n/* harmony export */ });\n/* harmony import */ var _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ResizeObserverSize */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNVO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXInO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/element.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHidden: () => (/* binding */ isHidden),\n/* harmony export */   isReplacedElement: () => (/* binding */ isReplacedElement),\n/* harmony export */   isSVG: () => (/* binding */ isSVG)\n/* harmony export */ });\nvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgcmV0dXJuICF3aWR0aCAmJiAhaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gIShvZmZzZXRXaWR0aCB8fCBvZmZzZXRIZWlnaHQgfHwgdGFyZ2V0LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNjb3BlID0gKF9hID0gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG59O1xudmFyIGlzUmVwbGFjZWRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICBjYXNlICdFTUJFRCc6XG4gICAgICAgIGNhc2UgJ09CSkVDVCc6XG4gICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgIGNhc2UgJ0lGUkFNRSc6XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiwgaXNFbGVtZW50LCBpc1JlcGxhY2VkRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/element.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js":
/*!******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/freeze.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   freeze: () => (/* binding */ freeze)\n/* harmony export */ });\nvar freeze = function (obj) { return Object.freeze(obj); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sOEJBQThCIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9mcmVlemUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/freeze.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/global.js":
/*!******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/global.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   global: () => (/* binding */ global)\n/* harmony export */ });\nvar global = typeof window !== 'undefined' ? window : {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/global.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/process.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/process.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   process: () => (/* binding */ process)\n/* harmony export */ });\n/* harmony import */ var _algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/hasActiveObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\");\n/* harmony import */ var _algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/hasSkippedObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\");\n/* harmony import */ var _algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/deliverResizeLoopError */ \"./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\");\n/* harmony import */ var _algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms/broadcastActiveObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\");\n/* harmony import */ var _algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithms/gatherActiveObservationsAtDepth */ \"./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\");\n\n\n\n\n\nvar process = function () {\n    var depth = 0;\n    (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    while ((0,_algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__.hasActiveObservations)()) {\n        depth = (0,_algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__.broadcastActiveObservations)();\n        (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    }\n    if ((0,_algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__.hasSkippedObservations)()) {\n        (0,_algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__.deliverResizeLoopError)();\n    }\n    return depth > 0;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQ0U7QUFDQTtBQUNVO0FBQ1E7QUFDaEc7QUFDQTtBQUNBLElBQUksNEdBQStCO0FBQ25DLFdBQVcsd0ZBQXFCO0FBQ2hDLGdCQUFnQixvR0FBMkI7QUFDM0MsUUFBUSw0R0FBK0I7QUFDdkM7QUFDQSxRQUFRLDBGQUFzQjtBQUM5QixRQUFRLDBGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQWN0aXZlT2JzZXJ2YXRpb25zIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMnO1xuaW1wb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucyc7XG5pbXBvcnQgeyBkZWxpdmVyUmVzaXplTG9vcEVycm9yIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yJztcbmltcG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zJztcbmltcG9ydCB7IGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggfSBmcm9tICcuLi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgnO1xudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcbiAgICB3aGlsZSAoaGFzQWN0aXZlT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcbiAgICAgICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gICAgfVxuICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVsaXZlclJlc2l6ZUxvb3BFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGggPiAwO1xufTtcbmV4cG9ydCB7IHByb2Nlc3MgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/process.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queueMicroTask: () => (/* binding */ queueMicroTask)\n/* harmony export */ });\nvar trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlTWljcm9UYXNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRCxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxrQkFBa0I7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9xdWV1ZU1pY3JvVGFzay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpZ2dlcjtcbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcbnZhciBxdWV1ZU1pY3JvVGFzayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgICAgICB2YXIgZWxfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuICAgICAgICB0cmlnZ2VyID0gZnVuY3Rpb24gKCkgeyBlbF8xLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodG9nZ2xlXzEgPyB0b2dnbGVfMS0tIDogdG9nZ2xlXzErKyk7IH07XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0cmlnZ2VyKCk7XG59O1xuZXhwb3J0IHsgcXVldWVNaWNyb1Rhc2sgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queueResizeObserver: () => (/* binding */ queueResizeObserver)\n/* harmony export */ });\n/* harmony import */ var _queueMicroTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queueMicroTask */ \"./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\");\n\nvar queueResizeObserver = function (cb) {\n    (0,_queueMicroTask__WEBPACK_IMPORTED_MODULE_0__.queueMicroTask)(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlUmVzaXplT2JzZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQytCIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9xdWV1ZVJlc2l6ZU9ic2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9xdWV1ZU1pY3JvVGFzayc7XG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resizeObservers: () => (/* binding */ resizeObservers)\n/* harmony export */ });\nvar resizeObservers = [];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVzaXplT2JzZXJ2ZXJzID0gW107XG5leHBvcnQgeyByZXNpemVPYnNlcnZlcnMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/scheduler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/scheduler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scheduler: () => (/* binding */ scheduler),\n/* harmony export */   updateCount: () => (/* binding */ updateCount)\n/* harmony export */ });\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process */ \"./node_modules/@juggle/resize-observer/lib/utils/process.js\");\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n/* harmony import */ var _queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\");\n\n\n\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        (0,_queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__.queueResizeObserver)(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = (0,_process__WEBPACK_IMPORTED_MODULE_0__.process)();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQzBCO0FBQzVEO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCLDJDQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sMkNBQU0sZ0RBQWdEO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLDJDQUFNLG1EQUFtRDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi9wcm9jZXNzJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuL3F1ZXVlUmVzaXplT2JzZXJ2ZXInO1xudmFyIHdhdGNoaW5nID0gMDtcbnZhciBpc1dhdGNoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF3YXRjaGluZzsgfTtcbnZhciBDQVRDSF9QRVJJT0QgPSAyNTA7XG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xudmFyIGV2ZW50cyA9IFtcbiAgICAncmVzaXplJyxcbiAgICAnbG9hZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICdhbmltYXRpb25lbmQnLFxuICAgICdhbmltYXRpb25zdGFydCcsXG4gICAgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ21vdXNldXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW92ZXInLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ2JsdXInLFxuICAgICdmb2N1cydcbl07XG52YXIgdGltZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuICAgIHJldHVybiBEYXRlLm5vdygpICsgdGltZW91dDtcbn07XG52YXIgc2NoZWR1bGVkID0gZmFsc2U7XG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2hlZHVsZSgpOyB9O1xuICAgIH1cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVudGlsID0gdGltZSh0aW1lb3V0KTtcbiAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkgPyBjYigpIDogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xudmFyIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcbnZhciB1cGRhdGVDb3VudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuICAgIHdhdGNoaW5nICs9IG47XG4gICAgIXdhdGNoaW5nICYmIHNjaGVkdWxlci5zdG9wKCk7XG59O1xuZXhwb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\n"));

/***/ }),

/***/ "./node_modules/direction/index.js":
/*!*****************************************!*\
  !*** ./node_modules/direction/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nmodule.exports = direction\n\nvar RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nvar LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nfunction direction(value) {\n  value = String(value || '')\n\n  if (rtl.test(value)) {\n    return 'rtl'\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr'\n  }\n\n  return 'neutral'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlyZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9kaXJlY3Rpb24vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZGlyZWN0aW9uXG5cbnZhciBSVEwgPSAnXFx1MDU5MS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZEXFx1RkU3MC1cXHVGRUZDJ1xudmFyIExUUiA9XG4gICdBLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjYnICtcbiAgJ1xcdTAwRjgtXFx1MDJCOFxcdTAzMDAtXFx1MDU5MFxcdTA4MDAtXFx1MUZGRlxcdTIwMEVcXHUyQzAwLVxcdUZCMUMnICtcbiAgJ1xcdUZFMDAtXFx1RkU2RlxcdUZFRkQtXFx1RkZGRidcblxudmFyIHJ0bCA9IG5ldyBSZWdFeHAoJ15bXicgKyBMVFIgKyAnXSpbJyArIFJUTCArICddJylcbnZhciBsdHIgPSBuZXcgUmVnRXhwKCdeW14nICsgUlRMICsgJ10qWycgKyBMVFIgKyAnXScpXG5cbmZ1bmN0aW9uIGRpcmVjdGlvbih2YWx1ZSkge1xuICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSB8fCAnJylcblxuICBpZiAocnRsLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuICdydGwnXG4gIH1cblxuICBpZiAobHRyLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuICdsdHInXG4gIH1cblxuICByZXR1cm4gJ25ldXRyYWwnXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/direction/index.js\n"));

/***/ }),

/***/ "./node_modules/is-hotkey/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/is-hotkey/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name]) {\n        throw new TypeError('Unknown modifier: \"' + value + '\"');\n      }\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports[\"default\"] = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxnRUFBZ0U7QUFDM0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWU7QUFDZixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG5cbnZhciBJU19NQUMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKTtcblxudmFyIE1PRElGSUVSUyA9IHtcbiAgYWx0OiAnYWx0S2V5JyxcbiAgY29udHJvbDogJ2N0cmxLZXknLFxuICBtZXRhOiAnbWV0YUtleScsXG4gIHNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG52YXIgQUxJQVNFUyA9IHtcbiAgYWRkOiAnKycsXG4gIGJyZWFrOiAncGF1c2UnLFxuICBjbWQ6ICdtZXRhJyxcbiAgY29tbWFuZDogJ21ldGEnLFxuICBjdGw6ICdjb250cm9sJyxcbiAgY3RybDogJ2NvbnRyb2wnLFxuICBkZWw6ICdkZWxldGUnLFxuICBkb3duOiAnYXJyb3dkb3duJyxcbiAgZXNjOiAnZXNjYXBlJyxcbiAgaW5zOiAnaW5zZXJ0JyxcbiAgbGVmdDogJ2Fycm93bGVmdCcsXG4gIG1vZDogSVNfTUFDID8gJ21ldGEnIDogJ2NvbnRyb2wnLFxuICBvcHQ6ICdhbHQnLFxuICBvcHRpb246ICdhbHQnLFxuICByZXR1cm46ICdlbnRlcicsXG4gIHJpZ2h0OiAnYXJyb3dyaWdodCcsXG4gIHNwYWNlOiAnICcsXG4gIHNwYWNlYmFyOiAnICcsXG4gIHVwOiAnYXJyb3d1cCcsXG4gIHdpbjogJ21ldGEnLFxuICB3aW5kb3dzOiAnbWV0YSdcbn07XG5cbnZhciBDT0RFUyA9IHtcbiAgYmFja3NwYWNlOiA4LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc2hpZnQ6IDE2LFxuICBjb250cm9sOiAxNyxcbiAgYWx0OiAxOCxcbiAgcGF1c2U6IDE5LFxuICBjYXBzbG9jazogMjAsXG4gIGVzY2FwZTogMjcsXG4gICcgJzogMzIsXG4gIHBhZ2V1cDogMzMsXG4gIHBhZ2Vkb3duOiAzNCxcbiAgZW5kOiAzNSxcbiAgaG9tZTogMzYsXG4gIGFycm93bGVmdDogMzcsXG4gIGFycm93dXA6IDM4LFxuICBhcnJvd3JpZ2h0OiAzOSxcbiAgYXJyb3dkb3duOiA0MCxcbiAgaW5zZXJ0OiA0NSxcbiAgZGVsZXRlOiA0NixcbiAgbWV0YTogOTEsXG4gIG51bWxvY2s6IDE0NCxcbiAgc2Nyb2xsbG9jazogMTQ1LFxuICAnOyc6IDE4NixcbiAgJz0nOiAxODcsXG4gICcsJzogMTg4LFxuICAnLSc6IDE4OSxcbiAgJy4nOiAxOTAsXG4gICcvJzogMTkxLFxuICAnYCc6IDE5MixcbiAgJ1snOiAyMTksXG4gICdcXFxcJzogMjIwLFxuICAnXSc6IDIyMSxcbiAgJ1xcJyc6IDIyMlxufTtcblxuZm9yICh2YXIgZiA9IDE7IGYgPCAyMDsgZisrKSB7XG4gIENPREVTWydmJyArIGZdID0gMTExICsgZjtcbn1cblxuLyoqXG4gKiBJcyBob3RrZXk/XG4gKi9cblxuZnVuY3Rpb24gaXNIb3RrZXkoaG90a2V5LCBvcHRpb25zLCBldmVudCkge1xuICBpZiAob3B0aW9ucyAmJiAhKCdieUtleScgaW4gb3B0aW9ucykpIHtcbiAgICBldmVudCA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoaG90a2V5KSkge1xuICAgIGhvdGtleSA9IFtob3RrZXldO1xuICB9XG5cbiAgdmFyIGFycmF5ID0gaG90a2V5Lm1hcChmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhcnNlSG90a2V5KHN0cmluZywgb3B0aW9ucyk7XG4gIH0pO1xuICB2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhlKSB7XG4gICAgcmV0dXJuIGFycmF5LnNvbWUoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVIb3RrZXkob2JqZWN0LCBlKTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIHJldCA9IGV2ZW50ID09IG51bGwgPyBjaGVjayA6IGNoZWNrKGV2ZW50KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaXNDb2RlSG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGlzSG90a2V5KGhvdGtleSwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBpc0tleUhvdGtleShob3RrZXksIGV2ZW50KSB7XG4gIHJldHVybiBpc0hvdGtleShob3RrZXksIHsgYnlLZXk6IHRydWUgfSwgZXZlbnQpO1xufVxuXG4vKipcbiAqIFBhcnNlLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSG90a2V5KGhvdGtleSwgb3B0aW9ucykge1xuICB2YXIgYnlLZXkgPSBvcHRpb25zICYmIG9wdGlvbnMuYnlLZXk7XG4gIHZhciByZXQgPSB7fTtcblxuICAvLyBTcGVjaWFsIGNhc2UgdG8gaGFuZGxlIHRoZSBgK2Aga2V5IHNpbmNlIHdlIHVzZSBpdCBhcyBhIHNlcGFyYXRvci5cbiAgaG90a2V5ID0gaG90a2V5LnJlcGxhY2UoJysrJywgJythZGQnKTtcbiAgdmFyIHZhbHVlcyA9IGhvdGtleS5zcGxpdCgnKycpO1xuICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAvLyBFbnN1cmUgdGhhdCBhbGwgdGhlIG1vZGlmaWVycyBhcmUgc2V0IHRvIGZhbHNlIHVubGVzcyB0aGUgaG90a2V5IGhhcyB0aGVtLlxuXG4gIGZvciAodmFyIGsgaW4gTU9ESUZJRVJTKSB7XG4gICAgcmV0W01PRElGSUVSU1trXV0gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbHVlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgb3B0aW9uYWwgPSB2YWx1ZS5lbmRzV2l0aCgnPycpICYmIHZhbHVlLmxlbmd0aCA+IDE7XG5cbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSB0b0tleU5hbWUodmFsdWUpO1xuICAgICAgdmFyIG1vZGlmaWVyID0gTU9ESUZJRVJTW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSAmJiAhbW9kaWZpZXIgJiYgIUFMSUFTRVNbdmFsdWVdICYmICFDT0RFU1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIG1vZGlmaWVyOiBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSAxIHx8ICFtb2RpZmllcikge1xuICAgICAgICBpZiAoYnlLZXkpIHtcbiAgICAgICAgICByZXQua2V5ID0gbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQud2hpY2ggPSB0b0tleUNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICByZXRbbW9kaWZpZXJdID0gb3B0aW9uYWwgPyBudWxsIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb21wYXJlLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVIb3RrZXkob2JqZWN0LCBldmVudCkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFyIGV4cGVjdGVkID0gb2JqZWN0W2tleV07XG4gICAgdmFyIGFjdHVhbCA9IHZvaWQgMDtcblxuICAgIGlmIChleHBlY3RlZCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAna2V5JyAmJiBldmVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICd3aGljaCcpIHtcbiAgICAgIGFjdHVhbCA9IGV4cGVjdGVkID09PSA5MSAmJiBldmVudC53aGljaCA9PT0gOTMgPyA5MSA6IGV2ZW50LndoaWNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3R1YWwgPSBldmVudFtrZXldO1xuICAgIH1cblxuICAgIGlmIChhY3R1YWwgPT0gbnVsbCAmJiBleHBlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVXRpbHMuXG4gKi9cblxuZnVuY3Rpb24gdG9LZXlDb2RlKG5hbWUpIHtcbiAgbmFtZSA9IHRvS2V5TmFtZShuYW1lKTtcbiAgdmFyIGNvZGUgPSBDT0RFU1tuYW1lXSB8fCBuYW1lLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNvZGU7XG59XG5cbmZ1bmN0aW9uIHRvS2V5TmFtZShuYW1lKSB7XG4gIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIG5hbWUgPSBBTElBU0VTW25hbWVdIHx8IG5hbWU7XG4gIHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0hvdGtleTtcbmV4cG9ydHMuaXNIb3RrZXkgPSBpc0hvdGtleTtcbmV4cG9ydHMuaXNDb2RlSG90a2V5ID0gaXNDb2RlSG90a2V5O1xuZXhwb3J0cy5pc0tleUhvdGtleSA9IGlzS2V5SG90a2V5O1xuZXhwb3J0cy5wYXJzZUhvdGtleSA9IHBhcnNlSG90a2V5O1xuZXhwb3J0cy5jb21wYXJlSG90a2V5ID0gY29tcGFyZUhvdGtleTtcbmV4cG9ydHMudG9LZXlDb2RlID0gdG9LZXlDb2RlO1xuZXhwb3J0cy50b0tleU5hbWUgPSB0b0tleU5hbWU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-hotkey/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLCtDQUFTOztBQUU1QjtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/_Symbol.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxtREFBVztBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBYztBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyxtRUFBbUI7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseGetTag.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ \"./node_modules/lodash/_trimmedEndIndex.js\");\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsbUJBQU8sQ0FBQyxxRUFBb0I7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUcmltLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0cmltbWVkRW5kSW5kZXggPSByZXF1aXJlKCcuL190cmltbWVkRW5kSW5kZXgnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUcmltO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseTrim.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esd0JBQXdCLHFCQUFNLGdCQUFnQixxQkFBTSxJQUFJLHFCQUFNLHNCQUFzQixxQkFBTTs7QUFFMUYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_freeGlobal.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLG1EQUFXOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_getRawTag.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/_objectToString.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFlOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_root.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL190cmltbWVkRW5kSW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdHJpbW1lZEVuZEluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmltbWVkRW5kSW5kZXg7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/_trimmedEndIndex.js\n"));

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    now = __webpack_require__(/*! ./now */ \"./node_modules/lodash/now.js\"),\n    toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/lodash/toNumber.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTtBQUNuQyxVQUFVLG1CQUFPLENBQUMsMkNBQU87QUFDekIsZUFBZSxtQkFBTyxDQUFDLHFEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgbm93ID0gcmVxdWlyZSgnLi9ub3cnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/debounce.js\n"));

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/isObject.js\n"));

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/isObjectLike.js\n"));

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFlO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLDZEQUFnQjs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/isSymbol.js\n"));

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsK0NBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/now.js\n"));

/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var debounce = __webpack_require__(/*! ./debounce */ \"./node_modules/lodash/debounce.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Rocm90dGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMscURBQVk7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsV0FBVztBQUM5QixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1CQUFtQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvbG9kYXNoL3Rocm90dGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/throttle.js\n"));

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var baseTrim = __webpack_require__(/*! ./_baseTrim */ \"./node_modules/lodash/_baseTrim.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMscURBQVk7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHFEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlVHJpbSA9IHJlcXVpcmUoJy4vX2Jhc2VUcmltJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/toNumber.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Ffabioesteves%2Frepos%2Funfoldr%2Fsrc%2Fpages%2F%5BdocumentId%5D.tsx&page=%2F%5BdocumentId%5D!":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Ffabioesteves%2Frepos%2Funfoldr%2Fsrc%2Fpages%2F%5BdocumentId%5D.tsx&page=%2F%5BdocumentId%5D! ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/[documentId]\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/[documentId].tsx */ \"./src/pages/[documentId].tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/[documentId]\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmZhYmlvZXN0ZXZlcyUyRnJlcG9zJTJGdW5mb2xkciUyRnNyYyUyRnBhZ2VzJTJGJTVCZG9jdW1lbnRJZCU1RC50c3gmcGFnZT0lMkYlNUJkb2N1bWVudElkJTVEISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtFQUE4QjtBQUNyRDtBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9bZG9jdW1lbnRJZF1cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9bZG9jdW1lbnRJZF0udHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9bZG9jdW1lbnRJZF1cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Ffabioesteves%2Frepos%2Funfoldr%2Fsrc%2Fpages%2F%5BdocumentId%5D.tsx&page=%2F%5BdocumentId%5D!\n"));

/***/ }),

/***/ "./src/pages/[documentId].tsx":
/*!************************************!*\
  !*** ./src/pages/[documentId].tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! slate */ \"./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! slate-react */ \"./node_modules/slate-react/dist/index.es.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst DocumentPage = ()=>{\n    _s();\n    const editor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"DocumentPage.useMemo[editor]\": ()=>(0,slate_react__WEBPACK_IMPORTED_MODULE_2__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_3__.createEditor)())\n    }[\"DocumentPage.useMemo[editor]\"], []);\n    const [title, setTitle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('Untitled Document');\n    const [isEditingTitle, setIsEditingTitle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const initialValue = [\n        {\n            type: 'paragraph',\n            children: [\n                {\n                    text: ''\n                }\n            ]\n        }\n    ];\n    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(initialValue);\n    const handleTitleEdit = (e)=>{\n        if (e.key === 'Enter') {\n            setIsEditingTitle(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-100 p-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"max-w-[850px] mx-auto mb-4\",\n                children: isEditingTitle ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    type: \"text\",\n                    value: title,\n                    onChange: (e)=>setTitle(e.target.value),\n                    onKeyDown: handleTitleEdit,\n                    onBlur: ()=>setIsEditingTitle(false),\n                    className: \"text-xl font-semibold text-gray-700 bg-transparent border-b border-gray-300 focus:outline-none focus:border-blue-500 w-full\",\n                    autoFocus: true\n                }, void 0, false, {\n                    fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                    lineNumber: 30,\n                    columnNumber: 11\n                }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"group relative inline-block\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-xl font-semibold text-gray-700 cursor-pointer group-hover:text-gray-900\",\n                            onClick: ()=>setIsEditingTitle(true),\n                            children: title\n                        }, void 0, false, {\n                            fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                            lineNumber: 41,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"hidden group-hover:block absolute -top-5 left-0 text-xs text-gray-500\",\n                            children: \"Click to edit\"\n                        }, void 0, false, {\n                            fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                            lineNumber: 47,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"hidden group-hover:block absolute bottom-0 left-0 right-0 h-px bg-gray-300\"\n                        }, void 0, false, {\n                            fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                            lineNumber: 50,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                    lineNumber: 40,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                lineNumber: 28,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"max-w-[850px] min-h-[1100px] mx-auto bg-white rounded-2xl shadow-lg p-12\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(slate_react__WEBPACK_IMPORTED_MODULE_2__.Slate, {\n                    editor: editor,\n                    initialValue: initialValue,\n                    onChange: (newValue)=>setValue(newValue),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(slate_react__WEBPACK_IMPORTED_MODULE_2__.Editable, {\n                        className: \"outline-none min-h-full\",\n                        placeholder: \"Start typing...\"\n                    }, void 0, false, {\n                        fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                        lineNumber: 61,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n                lineNumber: 55,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/fabioesteves/repos/unfoldr/src/pages/[documentId].tsx\",\n        lineNumber: 27,\n        columnNumber: 5\n    }, undefined);\n};\n_s(DocumentPage, \"kJdOZwQ9iw8AdVkKXqE+IC5DwBc=\");\n_c = DocumentPage;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DocumentPage);\nvar _c;\n$RefreshReg$(_c, \"DocumentPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvW2RvY3VtZW50SWRdLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDZjtBQUNRO0FBSXpELE1BQU1PLGVBQWU7O0lBQ25CLE1BQU1DLFNBQVNQLDhDQUFPQTt3Q0FBQyxJQUFNSyxzREFBU0EsQ0FBQ0gsbURBQVlBO3VDQUFLLEVBQUU7SUFDMUQsTUFBTSxDQUFDTSxPQUFPQyxTQUFTLEdBQUdSLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ1MsZ0JBQWdCQyxrQkFBa0IsR0FBR1YsK0NBQVFBLENBQUM7SUFDckQsTUFBTVcsZUFBNkI7UUFDakM7WUFDRUMsTUFBTTtZQUNOQyxVQUFVO2dCQUFDO29CQUFFQyxNQUFNO2dCQUFHO2FBQUU7UUFDMUI7S0FDRDtJQUVELE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHbEIscURBQWMsQ0FBZWE7SUFFdkQsTUFBTU0sa0JBQWtCLENBQUNDO1FBQ3ZCLElBQUlBLEVBQUVDLEdBQUcsS0FBSyxTQUFTO1lBQ3JCVCxrQkFBa0I7UUFDcEI7SUFDRjtJQUVBLHFCQUNFLDhEQUFDVTtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0M7Z0JBQU9ELFdBQVU7MEJBQ2ZaLCtCQUNDLDhEQUFDYztvQkFDQ1gsTUFBSztvQkFDTEcsT0FBT1I7b0JBQ1BpQixVQUFVLENBQUNOLElBQU1WLFNBQVNVLEVBQUVPLE1BQU0sQ0FBQ1YsS0FBSztvQkFDeENXLFdBQVdUO29CQUNYVSxRQUFRLElBQU1qQixrQkFBa0I7b0JBQ2hDVyxXQUFVO29CQUNWTyxTQUFTOzs7Ozs4Q0FHWCw4REFBQ1I7b0JBQUlDLFdBQVU7O3NDQUNiLDhEQUFDUTs0QkFDQ1IsV0FBVTs0QkFDVlMsU0FBUyxJQUFNcEIsa0JBQWtCO3NDQUVoQ0g7Ozs7OztzQ0FFSCw4REFBQ2E7NEJBQUlDLFdBQVU7c0NBQXdFOzs7Ozs7c0NBR3ZGLDhEQUFDRDs0QkFBSUMsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBS3JCLDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ25CLDhDQUFLQTtvQkFDSkksUUFBUUE7b0JBQ1JLLGNBQWNBO29CQUNkYSxVQUFVTyxDQUFBQSxXQUFZZixTQUFTZTs4QkFFL0IsNEVBQUM1QixpREFBUUE7d0JBQ1BrQixXQUFVO3dCQUNWVyxhQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXhCO0dBOURNM0I7S0FBQUE7QUFnRU4saUVBQWVBLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mYWJpb2VzdGV2ZXMvcmVwb3MvdW5mb2xkci9zcmMvcGFnZXMvW2RvY3VtZW50SWRdLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlU3RhdGUsIEtleWJvYXJkRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVFZGl0b3IsIERlc2NlbmRhbnQgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBTbGF0ZSwgRWRpdGFibGUsIHdpdGhSZWFjdCB9IGZyb20gJ3NsYXRlLXJlYWN0JztcblxudHlwZSBQYXJhZ3JhcGhFbGVtZW50ID0geyB0eXBlOiAncGFyYWdyYXBoJzsgY2hpbGRyZW46IHsgdGV4dDogc3RyaW5nIH1bXSB9O1xuXG5jb25zdCBEb2N1bWVudFBhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZU1lbW8oKCkgPT4gd2l0aFJlYWN0KGNyZWF0ZUVkaXRvcigpKSwgW10pO1xuICBjb25zdCBbdGl0bGUsIHNldFRpdGxlXSA9IHVzZVN0YXRlKCdVbnRpdGxlZCBEb2N1bWVudCcpO1xuICBjb25zdCBbaXNFZGl0aW5nVGl0bGUsIHNldElzRWRpdGluZ1RpdGxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgaW5pdGlhbFZhbHVlOiBEZXNjZW5kYW50W10gPSBbXG4gICAge1xuICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICBjaGlsZHJlbjogW3sgdGV4dDogJycgfV0sXG4gICAgfSBhcyBQYXJhZ3JhcGhFbGVtZW50LFxuICBdO1xuXG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGU8RGVzY2VuZGFudFtdPihpbml0aWFsVmFsdWUpO1xuXG4gIGNvbnN0IGhhbmRsZVRpdGxlRWRpdCA9IChlOiBLZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICBzZXRJc0VkaXRpbmdUaXRsZShmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctZ3JheS0xMDAgcC04XCI+XG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cIm1heC13LVs4NTBweF0gbXgtYXV0byBtYi00XCI+XG4gICAgICAgIHtpc0VkaXRpbmdUaXRsZSA/IChcbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlPXt0aXRsZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0VGl0bGUoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVUaXRsZUVkaXR9XG4gICAgICAgICAgICBvbkJsdXI9eygpID0+IHNldElzRWRpdGluZ1RpdGxlKGZhbHNlKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZCB0ZXh0LWdyYXktNzAwIGJnLXRyYW5zcGFyZW50IGJvcmRlci1iIGJvcmRlci1ncmF5LTMwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwIHctZnVsbFwiXG4gICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAvPlxuICAgICAgICApIDogKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JvdXAgcmVsYXRpdmUgaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICA8aDEgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZCB0ZXh0LWdyYXktNzAwIGN1cnNvci1wb2ludGVyIGdyb3VwLWhvdmVyOnRleHQtZ3JheS05MDBcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc0VkaXRpbmdUaXRsZSh0cnVlKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgICAgPC9oMT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGlkZGVuIGdyb3VwLWhvdmVyOmJsb2NrIGFic29sdXRlIC10b3AtNSBsZWZ0LTAgdGV4dC14cyB0ZXh0LWdyYXktNTAwXCI+XG4gICAgICAgICAgICAgIENsaWNrIHRvIGVkaXRcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoaWRkZW4gZ3JvdXAtaG92ZXI6YmxvY2sgYWJzb2x1dGUgYm90dG9tLTAgbGVmdC0wIHJpZ2h0LTAgaC1weCBiZy1ncmF5LTMwMFwiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy1bODUwcHhdIG1pbi1oLVsxMTAwcHhdIG14LWF1dG8gYmctd2hpdGUgcm91bmRlZC0yeGwgc2hhZG93LWxnIHAtMTJcIj5cbiAgICAgICAgPFNsYXRlIFxuICAgICAgICAgIGVkaXRvcj17ZWRpdG9yfSBcbiAgICAgICAgICBpbml0aWFsVmFsdWU9e2luaXRpYWxWYWx1ZX0gXG4gICAgICAgICAgb25DaGFuZ2U9e25ld1ZhbHVlID0+IHNldFZhbHVlKG5ld1ZhbHVlKX1cbiAgICAgICAgPlxuICAgICAgICAgIDxFZGl0YWJsZVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwib3V0bGluZS1ub25lIG1pbi1oLWZ1bGxcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTdGFydCB0eXBpbmcuLi5cIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvU2xhdGU+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERvY3VtZW50UGFnZTsgIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwiY3JlYXRlRWRpdG9yIiwiU2xhdGUiLCJFZGl0YWJsZSIsIndpdGhSZWFjdCIsIkRvY3VtZW50UGFnZSIsImVkaXRvciIsInRpdGxlIiwic2V0VGl0bGUiLCJpc0VkaXRpbmdUaXRsZSIsInNldElzRWRpdGluZ1RpdGxlIiwiaW5pdGlhbFZhbHVlIiwidHlwZSIsImNoaWxkcmVuIiwidGV4dCIsInZhbHVlIiwic2V0VmFsdWUiLCJoYW5kbGVUaXRsZUVkaXQiLCJlIiwia2V5IiwiZGl2IiwiY2xhc3NOYW1lIiwiaGVhZGVyIiwiaW5wdXQiLCJvbkNoYW5nZSIsInRhcmdldCIsIm9uS2V5RG93biIsIm9uQmx1ciIsImF1dG9Gb2N1cyIsImgxIiwib25DbGljayIsIm5ld1ZhbHVlIiwicGxhY2Vob2xkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/[documentId].tsx\n"));

/***/ }),

/***/ "./node_modules/slate-dom/dist/index.es.js":
/*!*************************************************!*\
  !*** ./node_modules/slate-dom/dist/index.es.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   DOMEditor: () => (/* binding */ DOMEditor),\n/* harmony export */   DOMElement: () => (/* binding */ DOMElement),\n/* harmony export */   DOMNode: () => (/* binding */ DOMNode),\n/* harmony export */   DOMRange: () => (/* binding */ DOMRange),\n/* harmony export */   DOMSelection: () => (/* binding */ DOMSelection),\n/* harmony export */   DOMStaticRange: () => (/* binding */ DOMStaticRange),\n/* harmony export */   DOMText: () => (/* binding */ DOMText),\n/* harmony export */   EDITOR_TO_ELEMENT: () => (/* binding */ EDITOR_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_FORCE_RENDER: () => (/* binding */ EDITOR_TO_FORCE_RENDER),\n/* harmony export */   EDITOR_TO_KEY_TO_ELEMENT: () => (/* binding */ EDITOR_TO_KEY_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_ON_CHANGE: () => (/* binding */ EDITOR_TO_ON_CHANGE),\n/* harmony export */   EDITOR_TO_PENDING_ACTION: () => (/* binding */ EDITOR_TO_PENDING_ACTION),\n/* harmony export */   EDITOR_TO_PENDING_DIFFS: () => (/* binding */ EDITOR_TO_PENDING_DIFFS),\n/* harmony export */   EDITOR_TO_PENDING_INSERTION_MARKS: () => (/* binding */ EDITOR_TO_PENDING_INSERTION_MARKS),\n/* harmony export */   EDITOR_TO_PENDING_SELECTION: () => (/* binding */ EDITOR_TO_PENDING_SELECTION),\n/* harmony export */   EDITOR_TO_PLACEHOLDER_ELEMENT: () => (/* binding */ EDITOR_TO_PLACEHOLDER_ELEMENT),\n/* harmony export */   EDITOR_TO_SCHEDULE_FLUSH: () => (/* binding */ EDITOR_TO_SCHEDULE_FLUSH),\n/* harmony export */   EDITOR_TO_USER_MARKS: () => (/* binding */ EDITOR_TO_USER_MARKS),\n/* harmony export */   EDITOR_TO_USER_SELECTION: () => (/* binding */ EDITOR_TO_USER_SELECTION),\n/* harmony export */   EDITOR_TO_WINDOW: () => (/* binding */ EDITOR_TO_WINDOW),\n/* harmony export */   ELEMENT_TO_NODE: () => (/* binding */ ELEMENT_TO_NODE),\n/* harmony export */   HAS_BEFORE_INPUT_SUPPORT: () => (/* binding */ HAS_BEFORE_INPUT_SUPPORT),\n/* harmony export */   Hotkeys: () => (/* binding */ hotkeys),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_COMPOSING: () => (/* binding */ IS_COMPOSING),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_FIREFOX_LEGACY: () => (/* binding */ IS_FIREFOX_LEGACY),\n/* harmony export */   IS_FOCUSED: () => (/* binding */ IS_FOCUSED),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_NODE_MAP_DIRTY: () => (/* binding */ IS_NODE_MAP_DIRTY),\n/* harmony export */   IS_READ_ONLY: () => (/* binding */ IS_READ_ONLY),\n/* harmony export */   IS_UC_MOBILE: () => (/* binding */ IS_UC_MOBILE),\n/* harmony export */   IS_WEBKIT: () => (/* binding */ IS_WEBKIT),\n/* harmony export */   IS_WECHATBROWSER: () => (/* binding */ IS_WECHATBROWSER),\n/* harmony export */   Key: () => (/* binding */ Key),\n/* harmony export */   MARK_PLACEHOLDER_SYMBOL: () => (/* binding */ MARK_PLACEHOLDER_SYMBOL),\n/* harmony export */   NODE_TO_ELEMENT: () => (/* binding */ NODE_TO_ELEMENT),\n/* harmony export */   NODE_TO_INDEX: () => (/* binding */ NODE_TO_INDEX),\n/* harmony export */   NODE_TO_KEY: () => (/* binding */ NODE_TO_KEY),\n/* harmony export */   NODE_TO_PARENT: () => (/* binding */ NODE_TO_PARENT),\n/* harmony export */   PLACEHOLDER_SYMBOL: () => (/* binding */ PLACEHOLDER_SYMBOL),\n/* harmony export */   TRIPLE_CLICK: () => (/* binding */ TRIPLE_CLICK),\n/* harmony export */   applyStringDiff: () => (/* binding */ applyStringDiff),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getDefaultView: () => (/* binding */ getDefaultView),\n/* harmony export */   getSelection: () => (/* binding */ getSelection),\n/* harmony export */   hasShadowRoot: () => (/* binding */ hasShadowRoot),\n/* harmony export */   isAfter: () => (/* binding */ isAfter),\n/* harmony export */   isBefore: () => (/* binding */ isBefore),\n/* harmony export */   isDOMElement: () => (/* binding */ isDOMElement),\n/* harmony export */   isDOMNode: () => (/* binding */ isDOMNode),\n/* harmony export */   isDOMSelection: () => (/* binding */ isDOMSelection),\n/* harmony export */   isElementDecorationsEqual: () => (/* binding */ isElementDecorationsEqual),\n/* harmony export */   isPlainTextOnlyPaste: () => (/* binding */ isPlainTextOnlyPaste),\n/* harmony export */   isTextDecorationsEqual: () => (/* binding */ isTextDecorationsEqual),\n/* harmony export */   isTrackedMutation: () => (/* binding */ isTrackedMutation),\n/* harmony export */   mergeStringDiffs: () => (/* binding */ mergeStringDiffs),\n/* harmony export */   normalizeDOMPoint: () => (/* binding */ normalizeDOMPoint),\n/* harmony export */   normalizePoint: () => (/* binding */ normalizePoint),\n/* harmony export */   normalizeRange: () => (/* binding */ normalizeRange),\n/* harmony export */   normalizeStringDiff: () => (/* binding */ normalizeStringDiff),\n/* harmony export */   targetRange: () => (/* binding */ targetRange),\n/* harmony export */   verifyDiffState: () => (/* binding */ verifyDiffState),\n/* harmony export */   withDOM: () => (/* binding */ withDOM)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-hotkey */ \"./node_modules/is-hotkey/lib/index.js\");\n\n\n\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint;\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = domNode => {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = root => {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var {\n    document\n  } = DOMEditor.getWindow(editor);\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = () => {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\n\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nclass Key {\n  constructor() {\n    _defineProperty(this, \"id\", void 0);\n    this.id = \"\".concat(n++);\n  }\n}\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n  androidScheduleFlush: editor => {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: editor => {\n    var {\n      selection\n    } = editor;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_1__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_1__.Editor.after(editor, edge);\n      if (point) {\n        var _range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var {\n      document\n    } = DOMEditor.getWindow(editor);\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: (editor, node) => {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: (editor, node) => {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(() => {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: editor => {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n    editable: true\n  }),\n  hasRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: (editor, target) => DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n  hasTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n  insertData: (editor, data) => {\n    editor.insertData(data);\n  },\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n  insertTextData: (editor, data) => editor.insertTextData(data),\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),\n  toDOMNode: (editor, node) => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: (editor, point) => {\n    var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(editor, point.path);\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: (editor, domNode) => {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: (editor, domPoint, options) => {\n    var {\n      exactMatch,\n      suppressThrow,\n      searchDirection = 'backward'\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = node => node ? node.querySelectorAll(\n        // Exclude leaf nodes in nested editors\n        '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [...getLeafNodes(elementNode), ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)];\n          leafNode = (_leafNodes$find = _leafNodes.find(leaf => isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling), ...getLeafNodes(elementNode)];\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(leaf => isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var {\n          path: _path,\n          offset: _offset\n        } = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, DOMEditor.findPath(editor, _slateNode));\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n  toSlateRange: (editor, domRange, options) => {\n    var _focusNode$textConten;\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            }\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.next(path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, nextPath);\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(editor, {\n    match: n => slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(editor, n),\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.next(editor, {\n      at: path,\n      match: slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText\n    });\n    if (!entry || !slate__WEBPACK_IMPORTED_MODULE_1__.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path,\n    offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var {\n    diff\n  } = textDiff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'split_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Range.end(parentRange));\n  var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_1__.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(e, {\n        match: n => slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(e, n),\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(currentLineRange)) {\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = op => {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.common(slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          var changedPath;\n          if (slate__WEBPACK_IMPORTED_MODULE_1__.Path.isBefore(op.path, op.newPath)) {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n            changedPath = op.newPath;\n          } else {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath)));\n            changedPath = op.path;\n          }\n          var changedNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.pathRef(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n        {\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var [path, key] of matches) {\n      var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var [pathRef, _key] of pathRefMatches) {\n      if (pathRef.current) {\n        var [_node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, pathRef.current);\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n    if (!selection) {\n      return;\n    }\n    var [start, end] = slate__WEBPACK_IMPORTED_MODULE_1__.Range.edges(selection);\n    var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n      at: end.path\n    });\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = data => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      for (var line of lines) {\n        if (split) {\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n        e.insertText(line);\n        split = true;\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = options => {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = (e, path) => {\n  var matches = [];\n  for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_1__.Editor.levels(e, {\n    at: path\n  })) {\n    var key = DOMEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n  return matches;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(generic);\n  var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(apple);\n  var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other) => {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xhdGUtZG9tL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEY7QUFDekQ7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2Q0FBVTtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUFPLG9CQUFvQix5Q0FBTTtBQUN6QztBQUNBO0FBQ0EsaUJBQWlCLHlDQUFNO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQLDJCQUEyQix5Q0FBTSx3QkFBd0IseUNBQU07QUFDL0Q7QUFDQSxxQkFBcUIseUNBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBTTtBQUNsQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQ0FBUTtBQUM5RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2Q0FBVSxnQkFBZ0IseUNBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixXQUFXLHlDQUFNLGlDQUFpQyx5Q0FBTTtBQUN4RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU8seUJBQXlCLHlDQUFNO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQU07QUFDeEI7QUFDQSwyRUFBMkUsMkNBQVE7QUFDbkY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix5Q0FBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQU07QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDJDQUFRO0FBQ3JGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLHdDQUFLO0FBQzFCO0FBQ0EsbUJBQW1CLHdDQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRSx5Q0FBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0NBQUssc0JBQXNCLHdDQUFLLGdEQUFnRCx5Q0FBTTtBQUM5RjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMseUNBQU07QUFDcEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixPQUFPLHlDQUFNO0FBQ2I7QUFDQTtBQUNBLGFBQWEsdUNBQUk7QUFDakIsT0FBTyx1Q0FBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQUk7QUFDckIsT0FBTyx5Q0FBTTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQUk7QUFDckIsU0FBUyx1Q0FBSTtBQUNiO0FBQ0E7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osT0FBTyx5Q0FBTTtBQUNiO0FBQ0E7QUFDQSxhQUFhLHVDQUFJO0FBQ2pCLE9BQU8sdUNBQUk7QUFDWDtBQUNBO0FBQ0Esb0JBQW9CLHlDQUFNO0FBQzFCLGdCQUFnQiwwQ0FBTyxpQkFBaUIseUNBQU07QUFDOUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQU07QUFDdEI7QUFDQSxhQUFhLHVDQUFJO0FBQ2pCLEtBQUs7QUFDTCxtQkFBbUIsdUNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdDQUFLO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyx1Q0FBSTtBQUNmLEdBQUc7QUFDSDtBQUNBLFdBQVcsd0NBQUs7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUFLO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUFLO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdDQUFLO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVDQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUNBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVDQUFJO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0JBQWdCLHVDQUFJO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUNBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxnQkFBZ0IsdUNBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIseUNBQU0sZUFBZSx3Q0FBSztBQUN0RCw2QkFBNkIseUNBQU07QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUFNO0FBQ3RDLFdBQVcseUNBQU07QUFDakI7QUFDQTtBQUNBLFdBQVcseUNBQU07QUFDakI7QUFDQTtBQUNBLGtDQUFrQyx5Q0FBTTtBQUN4QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUNBQU07QUFDZjs7QUFFQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBSztBQUM1Qiw2QkFBNkIseUNBQU07QUFDbkMsb0JBQW9CLDBDQUFPLGlCQUFpQix5Q0FBTTtBQUNsRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUNBQWlDLHlDQUFNO0FBQ3ZDO0FBQ0EsYUFBYSx3Q0FBSztBQUNsQixVQUFVLDZDQUFVO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdDQUFLO0FBQ3BCLHlFQUF5RSxvQkFBb0I7QUFDN0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVDQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVDQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUNBQUksUUFBUSx1Q0FBSSxrQkFBa0IsdUNBQUk7QUFDakU7QUFDQTtBQUNBLGNBQWMsdUNBQUk7QUFDbEIsMENBQTBDLHVDQUFJO0FBQzlDO0FBQ0EsWUFBWTtBQUNaLDBDQUEwQyx1Q0FBSTtBQUM5QztBQUNBO0FBQ0EsNEJBQTRCLHVDQUFJLGFBQWEsdUNBQUk7QUFDakQ7QUFDQSwrQkFBK0IseUNBQU0sWUFBWSx1Q0FBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5Q0FBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBSztBQUM1QixvQkFBb0IseUNBQU07QUFDMUI7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLHlDQUFNO0FBQ3hCO0FBQ0EsS0FBSztBQUNMLFFBQVEsd0NBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUFVO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlDQUFNO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtREFBUTtBQUNyQyx5QkFBeUIsbURBQVE7QUFDakMsNkJBQTZCLG1EQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLFNBQVMsd0NBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5bkM7QUFDem5DIiwic291cmNlcyI6WyIvVXNlcnMvZmFiaW9lc3RldmVzL3JlcG9zL3VuZm9sZHIvbm9kZV9tb2R1bGVzL3NsYXRlLWRvbS9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zZm9ybXMsIEVsZW1lbnQsIEVkaXRvciwgU2NydWJiZXIsIFJhbmdlLCBOb2RlLCBUZXh0LCBQYXRoLCBQb2ludCB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IGlzSG90a2V5IH0gZnJvbSAnaXMtaG90a2V5JztcblxuLyoqXG4gKiBUeXBlcy5cbiAqL1xuLy8gQ09NUEFUOiBUaGlzIGlzIHJlcXVpcmVkIHRvIHByZXZlbnQgVHlwZVNjcmlwdCBhbGlhc2VzIGZyb20gZG9pbmcgc29tZSB2ZXJ5XG4vLyB3ZWlyZCB0aGluZ3MgZm9yIFNsYXRlJ3MgdHlwZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGdsb2JhbHMuICgyMDE5LzExLzI3KVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNTAwMlxudmFyIERPTU5vZGUgPSBnbG9iYWxUaGlzLk5vZGU7XG52YXIgRE9NRWxlbWVudCA9IGdsb2JhbFRoaXMuRWxlbWVudDtcbnZhciBET01UZXh0ID0gZ2xvYmFsVGhpcy5UZXh0O1xudmFyIERPTVJhbmdlID0gZ2xvYmFsVGhpcy5SYW5nZTtcbnZhciBET01TZWxlY3Rpb24gPSBnbG9iYWxUaGlzLlNlbGVjdGlvbjtcbnZhciBET01TdGF0aWNSYW5nZSA9IGdsb2JhbFRoaXMuU3RhdGljUmFuZ2U7XG4vKipcbiAqIFJldHVybnMgdGhlIGhvc3Qgd2luZG93IG9mIGEgRE9NIG5vZGVcbiAqL1xudmFyIGdldERlZmF1bHRWaWV3ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3duZXJEb2N1bWVudCAmJiB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG51bGw7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxuICovXG52YXIgaXNET01Db21tZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gODtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxuICovXG52YXIgaXNET01FbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gbm9kZS5cbiAqL1xudmFyIGlzRE9NTm9kZSA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHZhbHVlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93Lk5vZGU7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIHNlbGVjdGlvbi5cbiAqL1xudmFyIGlzRE9NU2VsZWN0aW9uID0gdmFsdWUgPT4ge1xuICB2YXIgd2luZG93ID0gdmFsdWUgJiYgdmFsdWUuYW5jaG9yTm9kZSAmJiBnZXREZWZhdWx0Vmlldyh2YWx1ZS5hbmNob3JOb2RlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93LlNlbGVjdGlvbjtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxuICovXG52YXIgaXNET01UZXh0ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cbiAqL1xudmFyIGlzUGxhaW5UZXh0T25seVBhc3RlID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSAhPT0gJycgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcy5sZW5ndGggPT09IDE7XG59O1xuLyoqXG4gKiBOb3JtYWxpemUgYSBET00gcG9pbnQgc28gdGhhdCBpdCBhbHdheXMgcmVmZXJzIHRvIGEgdGV4dCBub2RlLlxuICovXG52YXIgbm9ybWFsaXplRE9NUG9pbnQgPSBkb21Qb2ludCA9PiB7XG4gIHZhciBbbm9kZSwgb2Zmc2V0XSA9IGRvbVBvaW50O1xuICAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cbiAgaWYgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlzTGFzdCA9IG9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBpc0xhc3QgPyBvZmZzZXQgLSAxIDogb2Zmc2V0O1xuICAgIFtub2RlLCBpbmRleF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgobm9kZSwgaW5kZXgsIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpO1xuICAgIC8vIElmIHRoZSBlZGl0YWJsZSBjaGlsZCBmb3VuZCBpcyBpbiBmcm9udCBvZiBpbnB1dCBvZmZzZXQsIHdlIGluc3RlYWQgc2VlayB0byBpdHMgZW5kXG4gICAgaXNMYXN0ID0gaW5kZXggPCBvZmZzZXQ7XG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIGNoaWxkcmVuLCB0cmF2ZXJzZSB1bnRpbCB3ZSBoYXZlIGEgbGVhZiBub2RlLiBMZWFmIG5vZGVzXG4gICAgLy8gY2FuIGJlIGVpdGhlciB0ZXh0IG5vZGVzLCBvciBvdGhlciB2b2lkIERPTSBub2Rlcy5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgfVxuICAgIC8vIERldGVybWluZSB0aGUgbmV3IG9mZnNldCBpbnNpZGUgdGhlIHRleHQgbm9kZS5cbiAgICBvZmZzZXQgPSBpc0xhc3QgJiYgbm9kZS50ZXh0Q29udGVudCAhPSBudWxsID8gbm9kZS50ZXh0Q29udGVudC5sZW5ndGggOiAwO1xuICB9XG4gIC8vIFJldHVybiB0aGUgbm9kZSBhbmQgb2Zmc2V0LlxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIG5lc3RlZCB3aXRoaW4gYSBzaGFkb3dSb290XG4gKi9cbnZhciBoYXNTaGFkb3dSb290ID0gbm9kZSA9PiB7XG4gIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGFuZCBpbmRleCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcbiAqIGBkaXJlY3Rpb25gLlxuICovXG52YXIgZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4ID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkTm9kZXNcbiAgfSA9IHBhcmVudDtcbiAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpbmRleF07XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciB0cmllZEZvcndhcmQgPSBmYWxzZTtcbiAgdmFyIHRyaWVkQmFja3dhcmQgPSBmYWxzZTtcbiAgLy8gV2hpbGUgdGhlIGNoaWxkIGlzIGEgY29tbWVudCBub2RlLCBvciBhbiBlbGVtZW50IG5vZGUgd2l0aCBubyBjaGlsZHJlbixcbiAgLy8ga2VlcCBpdGVyYXRpbmcgdG8gZmluZCBhIHNpYmxpbmcgbm9uLXZvaWQsIG5vbi1jb21tZW50IG5vZGUuXG4gIHdoaWxlIChpc0RPTUNvbW1lbnQoY2hpbGQpIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgaWYgKHRyaWVkRm9yd2FyZCAmJiB0cmllZEJhY2t3YXJkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGkgPj0gY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRyaWVkRm9yd2FyZCA9IHRydWU7XG4gICAgICBpID0gaW5kZXggLSAxO1xuICAgICAgZGlyZWN0aW9uID0gJ2JhY2t3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRyaWVkQmFja3dhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgaW5kZXggPSBpO1xuICAgIGkgKz0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIFtjaGlsZCwgaW5kZXhdO1xufTtcbi8qKlxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xuICogYGRpcmVjdGlvbmAuXG4gKi9cbnZhciBnZXRFZGl0YWJsZUNoaWxkID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIgW2NoaWxkXSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuLyoqXG4gKiBHZXQgYSBwbGFpbnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRlbnQgb2YgYSBub2RlLCBhY2NvdW50aW5nIGZvciBibG9ja1xuICogZWxlbWVudHMgd2hpY2ggZ2V0IGEgbmV3bGluZSBhcHBlbmRlZC5cbiAqXG4gKiBUaGUgZG9tTm9kZSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gKi9cbnZhciBnZXRQbGFpblRleHQgPSBkb21Ob2RlID0+IHtcbiAgdmFyIHRleHQgPSAnJztcbiAgaWYgKGlzRE9NVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBkb21Ob2RlLm5vZGVWYWx1ZTtcbiAgfVxuICBpZiAoaXNET01FbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgZm9yICh2YXIgY2hpbGROb2RlIG9mIEFycmF5LmZyb20oZG9tTm9kZS5jaGlsZE5vZGVzKSkge1xuICAgICAgdGV4dCArPSBnZXRQbGFpblRleHQoY2hpbGROb2RlKTtcbiAgICB9XG4gICAgdmFyIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBkaXNwbGF5ID09PSAnbGlzdCcgfHwgZG9tTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG4vKipcbiAqIEdldCB4LXNsYXRlLWZyYWdtZW50IGF0dHJpYnV0ZSBmcm9tIGRhdGEtc2xhdGUtZnJhZ21lbnRcbiAqL1xudmFyIGNhdGNoU2xhdGVGcmFnbWVudCA9IC9kYXRhLXNsYXRlLWZyYWdtZW50PVwiKC4rPylcIi9tO1xudmFyIGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUgPSBkYXRhVHJhbnNmZXIgPT4ge1xuICB2YXIgaHRtbERhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIHZhciBbLCBmcmFnbWVudF0gPSBodG1sRGF0YS5tYXRjaChjYXRjaFNsYXRlRnJhZ21lbnQpIHx8IFtdO1xuICByZXR1cm4gZnJhZ21lbnQ7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGRvbSBzZWxlY3Rpb24gZnJvbSBTaGFkb3cgUm9vdCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGZyb20gdGhlIGRvY3VtZW50XG4gKi9cbnZhciBnZXRTZWxlY3Rpb24gPSByb290ID0+IHtcbiAgaWYgKHJvb3QuZ2V0U2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICByZXR1cm4gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG59O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cbiAqL1xudmFyIGlzVHJhY2tlZE11dGF0aW9uID0gKGVkaXRvciwgbXV0YXRpb24sIGJhdGNoKSA9PiB7XG4gIHZhciB7XG4gICAgdGFyZ2V0XG4gIH0gPSBtdXRhdGlvbjtcbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIge1xuICAgIGRvY3VtZW50XG4gIH0gPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHZhciBwYXJlbnRNdXRhdGlvbiA9IGJhdGNoLmZpbmQoX3JlZiA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGFkZGVkTm9kZXMsXG4gICAgICByZW1vdmVkTm9kZXNcbiAgICB9ID0gX3JlZjtcbiAgICBmb3IgKHZhciBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlID09PSB0YXJnZXQgfHwgbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgIGlmIChfbm9kZSA9PT0gdGFyZ2V0IHx8IF9ub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJlbnRNdXRhdGlvbiB8fCBwYXJlbnRNdXRhdGlvbiA9PT0gbXV0YXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGFyZ2V0IGFkZC9yZW1vdmUgaXMgdHJhY2tlZC4gVHJhY2sgdGhlIG11dGF0aW9uIGlmIHdlIHRyYWNrIHRoZSBwYXJlbnQgbXV0YXRpb24uXG4gIHJldHVybiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIHBhcmVudE11dGF0aW9uLCBiYXRjaCk7XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGRlZXBlc3QgYWN0aXZlIGVsZW1lbnQgaW4gdGhlIERPTSwgY29uc2lkZXJpbmcgbmVzdGVkIHNoYWRvdyBET01zLlxuICovXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB3aGlsZSAoKF9hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudCkgIT09IG51bGwgJiYgX2FjdGl2ZUVsZW1lbnQgIT09IHZvaWQgMCAmJiBfYWN0aXZlRWxlbWVudC5zaGFkb3dSb290ICYmIChfYWN0aXZlRWxlbWVudCRzaGFkb3cgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpICE9PSBudWxsICYmIF9hY3RpdmVFbGVtZW50JHNoYWRvdyAhPT0gdm9pZCAwICYmIF9hY3RpdmVFbGVtZW50JHNoYWRvdy5hY3RpdmVFbGVtZW50KSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50LCBfYWN0aXZlRWxlbWVudCRzaGFkb3csIF9hY3RpdmVFbGVtZW50MjtcbiAgICBhY3RpdmVFbGVtZW50ID0gKF9hY3RpdmVFbGVtZW50MiA9IGFjdGl2ZUVsZW1lbnQpID09PSBudWxsIHx8IF9hY3RpdmVFbGVtZW50MiA9PT0gdm9pZCAwIHx8IChfYWN0aXZlRWxlbWVudDIgPSBfYWN0aXZlRWxlbWVudDIuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2FjdGl2ZUVsZW1lbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWN0aXZlRWxlbWVudDIuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn07XG4vKipcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBgb3RoZXJOb2RlYCBpcyBiZWZvcmUgYG5vZGVgIGluIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICovXG52YXIgaXNCZWZvcmUgPSAobm9kZSwgb3RoZXJOb2RlKSA9PiBCb29sZWFuKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIERPTU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKTtcbi8qKlxuICogQHJldHVybnMgYHRydWVgIGlmIGBvdGhlck5vZGVgIGlzIGFmdGVyIGBub2RlYCBpbiB0aGUgZG9jdW1lbnQ7IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAqL1xudmFyIGlzQWZ0ZXIgPSAobm9kZSwgb3RoZXJOb2RlKSA9PiBCb29sZWFuKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIERPTU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKTtcblxudmFyIF9uYXZpZ2F0b3IkdXNlckFnZW50JCwgX25hdmlnYXRvciR1c2VyQWdlbnQkMjtcbnZhciBJU19JT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xudmFyIElTX0FQUExFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL01hYyBPUyBYLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0FORFJPSUQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19GSVJFRk9YID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX1dFQktJVCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BcHBsZVdlYktpdCg/IS4qQ2hyb21lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBcIm1vZGVyblwiIEVkZ2Ugd2FzIHJlbGVhc2VkIGF0IDc5LnhcbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19DSFJPTUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIE5hdGl2ZSBgYmVmb3JlSW5wdXRgIGV2ZW50cyBkb24ndCB3b3JrIHdlbGwgd2l0aCByZWFjdCBvbiBDaHJvbWUgNzVcbi8vIGFuZCBvbGRlciwgQ2hyb21lIDc2KyBjYW4gdXNlIGBiZWZvcmVJbnB1dGAgdGhvdWdoLlxudmFyIElTX0NIUk9NRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTddWzAtNV18WzAtNl1bMC05XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kgPSBJU19BTkRST0lEICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWU/XFwvKD86WzAtNV0/XFxkKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cbnZhciBJU19GSVJFRk9YX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94XFwvKD86WzAtN11bMC05XXxbMC04XVswLTZdKSg/OlxcLikpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gVUMgbW9iaWxlIGJyb3dzZXJcbnZhciBJU19VQ19NT0JJTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipVQ0Jyb3dzZXIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBXZWNoYXQgYnJvd3NlciAobm90IGluY2x1ZGluZyBtYWMgd2VjaGF0KVxudmFyIElTX1dFQ0hBVEJST1dTRVIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS8uKk1hY1dlY2hhdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gYXZvaWQgbG9va2JlaGluZCAoYnVnZ3kgaW4gc2FmYXJpIDwgMTYuNClcbi8vIENoZWNrIGlmIERPTSBpcyBhdmFpbGFibGUgYXMgUmVhY3QgZG9lcyBpbnRlcm5hbGx5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xudmFyIENBTl9VU0VfRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG4vLyBDaGVjayBpZiB0aGUgYnJvd3NlciBpcyBTYWZhcmkgYW5kIG9sZGVyIHRoYW4gMTdcbnR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL1ZlcnNpb25cXC8oXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKChfbmF2aWdhdG9yJHVzZXJBZ2VudCQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLykpICE9PSBudWxsICYmIF9uYXZpZ2F0b3IkdXNlckFnZW50JCAhPT0gdm9pZCAwICYmIF9uYXZpZ2F0b3IkdXNlckFnZW50JFsxXSA/IHBhcnNlSW50KChfbmF2aWdhdG9yJHVzZXJBZ2VudCQyID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhcXGQrKS8pKSA9PT0gbnVsbCB8fCBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyWzFdLCAxMCkgPCAxNyA6IGZhbHNlKTtcbi8vIENPTVBBVDogRmlyZWZveC9FZGdlIExlZ2FjeSBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50XG4vLyBDaHJvbWUgTGVnYWN5IGRvZXNuJ3Qgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGNvcnJlY3RseVxudmFyIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA9ICghSVNfQ0hST01FX0xFR0FDWSB8fCAhSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZKSAmJiAhSVNfRURHRV9MRUdBQ1kgJiZcbi8vIGdsb2JhbFRoaXMgaXMgdW5kZWZpbmVkIGluIG9sZGVyIGJyb3dzZXJzXG50eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5JbnB1dEV2ZW50ICYmXG4vLyBAdHMtaWdub3JlIFRoZSBgZ2V0VGFyZ2V0UmFuZ2VzYCBwcm9wZXJ0eSBpc24ndCByZWNvZ25pemVkLlxudHlwZW9mIGdsb2JhbFRoaXMuSW5wdXRFdmVudC5wcm90b3R5cGUuZ2V0VGFyZ2V0UmFuZ2VzID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBBbiBhdXRvLWluY3JlbWVudGluZyBpZGVudGlmaWVyIGZvciBrZXlzLlxuICovXG52YXIgbiA9IDA7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBhIGtleSBzdHJpbmcuIFdlIHVzZSBhIGZ1bGwgY2xhc3MgaGVyZSBiZWNhdXNlIHdlXG4gKiB3YW50IHRvIGJlIGFibGUgdG8gdXNlIHRoZW0gYXMga2V5cyBpbiBgV2Vha01hcGAgb2JqZWN0cy5cbiAqL1xuY2xhc3MgS2V5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmlkID0gXCJcIi5jb25jYXQobisrKTtcbiAgfVxufVxuXG4vKipcbiAqIFR3byB3ZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyByZWJ1aWxkIGEgcGF0aCBnaXZlbiBhIG5vZGUuIFRoZXkgYXJlIHBvcHVsYXRlZFxuICogYXQgcmVuZGVyIHRpbWUgc3VjaCB0aGF0IGFmdGVyIGEgcmVuZGVyIG9jY3VycyB3ZSBjYW4gYWx3YXlzIGJhY2t0cmFjay5cbiAqL1xudmFyIElTX05PREVfTUFQX0RJUlRZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0lOREVYID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX1BBUkVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHRvIGdvIGJldHdlZW4gU2xhdGUgbm9kZXMgYW5kIERPTSBub2Rlcy4gVGhlc2VcbiAqIGFyZSB1c2VkIHRvIHJlc29sdmUgRE9NIGV2ZW50LXJlbGF0ZWQgbG9naWMgaW50byBTbGF0ZSBhY3Rpb25zLlxuICovXG52YXIgRURJVE9SX1RPX1dJTkRPVyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFTEVNRU5UX1RPX05PREUgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19LRVkgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyBmb3Igc3RvcmluZyBlZGl0b3ItcmVsYXRlZCBzdGF0ZS5cbiAqL1xudmFyIElTX1JFQURfT05MWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfRk9DVVNFRCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfQ09NUE9TSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcCBmb3IgYXNzb2NpYXRpbmcgdGhlIGNvbnRleHQgYG9uQ2hhbmdlYCBjb250ZXh0IHdpdGggdGhlIHBsdWdpbi5cbiAqL1xudmFyIEVESVRPUl9UT19PTl9DSEFOR0UgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgZm9yIHNhdmluZyBwZW5kaW5nIHN0YXRlIG9uIGNvbXBvc2l0aW9uIHN0YWdlLlxuICovXG52YXIgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQW5kcm9pZCBpbnB1dCBoYW5kbGluZyBzcGVjaWZpYyB3ZWFrLW1hcHNcbiAqL1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19BQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFN5bWJvbHMuXG4gKi9cbnZhciBQTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ3BsYWNlaG9sZGVyJyk7XG52YXIgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ21hcmstcGxhY2Vob2xkZXInKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIERPTUVkaXRvciA9IHtcbiAgYW5kcm9pZFBlbmRpbmdEaWZmczogZWRpdG9yID0+IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpLFxuICBhbmRyb2lkU2NoZWR1bGVGbHVzaDogZWRpdG9yID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GO1xuICAgIChfRURJVE9SX1RPX1NDSEVEVUxFX0YgPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICB9LFxuICBibHVyOiBlZGl0b3IgPT4ge1xuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gRE9NRWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICB9LFxuICBkZXNlbGVjdDogZWRpdG9yID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgIGlmIChkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICB9XG4gIH0sXG4gIGZpbmREb2N1bWVudE9yU2hhZG93Um9vdDogZWRpdG9yID0+IHtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50O1xuICB9LFxuICBmaW5kRXZlbnRSYW5nZTogKGVkaXRvciwgZXZlbnQpID0+IHtcbiAgICBpZiAoJ25hdGl2ZUV2ZW50JyBpbiBldmVudCkge1xuICAgICAgZXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICB9XG4gICAgdmFyIHtcbiAgICAgIGNsaWVudFg6IHgsXG4gICAgICBjbGllbnRZOiB5LFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHBhdGggPSBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAvLyBJZiB0aGUgZHJvcCB0YXJnZXQgaXMgaW5zaWRlIGEgdm9pZCBub2RlLCBtb3ZlIGl0IGludG8gZWl0aGVyIHRoZVxuICAgIC8vIG5leHQgb3IgcHJldmlvdXMgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGUgdGhlIGB4YCBhbmQgYHlgXG4gICAgLy8gY29vcmRpbmF0ZXMgYXJlIGNsb3Nlc3QgdG8uXG4gICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHZhciBfcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVsc2UgcmVzb2x2ZSBhIHJhbmdlIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRoZSBkcm9wIG9jY3VyZWQuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG4gICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGRvbVJhbmdlLnNldFN0YXJ0KHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICAgIGRvbVJhbmdlLnNldEVuZChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cbiAgICAvLyBSZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSB0aGUgRE9NIHJhbmdlLlxuICAgIHZhciByYW5nZSA9IERPTUVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21SYW5nZSwge1xuICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfSxcbiAgZmluZEtleTogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBrZXkgPSBOT0RFX1RPX0tFWS5nZXQobm9kZSk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGtleSA9IG5ldyBLZXkoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9LFxuICBmaW5kUGF0aDogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGNoaWxkID0gbm9kZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IE5PREVfVE9fUEFSRU5ULmdldChjaGlsZCk7XG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSBOT0RFX1RPX0lOREVYLmdldChjaGlsZCk7XG4gICAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBwYXRoIGZvciBTbGF0ZSBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gIH0sXG4gIGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgcmV0cmllczogNVxuICAgIH07XG4gICAgLy8gUmV0dXJuIGlmIGFscmVhZHkgZm9jdXNlZFxuICAgIGlmIChJU19GT0NVU0VELmdldChlZGl0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJldHJ5IHNldHRpbmcgZm9jdXMgaWYgdGhlIGVkaXRvciBoYXMgcGVuZGluZyBvcGVyYXRpb25zLlxuICAgIC8vIFRoZSBET00gKHNlbGVjdGlvbikgaXMgdW5zdGFibGUgd2hpbGUgY2hhbmdlcyBhcmUgYXBwbGllZC5cbiAgICAvLyBSZXRyeSB1bnRpbCByZXRyaWVzIGFyZSBleGhhdXN0ZWQgb3IgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgaWYgKG9wdGlvbnMucmV0cmllcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzZXQgZm9jdXMsIGVkaXRvciBzZWVtcyBzdHVjayB3aXRoIHBlbmRpbmcgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIERPTUVkaXRvci5mb2N1cyhlZGl0b3IsIHtcbiAgICAgICAgICByZXRyaWVzOiBvcHRpb25zLnJldHJpZXMgLSAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ICE9PSBlbCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIERPTSBzZWxlY3Rpb24gc3RhdGUgaXMgc2V0IHRvIHRoZSBlZGl0b3IncyBzZWxlY3Rpb25cbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgICAgICB2YXIgZG9tUmFuZ2UgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKGRvbVJhbmdlKTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZWxlY3Rpb24gaW4gdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQgaWYgbWlzc2luZ1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pKTtcbiAgICAgIH1cbiAgICAgIC8vIElTX0ZPQ1VTRUQgc2hvdWxkIGJlIHNldCBiZWZvcmUgY2FsbGluZyBlbC5mb2N1cygpIHRvIGVuc3VyZSB0aGF0XG4gICAgICAvLyBGb2N1c2VkQ29udGV4dCBpcyB1cGRhdGVkIHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgZWwuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFdpbmRvdzogZWRpdG9yID0+IHtcbiAgICB2YXIgd2luZG93ID0gRURJVE9SX1RPX1dJTkRPVy5nZXQoZWRpdG9yKTtcbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIGhvc3Qgd2luZG93IGVsZW1lbnQgZm9yIHRoaXMgZWRpdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3c7XG4gIH0sXG4gIGhhc0RPTU5vZGU6IGZ1bmN0aW9uIGhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkaXRhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWRpdG9yRWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgdGFyZ2V0RWw7XG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCByZWFkaW5nIGB0YXJnZXQubm9kZVR5cGVgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAvLyB0YXJnZXQgaXMgb3JpZ2luYXRpbmcgZnJvbSBhbiBpbnRlcm5hbCBcInJlc3RyaWN0ZWRcIiBlbGVtZW50IChlLmcuIGFcbiAgICAvLyBzdGVwcGVyIGFycm93IG9uIGEgbnVtYmVyIGlucHV0KS4gKDIwMTgvMDUvMDQpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy8xODE5XG4gICAgdHJ5IHtcbiAgICAgIHRhcmdldEVsID0gaXNET01FbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiAhZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcIm5vZGVUeXBlXCInKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldEVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1lZGl0b3JdXCIpID09PSBlZGl0b3JFbCAmJiAoIWVkaXRhYmxlIHx8IHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID8gdHJ1ZSA6IHR5cGVvZiB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgLy8gaXNDb250ZW50RWRpdGFibGUgZXhpc3RzIG9ubHkgb24gSFRNTEVsZW1lbnQsIGFuZCBvbiBvdGhlciBub2RlcyBpdCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIC8vIHRoaXMgaXMgdGhlIGNvcmUgbG9naWMgdGhhdCBsZXRzIHlvdSBrbm93IHlvdSBnb3QgdGhlIHJpZ2h0IGVkaXRvci5zZWxlY3Rpb24gaW5zdGVhZCBvZiBudWxsIHdoZW4gZWRpdG9yIGlzIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIocmVhZE9ubHkpXG4gICAgdGFyZ2V0RWwuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJykgPT09IGVkaXRvckVsIHx8ICEhdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSk7XG4gIH0sXG4gIGhhc0VkaXRhYmxlVGFyZ2V0OiAoZWRpdG9yLCB0YXJnZXQpID0+IGlzRE9NTm9kZSh0YXJnZXQpICYmIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgZWRpdGFibGU6IHRydWVcbiAgfSksXG4gIGhhc1JhbmdlOiAoZWRpdG9yLCByYW5nZSkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBhbmNob3IucGF0aCkgJiYgRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBmb2N1cy5wYXRoKTtcbiAgfSxcbiAgaGFzU2VsZWN0YWJsZVRhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBET01FZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHx8IERPTUVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCksXG4gIGhhc1RhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCksXG4gIGluc2VydERhdGE6IChlZGl0b3IsIGRhdGEpID0+IHtcbiAgICBlZGl0b3IuaW5zZXJ0RGF0YShkYXRhKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnREYXRhOiAoZWRpdG9yLCBkYXRhKSA9PiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpLFxuICBpbnNlcnRUZXh0RGF0YTogKGVkaXRvciwgZGF0YSkgPT4gZWRpdG9yLmluc2VydFRleHREYXRhKGRhdGEpLFxuICBpc0NvbXBvc2luZzogZWRpdG9yID0+IHtcbiAgICByZXR1cm4gISFJU19DT01QT1NJTkcuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIGlzRm9jdXNlZDogZWRpdG9yID0+ICEhSVNfRk9DVVNFRC5nZXQoZWRpdG9yKSxcbiAgaXNSZWFkT25seTogZWRpdG9yID0+ICEhSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpLFxuICBpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZDogKGVkaXRvciwgdGFyZ2V0KSA9PiB7XG4gICAgaWYgKElTX1JFQURfT05MWS5nZXQoZWRpdG9yKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzbGF0ZU5vZGUgPSBET01FZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChzbGF0ZU5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICB9LFxuICBzZXRGcmFnbWVudERhdGE6IChlZGl0b3IsIGRhdGEsIG9yaWdpbkV2ZW50KSA9PiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGRhdGEsIG9yaWdpbkV2ZW50KSxcbiAgdG9ET01Ob2RlOiAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIHZhciBkb21Ob2RlID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcikgOiBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZ2V0KERPTUVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gbm9kZSBmcm9tIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbU5vZGU7XG4gIH0sXG4gIHRvRE9NUG9pbnQ6IChlZGl0b3IsIHBvaW50KSA9PiB7XG4gICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aCk7XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgIHZhciBkb21Qb2ludDtcbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSB2b2lkIG5vZGUsIGZvcmNlIHRoZSBvZmZzZXQgdG8gMCwgb3RoZXJ3aXNlIHRoZSB6ZXJvXG4gICAgLy8gd2lkdGggc3BhY2luZyBjaGFyYWN0ZXIgd2lsbCByZXN1bHQgaW4gYW4gaW5jb3JyZWN0IG9mZnNldCBvZiAxXG4gICAgaWYgKEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHBvaW50XG4gICAgfSkpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGxlYWYsIHdlIG5lZWQgdG8gaXNvbGF0ZSBpdHMgY29udGVudCwgd2hpY2ggbWVhbnMgZmlsdGVyaW5nXG4gICAgLy8gdG8gaXRzIGRpcmVjdCB0ZXh0IGFuZCB6ZXJvLXdpZHRoIHNwYW5zLiAoV2UgaGF2ZSB0byBmaWx0ZXIgb3V0IGFueVxuICAgIC8vIG90aGVyIHNpYmxpbmdzIHRoYXQgbWF5IGhhdmUgYmVlbiByZW5kZXJlZCBhbG9uZ3NpZGUgdGhlbS4pXG4gICAgdmFyIHNlbGVjdG9yID0gXCJbZGF0YS1zbGF0ZS1zdHJpbmddLCBbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiO1xuICAgIHZhciB0ZXh0cyA9IEFycmF5LmZyb20oZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHQgPSB0ZXh0c1tpXTtcbiAgICAgIHZhciBkb21Ob2RlID0gdGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgaWYgKGRvbU5vZGUgPT0gbnVsbCB8fCBkb21Ob2RlLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBkb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgdmFyIGF0dHIgPSB0ZXh0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1sZW5ndGgnKTtcbiAgICAgIHZhciB0cnVlTGVuZ3RoID0gYXR0ciA9PSBudWxsID8gbGVuZ3RoIDogcGFyc2VJbnQoYXR0ciwgMTApO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgdHJ1ZUxlbmd0aDtcbiAgICAgIC8vIFByZWZlciBwdXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBtYXJrIHBsYWNlaG9sZGVyIHRvIGVuc3VyZVxuICAgICAgLy8gY29tcG9zZWQgdGV4dCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgY29ycmVjdCBtYXJrcy5cbiAgICAgIHZhciBuZXh0VGV4dCA9IHRleHRzW2kgKyAxXTtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPT09IGVuZCAmJiBuZXh0VGV4dCAhPT0gbnVsbCAmJiBuZXh0VGV4dCAhPT0gdm9pZCAwICYmIG5leHRUZXh0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgdmFyIF9uZXh0VGV4dCR0ZXh0Q29udGVudDtcbiAgICAgICAgdmFyIGRvbVRleHQgPSBuZXh0VGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBkb21Qb2ludCA9IFtcbiAgICAgICAgLy8gQ09NUEFUOiBJZiB3ZSBkb24ndCBleHBsaWNpdHkgc2V0IHRoZSBkb20gcG9pbnQgdG8gYmUgb24gdGhlIGFjdHVhbFxuICAgICAgICAvLyBkb20gdGV4dCBlbGVtZW50LCBjaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiBiZWhpbmQgdGhlIGFjdHVhbCBkb21cbiAgICAgICAgLy8gdGV4dCBlbGVtZW50LCBjYXVzaW5nIGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGxzIG9uIGEgY29sbGFwc2VkXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byByZXR1cm4gaW5jb3JyZWN0IHplcm8gdmFsdWVzIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzgpXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzIHdoZW4gc2Nyb2xsaW5nIHRvIGl0LlxuICAgICAgICBkb21UZXh0IGluc3RhbmNlb2YgRE9NVGV4dCA/IGRvbVRleHQgOiBuZXh0VGV4dCwgKF9uZXh0VGV4dCR0ZXh0Q29udGVudCA9IG5leHRUZXh0LnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpID8gMSA6IDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIE1hdGgubWF4KDAsIHBvaW50Lm9mZnNldCAtIHN0YXJ0KSk7XG4gICAgICAgIGRvbVBvaW50ID0gW2RvbU5vZGUsIG9mZnNldF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghZG9tUG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIHBvaW50IGZyb20gU2xhdGUgcG9pbnQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocG9pbnQpKSk7XG4gICAgfVxuICAgIHJldHVybiBkb21Qb2ludDtcbiAgfSxcbiAgdG9ET01SYW5nZTogKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgICB2YXIgZG9tQW5jaG9yID0gRE9NRWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBhbmNob3IpO1xuICAgIHZhciBkb21Gb2N1cyA9IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSA/IGRvbUFuY2hvciA6IERPTUVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgZm9jdXMpO1xuICAgIHZhciB3aW5kb3cgPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgdmFyIGRvbVJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgdmFyIFtzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21Gb2N1cyA6IGRvbUFuY2hvcjtcbiAgICB2YXIgW2VuZE5vZGUsIGVuZE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tQW5jaG9yIDogZG9tRm9jdXM7XG4gICAgLy8gQSBzbGF0ZSBQb2ludCBhdCB6ZXJvLXdpZHRoIExlYWYgYWx3YXlzIGhhcyBhbiBvZmZzZXQgb2YgMCBidXQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBhdFxuICAgIC8vIHplcm8td2lkdGggbm9kZSBoYXMgYW4gb2Zmc2V0IG9mIDEgc28gd2UgaGF2ZSB0byBjaGVjayBpZiB3ZSBhcmUgaW4gYSB6ZXJvLXdpZHRoIG5vZGUgYW5kXG4gICAgLy8gYWRqdXN0IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuXG4gICAgdmFyIHN0YXJ0RWwgPSBpc0RPTUVsZW1lbnQoc3RhcnROb2RlKSA/IHN0YXJ0Tm9kZSA6IHN0YXJ0Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc1N0YXJ0QXRaZXJvV2lkdGggPSAhIXN0YXJ0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICB2YXIgZW5kRWwgPSBpc0RPTUVsZW1lbnQoZW5kTm9kZSkgPyBlbmROb2RlIDogZW5kTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc0VuZEF0WmVyb1dpZHRoID0gISFlbmRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIGRvbVJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgaXNTdGFydEF0WmVyb1dpZHRoID8gMSA6IHN0YXJ0T2Zmc2V0KTtcbiAgICBkb21SYW5nZS5zZXRFbmQoZW5kTm9kZSwgaXNFbmRBdFplcm9XaWR0aCA/IDEgOiBlbmRPZmZzZXQpO1xuICAgIHJldHVybiBkb21SYW5nZTtcbiAgfSxcbiAgdG9TbGF0ZU5vZGU6IChlZGl0b3IsIGRvbU5vZGUpID0+IHtcbiAgICB2YXIgZG9tRWwgPSBpc0RPTUVsZW1lbnQoZG9tTm9kZSkgPyBkb21Ob2RlIDogZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChkb21FbCAmJiAhZG9tRWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSkge1xuICAgICAgZG9tRWwgPSBkb21FbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtbm9kZV1cIik7XG4gICAgfVxuICAgIHZhciBub2RlID0gZG9tRWwgPyBFTEVNRU5UX1RPX05PREUuZ2V0KGRvbUVsKSA6IG51bGw7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIG5vZGUgZnJvbSBET00gbm9kZTogXCIuY29uY2F0KGRvbUVsKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICB0b1NsYXRlUG9pbnQ6IChlZGl0b3IsIGRvbVBvaW50LCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93LFxuICAgICAgc2VhcmNoRGlyZWN0aW9uID0gJ2JhY2t3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBbbmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXRdID0gZXhhY3RNYXRjaCA/IGRvbVBvaW50IDogbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpO1xuICAgIHZhciBwYXJlbnROb2RlID0gbmVhcmVzdE5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgdGV4dE5vZGUgPSBudWxsO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICB2YXIgX2RvbU5vZGUkdGV4dENvbnRlbnQsIF9kb21Ob2RlJHRleHRDb250ZW50MjtcbiAgICAgIHZhciBlZGl0b3JFbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIHBvdGVudGlhbFZvaWROb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS12b2lkPVwidHJ1ZVwiXScpO1xuICAgICAgLy8gTmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvc2VzdCB2b2lkIG5vZGUgaXMgYWN0dWFsbHkgYSB2b2lkIG5vZGVcbiAgICAgIC8vIHdpdGhpbiB0aGlzIGVkaXRvciwgYW5kIG5vdCBhIHZvaWQgbm9kZSB3aXRoaW4gc29tZSBwYXJlbnQgZWRpdG9yLiBUaGlzIGNhbiBoYXBwZW5cbiAgICAgIC8vIGlmIHRoaXMgZWRpdG9yIGlzIHdpdGhpbiBhIHZvaWQgbm9kZSBvZiBhbm90aGVyIGVkaXRvciAoXCJuZXN0ZWQgZWRpdG9yc1wiLCBsaWtlIGluXG4gICAgICAvLyB0aGUgXCJFZGl0YWJsZSBWb2lkc1wiIGV4YW1wbGUgb24gdGhlIGRvY3Mgc2l0ZSkuXG4gICAgICB2YXIgdm9pZE5vZGUgPSBwb3RlbnRpYWxWb2lkTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxWb2lkTm9kZSkgPyBwb3RlbnRpYWxWb2lkTm9kZSA6IG51bGw7XG4gICAgICB2YXIgcG90ZW50aWFsTm9uRWRpdGFibGVOb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKTtcbiAgICAgIHZhciBub25FZGl0YWJsZU5vZGUgPSBwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUgJiYgZWRpdG9yRWwuY29udGFpbnMocG90ZW50aWFsTm9uRWRpdGFibGVOb2RlKSA/IHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSA6IG51bGw7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7XG4gICAgICAvLyBDYWxjdWxhdGUgaG93IGZhciBpbnRvIHRoZSB0ZXh0IG5vZGUgdGhlIGBuZWFyZXN0Tm9kZWAgaXMsIHNvIHRoYXQgd2VcbiAgICAgIC8vIGNhbiBkZXRlcm1pbmUgd2hhdCB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB0ZXh0IG5vZGUgaXMuXG4gICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICBpZiAodGV4dE5vZGUpIHtcbiAgICAgICAgICB2YXIgd2luZG93ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgICAgICAgIHZhciByYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXQpO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSksIC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjb250ZW50ZWRpdGFibGU9ZmFsc2VdJykpXTtcbiAgICAgICAgICByZW1vdmFscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgY29tcG9zaW5nIGF0IHRoZSBzdGFydCBvZiBhIHRleHQgbm9kZSwgc29tZSBrZXlib2FyZHMgcHV0XG4gICAgICAgICAgICAvLyB0aGUgdGV4dCBjb250ZW50IGluc2lkZSB0aGUgemVybyB3aWR0aCBzcGFjZS5cbiAgICAgICAgICAgIGlmIChJU19BTkRST0lEICYmICFleGFjdE1hdGNoICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgJiYgZWwudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBlbC50ZXh0Q29udGV4dCAhPT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykpIHtcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIENPTVBBVDogRWRnZSBoYXMgYSBidWcgd2hlcmUgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nKCkgd2lsbFxuICAgICAgICAgIC8vIGNvbnZlcnQgXFxuIGludG8gXFxyXFxuLiBUaGUgYnVnIGNhdXNlcyBhIGxvb3Agd2hlbiBzbGF0ZS1kb21cbiAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZXBvc2l0aW9uIGl0cyBjdXJzb3IgdG8gbWF0Y2ggdGhlIG5hdGl2ZSBwb3NpdGlvbi4gVXNlXG4gICAgICAgICAgLy8gdGV4dENvbnRlbnQubGVuZ3RoIGluc3RlYWQuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAyOTExMTYvXG4gICAgICAgICAgb2Zmc2V0ID0gY29udGVudHMudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2b2lkTm9kZSkge1xuICAgICAgICAvLyBGb3Igdm9pZCBub2RlcywgdGhlIGVsZW1lbnQgd2l0aCB0aGUgb2Zmc2V0IGtleSB3aWxsIGJlIGEgY291c2luLCBub3QgYW5cbiAgICAgICAgLy8gYW5jZXN0b3IsIHNvIGZpbmQgaXQgYnkgZ29pbmcgZG93biBmcm9tIHRoZSBuZWFyZXN0IHZvaWQgcGFyZW50IGFuZCB0YWtpbmcgdGhlXG4gICAgICAgIC8vIGZpcnN0IG9uZSB0aGF0IGlzbid0IGluc2lkZSBhIG5lc3RlZCBlZGl0b3IuXG4gICAgICAgIHZhciBsZWFmTm9kZXMgPSB2b2lkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVhZk5vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gbGVhZk5vZGVzW2luZGV4XTtcbiAgICAgICAgICBpZiAoRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgbGVhZk5vZGUgPSBjdXJyZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogSW4gcmVhZC1vbmx5IGVkaXRvcnMgdGhlIGxlYWYgaXMgbm90IHJlbmRlcmVkLlxuICAgICAgICBpZiAoIWxlYWZOb2RlKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIG9mZnNldCA9IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9uRWRpdGFibGVOb2RlKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVkZ2Ugb2YgdGhlIG5lYXJlc3QgbGVhZiBpbiBgc2VhcmNoRGlyZWN0aW9uYFxuICAgICAgICB2YXIgZ2V0TGVhZk5vZGVzID0gbm9kZSA9PiBub2RlID8gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAvLyBFeGNsdWRlIGxlYWYgbm9kZXMgaW4gbmVzdGVkIGVkaXRvcnNcbiAgICAgICAgJ1tkYXRhLXNsYXRlLWxlYWZdOm5vdCg6c2NvcGUgW2RhdGEtc2xhdGUtZWRpdG9yXSBbZGF0YS1zbGF0ZS1sZWFmXSknKSA6IFtdO1xuICAgICAgICB2YXIgZWxlbWVudE5vZGUgPSBub25FZGl0YWJsZU5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cImVsZW1lbnRcIl0nKTtcbiAgICAgICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMkZmluZDtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlcyA9IFsuLi5nZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUpLCAuLi5nZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUgPT09IG51bGwgfHwgZWxlbWVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnROb2RlLm5leHRFbGVtZW50U2libGluZyldO1xuICAgICAgICAgIGxlYWZOb2RlID0gKF9sZWFmTm9kZXMkZmluZCA9IF9sZWFmTm9kZXMuZmluZChsZWFmID0+IGlzQWZ0ZXIobm9uRWRpdGFibGVOb2RlLCBsZWFmKSkpICE9PSBudWxsICYmIF9sZWFmTm9kZXMkZmluZCAhPT0gdm9pZCAwID8gX2xlYWZOb2RlcyRmaW5kIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlczIkZmluZExhc3Q7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMyID0gWy4uLmdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSA9PT0gbnVsbCB8fCBlbGVtZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudE5vZGUucHJldmlvdXNFbGVtZW50U2libGluZyksIC4uLmdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSldO1xuICAgICAgICAgIGxlYWZOb2RlID0gKF9sZWFmTm9kZXMyJGZpbmRMYXN0ID0gX2xlYWZOb2RlczIuZmluZExhc3QobGVhZiA9PiBpc0JlZm9yZShub25FZGl0YWJsZU5vZGUsIGxlYWYpKSkgIT09IG51bGwgJiYgX2xlYWZOb2RlczIkZmluZExhc3QgIT09IHZvaWQgMCA/IF9sZWFmTm9kZXMyJGZpbmRMYXN0IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkb21Ob2RlICYmIG9mZnNldCA9PT0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGggJiZcbiAgICAgIC8vIENPTVBBVDogQW5kcm9pZCBJTUVzIG1pZ2h0IHJlbW92ZSB0aGUgemVybyB3aWR0aCBzcGFjZSB3aGlsZSBjb21wb3NpbmcsXG4gICAgICAvLyBhbmQgd2UgZG9uJ3QgYWRkIGl0IGZvciBsaW5lLWJyZWFrcy5cbiAgICAgIElTX0FORFJPSUQgJiYgZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAneicgJiYgKF9kb21Ob2RlJHRleHRDb250ZW50ID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgJiYgKFxuICAgICAgLy8gQ09NUEFUOiBJZiB0aGUgcGFyZW50IG5vZGUgaXMgYSBTbGF0ZSB6ZXJvLXdpZHRoIHNwYWNlLCBlZGl0b3IgaXNcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHRleHQgbm9kZSBzaG91bGQgaGF2ZSBubyBjaGFyYWN0ZXJzLiBIb3dldmVyLCBkdXJpbmcgSU1FXG4gICAgICAvLyBjb21wb3NpdGlvbiB0aGUgQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UsIHNvIHN1YnRyYWN0IDEgZnJvbSB0aGUgb2Zmc2V0IHRvIGFjY291bnQgZm9yIHRoZSB6ZXJvLXdpZHRoXG4gICAgICAvLyBzcGFjZSBjaGFyYWN0ZXIuXG4gICAgICBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgfHxcbiAgICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgYHJhbmdlLmNsb25lQ29udGVudHMoKWAgcmV0dXJucyBhbiBleHRyYSB0cmFpbGluZyAnXFxuJ1xuICAgICAgLy8gd2hlbiB0aGUgZG9jdW1lbnQgZW5kcyB3aXRoIGEgbmV3LWxpbmUgY2hhcmFjdGVyLiBUaGlzIHJlc3VsdHMgaW4gdGhlIG9mZnNldFxuICAgICAgLy8gbGVuZ3RoIGJlaW5nIG9mZiBieSBvbmUsIHNvIHdlIG5lZWQgdG8gc3VidHJhY3Qgb25lIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAgICBJU19GSVJFRk9YICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudDIgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIuZW5kc1dpdGgoJ1xcblxcbicpKSkge1xuICAgICAgICBvZmZzZXQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKElTX0FORFJPSUQgJiYgIXRleHROb2RlICYmICFleGFjdE1hdGNoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSA/IHBhcmVudE5vZGUgOiBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGVdJyk7XG4gICAgICBpZiAobm9kZSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBfc2xhdGVOb2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH0gPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBfc2xhdGVOb2RlKSk7XG4gICAgICAgIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1sZWFmXScpKSB7XG4gICAgICAgICAgX29mZnNldCA9IG5lYXJlc3RPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHN1cHByZXNzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHBvaW50IGZyb20gRE9NIHBvaW50OiBcIi5jb25jYXQoZG9tUG9pbnQpKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcbiAgICB2YXIgc2xhdGVOb2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldFxuICAgIH07XG4gIH0sXG4gIHRvU2xhdGVSYW5nZTogKGVkaXRvciwgZG9tUmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2ZvY3VzTm9kZSR0ZXh0Q29udGVuO1xuICAgIHZhciB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBlbCA9IGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSA/IGRvbVJhbmdlLmFuY2hvck5vZGUgOiBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgYW5jaG9yTm9kZTtcbiAgICB2YXIgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1c05vZGU7XG4gICAgdmFyIGZvY3VzT2Zmc2V0O1xuICAgIHZhciBpc0NvbGxhcHNlZDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChpc0RPTVNlbGVjdGlvbihkb21SYW5nZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZXRpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzU0ODYjaXNzdWUtMTgyMDcyMDIyMylcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tUmFuZ2UucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7IC8vIEZvY3VzIG5vZGUgd29ya3MgZmluZVxuICAgICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdChkb21SYW5nZS5yYW5nZUNvdW50IC0gMSk7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBhcmUgaW4gdGhlIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9mIGEgdGFibGUgaW4gZmlyZWZveFxuICAgICAgICAgIGlmIChmb2N1c05vZGUgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGxhc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEhUTUxFbGVtZW50LCBiZWNvdXNlIEVsZW1lbnQgaXMgYSBzbGF0ZSBlbGVtZW50XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMYXN0Q2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlUm93ID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZVJvdyA9IGxhc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGZhaWwgYXMgXCJUaGUgSFRNTEVsZW1lbnQgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW55IEhUTUwgZWxlbWVudC5cIlxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZSA9IGdldExhc3RDaGlsZHJlbihmaXJzdE5vZGVSb3cuY2hpbGRyZW5bZmlyc3RSYW5nZS5zdGFydE9mZnNldF0pO1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGxhc3ROb2RlUm93LmNoaWxkcmVuW2xhc3RSYW5nZS5zdGFydE9mZnNldF0pO1xuICAgICAgICAgICAgLy8gWmVybywgYXMgd2UgYWxsd2F5cyB0YWtlIHRoZSByaWdodCBvbmUgYXMgdGhlIGFuY2hvciBwb2ludFxuICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKGxhc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gZmlyc3ROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3ROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE5vZGUuaW5uZXJIVE1MLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9wdGlvblxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByZWFkIG9ubHkgbW9kZSBvZiBhIGZpcmVmb3ggdGFibGVcbiAgICAgICAgICAgIC8vIFJpZ2h0IHRvIGxlZnRcbiAgICAgICAgICAgIGlmIChmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3RSYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3RSYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZmlyc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGZpcnN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLmFuY2hvck5vZGU7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogVGhlcmUncyBhIGJ1ZyBpbiBjaHJvbWUgdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICAgIC8vIGBpc0NvbGxhcHNlZGAgZm9yIGEgU2VsZWN0aW9uIHRoYXQgY29tZXMgZnJvbSBhIFNoYWRvd1Jvb3QuXG4gICAgICAgIC8vICgyMDIwLzA4LzA4KVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbiAgICAgICAgLy8gSXNDb2xsYXBzZWQgbWlnaHQgbm90IHdvcmsgaW4gZmlyZWZveCwgYnV0IHRoaXMgd2lsbFxuICAgICAgICBpZiAoSVNfQ0hST01FICYmIGhhc1NoYWRvd1Jvb3QoYW5jaG9yTm9kZSkgfHwgSVNfRklSRUZPWCkge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuYW5jaG9yTm9kZSA9PT0gZG9tUmFuZ2UuZm9jdXNOb2RlICYmIGRvbVJhbmdlLmFuY2hvck9mZnNldCA9PT0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5pc0NvbGxhcHNlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5jb2xsYXBzZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZm9jdXNOb2RlID09IG51bGwgfHwgYW5jaG9yT2Zmc2V0ID09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIERPTSByYW5nZTogXCIuY29uY2F0KGRvbVJhbmdlKSk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogRmlyZWZveCBzb21ldGltZXMgaW5jbHVkZXMgYW4gZXh0cmEgXFxuIChyZW5kZXJlZCBieSBUZXh0U3RyaW5nXG4gICAgLy8gd2hlbiBpc1RyYWlsaW5nIGlzIHRydWUpIGluIHRoZSBmb2N1c09mZnNldCwgcmVzdWx0aW5nIGluIGFuIGludmFsaWRcbiAgICAvLyBTbGF0ZSBwb2ludC4gKDIwMjMvMTEvMDEpXG4gICAgaWYgKElTX0ZJUkVGT1ggJiYgKF9mb2N1c05vZGUkdGV4dENvbnRlbiA9IGZvY3VzTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2ZvY3VzTm9kZSR0ZXh0Q29udGVuICE9PSB2b2lkIDAgJiYgX2ZvY3VzTm9kZSR0ZXh0Q29udGVuLmVuZHNXaXRoKCdcXG5cXG4nKSAmJiBmb2N1c09mZnNldCA9PT0gZm9jdXNOb2RlLnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgZm9jdXNPZmZzZXQtLTtcbiAgICB9XG4gICAgdmFyIGFuY2hvciA9IERPTUVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBmb2N1c0JlZm9yZUFuY2hvciA9IGlzQmVmb3JlKGFuY2hvck5vZGUsIGZvY3VzTm9kZSkgfHwgYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGZvY3VzT2Zmc2V0IDwgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1cyA9IGlzQ29sbGFwc2VkID8gYW5jaG9yIDogRE9NRWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3csXG4gICAgICBzZWFyY2hEaXJlY3Rpb246IGZvY3VzQmVmb3JlQW5jaG9yID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICAgIGlmICghZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgLy8gaWYgdGhlIHNlbGVjdGlvbiBpcyBhIGhhbmdpbmcgcmFuZ2UgdGhhdCBlbmRzIGluIGEgdm9pZFxuICAgIC8vIGFuZCB0aGUgRE9NIGZvY3VzIGlzIGFuIEVsZW1lbnRcbiAgICAvLyAobWVhbmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gZW5kcyBiZWZvcmUgdGhlIGVsZW1lbnQpXG4gICAgLy8gdW5oYW5nIHRoZSByYW5nZSB0byBhdm9pZCBtaXN0YWtlbmx5IGluY2x1ZGluZyB0aGUgdm9pZFxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHJhbmdlKSAmJiBSYW5nZS5pc0ZvcndhcmQocmFuZ2UpICYmIGlzRE9NRWxlbWVudChmb2N1c05vZGUpICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLmZvY3VzLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpIHtcbiAgICAgIHJhbmdlID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIHtcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHRleHQgZGlmZiB3YXMgYXBwbGllZCBpbiBhIHdheSB3ZSBjYW4gcGVyZm9ybSB0aGUgcGVuZGluZyBhY3Rpb24gb24gL1xuICogcmVjb3ZlciB0aGUgcGVuZGluZyBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGlmZi5zdGFydCAhPT0gbm9kZS50ZXh0Lmxlbmd0aCB8fCBkaWZmLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dC5zbGljZShkaWZmLnN0YXJ0LCBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkgPT09IGRpZmYudGV4dDtcbiAgfVxuICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBuZXh0UGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG5leHROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBuZXh0UGF0aCk7XG4gIHJldHVybiBUZXh0LmlzVGV4dChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUudGV4dC5zdGFydHNXaXRoKGRpZmYudGV4dCk7XG59XG5mdW5jdGlvbiBhcHBseVN0cmluZ0RpZmYodGV4dCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGlmZnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGRpZmZzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlmZnMucmVkdWNlKCh0ZXh0LCBkaWZmKSA9PiB0ZXh0LnNsaWNlKDAsIGRpZmYuc3RhcnQpICsgZGlmZi50ZXh0ICsgdGV4dC5zbGljZShkaWZmLmVuZCksIHRleHQpO1xufVxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChzdHIsIGFub3RoZXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KGkpICE9PSBhbm90aGVyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHN0ciwgYW5vdGhlciwgbWF4KSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCwgbWF4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KHN0ci5sZW5ndGggLSBpIC0gMSkgIT09IGFub3RoZXIuY2hhckF0KGFub3RoZXIubGVuZ3RoIC0gaSAtIDEpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogUmVtb3ZlIHJlZHVuZGFudCBjaGFuZ2VzIGZyb20gdGhlIGRpZmYgc28gdGhhdCBpdCBzcGFucyB0aGUgbWluaW1hbCBwb3NzaWJsZSByYW5nZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIGRpZmYpIHtcbiAgdmFyIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9ID0gZGlmZjtcbiAgdmFyIHJlbW92ZWRUZXh0ID0gdGFyZ2V0VGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHByZWZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQpO1xuICB2YXIgbWF4ID0gTWF0aC5taW4ocmVtb3ZlZFRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCk7XG4gIHZhciBzdWZmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0LCBtYXgpO1xuICB2YXIgbm9ybWFsaXplZCA9IHtcbiAgICBzdGFydDogc3RhcnQgKyBwcmVmaXhMZW5ndGgsXG4gICAgZW5kOiBlbmQgLSBzdWZmaXhMZW5ndGgsXG4gICAgdGV4dDogdGV4dC5zbGljZShwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gc3VmZml4TGVuZ3RoKVxuICB9O1xuICBpZiAobm9ybWFsaXplZC5zdGFydCA9PT0gbm9ybWFsaXplZC5lbmQgJiYgbm9ybWFsaXplZC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgZGlmZiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYXBwbHlpbmcgYiBhZnRlciBhIHNwYW5uaW5nIHRoZSByYW5nZSBvZlxuICogYm90aCBjaGFuZ2VzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU3RyaW5nRGlmZnModGFyZ2V0VGV4dCwgYSwgYikge1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgdmFyIG92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCwgYi5lbmQpIC0gYi5zdGFydCk7XG4gIHZhciBhcHBsaWVkID0gYXBwbHlTdHJpbmdEaWZmKHRhcmdldFRleHQsIGEsIGIpO1xuICB2YXIgc2xpY2VFbmQgPSBNYXRoLm1heChiLnN0YXJ0ICsgYi50ZXh0Lmxlbmd0aCwgYS5zdGFydCArIGEudGV4dC5sZW5ndGggKyAoYS5zdGFydCArIGEudGV4dC5sZW5ndGggPiBiLnN0YXJ0ID8gYi50ZXh0Lmxlbmd0aCA6IDApIC0gb3ZlcmxhcCk7XG4gIHZhciB0ZXh0ID0gYXBwbGllZC5zbGljZShzdGFydCwgc2xpY2VFbmQpO1xuICB2YXIgZW5kID0gTWF0aC5tYXgoYS5lbmQsIGIuZW5kIC0gYS50ZXh0Lmxlbmd0aCArIChhLmVuZCAtIGEuc3RhcnQpKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICB0ZXh0XG4gIH0pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHNsYXRlIHJhbmdlIHRoZSB0ZXh0IGRpZmYgc3BhbnMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldFJhbmdlKHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLmVuZFxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgcG9pbnQnIGEuay5hIGEgcG9pbnQgYmFzZWQgb24gdGhlIGRvbSBzdGF0ZSBiZWZvcmUgYXBwbHlpbmdcbiAqIHRoZSBwZW5kaW5nIGRpZmZzLiBTaW5jZSB0aGUgcGVuZGluZyBkaWZmcyBtaWdodCBoYXZlIGJlZW4gaW5zZXJ0ZWQgd2l0aCBkaWZmZXJlbnRcbiAqIG1hcmtzIHdlIGhhdmUgdG8gJ3dhbGsnIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gdG8gZW5zdXJlIHdlIHN0aWxsXG4gKiBoYXZlIGEgdmFsaWQgcG9pbnQgaW5zaWRlIHRoZSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQb2ludChlZGl0b3IsIHBvaW50KSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfSA9IHBvaW50O1xuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVhZiA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIGlmICghVGV4dC5pc1RleHQobGVhZikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcGFyZW50QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICBhdDogcGF0aFxuICB9KTtcbiAgaWYgKCFwYXJlbnRCbG9jaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPiBsZWFmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5leHQoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pO1xuICAgIGlmICghZW50cnkgfHwgIVBhdGguaXNEZXNjZW5kYW50KGVudHJ5WzFdLCBwYXJlbnRCbG9ja1sxXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvZmZzZXQgLT0gbGVhZi50ZXh0Lmxlbmd0aDtcbiAgICBsZWFmID0gZW50cnlbMF07XG4gICAgcGF0aCA9IGVudHJ5WzFdO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgc2VsZWN0aW9uJyB0byBlbnN1cmUgaXQncyB2YWxpZCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgYW5jaG9yID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IpO1xuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cbiAgdmFyIGZvY3VzID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5mb2N1cyk7XG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcG9pbnQsIG9wKSB7XG4gIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKTtcbiAgdmFyIHRleHREaWZmID0gcGVuZGluZ0RpZmZzID09PSBudWxsIHx8IHBlbmRpbmdEaWZmcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0RpZmZzLmZpbmQoX3JlZiA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMocGF0aCwgcG9pbnQucGF0aCk7XG4gIH0pO1xuICBpZiAoIXRleHREaWZmIHx8IHBvaW50Lm9mZnNldCA8PSB0ZXh0RGlmZi5kaWZmLnN0YXJ0KSB7XG4gICAgcmV0dXJuIFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cbiAgdmFyIHtcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBpbnNpZGUgdGhlIGRpZmYgPT4gdHJhbnNmb3JtIHRoZSBwb2ludCBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgLy8gdGhlIGRpZmYgd2lsbCBiZSBhcHBsaWVkIHRvIGFuZCBhZGQgdGhlIG9mZnNldCBpbnNpZGUgdGhlIGRpZmYuXG4gIGlmIChwb2ludC5vZmZzZXQgPD0gZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgX2FuY2hvciA9IHtcbiAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9O1xuICAgIHZhciBfdHJhbnNmb3JtZWQgPSBQb2ludC50cmFuc2Zvcm0oX2FuY2hvciwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgaWYgKCFfdHJhbnNmb3JtZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogX3RyYW5zZm9ybWVkLnBhdGgsXG4gICAgICBvZmZzZXQ6IF90cmFuc2Zvcm1lZC5vZmZzZXQgKyBwb2ludC5vZmZzZXQgLSBkaWZmLnN0YXJ0XG4gICAgfTtcbiAgfVxuICAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGFmdGVyIHRoZSBkaWZmXG4gIHZhciBhbmNob3IgPSB7XG4gICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICBvZmZzZXQ6IHBvaW50Lm9mZnNldCAtIGRpZmYudGV4dC5sZW5ndGggKyBkaWZmLmVuZCAtIGRpZmYuc3RhcnRcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKGFuY2hvciwgb3AsIHtcbiAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICB9KTtcbiAgaWYgKCF0cmFuc2Zvcm1lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcC50eXBlID09PSAnc3BsaXRfbm9kZScgJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcG9pbnQucGF0aCkgJiYgYW5jaG9yLm9mZnNldCA8IG9wLnBvc2l0aW9uICYmIGRpZmYuc3RhcnQgPCBvcC5wb3NpdGlvbikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IHRyYW5zZm9ybWVkLnBhdGgsXG4gICAgb2Zmc2V0OiB0cmFuc2Zvcm1lZC5vZmZzZXQgKyBkaWZmLnRleHQubGVuZ3RoIC0gZGlmZi5lbmQgKyBkaWZmLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3ApIHtcbiAgdmFyIGFuY2hvciA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvciwgb3ApO1xuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cbiAgdmFyIGZvY3VzID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMsIG9wKTtcbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmYsXG4gICAgaWRcbiAgfSA9IHRleHREaWZmO1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5vZmZzZXQgPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogb3AudGV4dC5sZW5ndGggKyBkaWZmLmVuZCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3AucG9zaXRpb24gPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucG9zaXRpb24gPiBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogTWF0aC5taW4ob3AucG9zaXRpb24sIGRpZmYuZW5kKSxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgKyBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cbiAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gIGlmICghbmV3UGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGlmZixcbiAgICBwYXRoOiBuZXdQYXRoLFxuICAgIGlkXG4gIH07XG59XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBzaW5nbGUtbGluZSBkZWxldGlvblxuICovXG52YXIgZG9SZWN0c0ludGVyc2VjdCA9IChyZWN0LCBjb21wYXJlUmVjdCkgPT4ge1xuICB2YXIgbWlkZGxlID0gKGNvbXBhcmVSZWN0LnRvcCArIGNvbXBhcmVSZWN0LmJvdHRvbSkgLyAyO1xuICByZXR1cm4gcmVjdC50b3AgPD0gbWlkZGxlICYmIHJlY3QuYm90dG9tID49IG1pZGRsZTtcbn07XG52YXIgYXJlUmFuZ2VzU2FtZUxpbmUgPSAoZWRpdG9yLCByYW5nZTEsIHJhbmdlMikgPT4ge1xuICB2YXIgcmVjdDEgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciByZWN0MiA9IERPTUVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGRvUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG59O1xuLyoqXG4gKiBBIGhlbHBlciB1dGlsaXR5IHRoYXQgcmV0dXJucyB0aGUgZW5kIHBvcnRpb24gb2YgYSBgUmFuZ2VgXG4gKiB3aGljaCBpcyBsb2NhdGVkIG9uIGEgc2luZ2xlIGxpbmUuXG4gKlxuICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7UmFuZ2V9IHBhcmVudFJhbmdlIFRoZSBwYXJlbnQgcmFuZ2UgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7UmFuZ2V9IEEgdmFsaWQgcG9ydGlvbiBvZiB0aGUgcGFyZW50UmFuZ2Ugd2hpY2ggaXMgb25lIGEgc2luZ2xlIGxpbmVcbiAqL1xudmFyIGZpbmRDdXJyZW50TGluZVJhbmdlID0gKGVkaXRvciwgcGFyZW50UmFuZ2UpID0+IHtcbiAgdmFyIHBhcmVudFJhbmdlQm91bmRhcnkgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBSYW5nZS5lbmQocGFyZW50UmFuZ2UpKTtcbiAgdmFyIHBvc2l0aW9ucyA9IEFycmF5LmZyb20oRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICBhdDogcGFyZW50UmFuZ2VcbiAgfSkpO1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHJpZ2h0IC8gMik7XG4gIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG4gIHdoaWxlIChtaWRkbGUgIT09IHBvc2l0aW9ucy5sZW5ndGggJiYgbWlkZGxlICE9PSBsZWZ0KSB7XG4gICAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW21pZGRsZV0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgfVxuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3JpZ2h0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8qKlxuICogYHdpdGhET01gIGFkZHMgRE9NIHNwZWNpZmljIGJlaGF2aW9ycyB0byB0aGUgZWRpdG9yLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG11c3QgZXh0ZW5kIFNsYXRlJ3MgQ3VzdG9tVHlwZXMgdG8gdXNlXG4gKiB0aGlzIHBsdWdpbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzExLXR5cGVzY3JpcHQgdG8gbGVhcm4gaG93LlxuICovXG52YXIgd2l0aERPTSA9IGZ1bmN0aW9uIHdpdGhET00oZWRpdG9yKSB7XG4gIHZhciBjbGlwYm9hcmRGb3JtYXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd4LXNsYXRlLWZyYWdtZW50JztcbiAgdmFyIGUgPSBlZGl0b3I7XG4gIHZhciB7XG4gICAgYXBwbHksXG4gICAgb25DaGFuZ2UsXG4gICAgZGVsZXRlQmFja3dhcmQsXG4gICAgYWRkTWFyayxcbiAgICByZW1vdmVNYXJrXG4gIH0gPSBlO1xuICAvLyBUaGUgV2Vha01hcCB3aGljaCBtYXBzIGEga2V5IHRvIGEgc3BlY2lmaWMgSFRNTEVsZW1lbnQgbXVzdCBiZSBzY29wZWQgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSB0b1xuICAvLyBhdm9pZCBjb2xsaXNpb25zIGJldHdlZW4gZWRpdG9ycyBpbiB0aGUgRE9NIHRoYXQgc2hhcmUgdGhlIHNhbWUgdmFsdWUuXG4gIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5zZXQoZSwgbmV3IFdlYWtNYXAoKSk7XG4gIGUuYWRkTWFyayA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRiwgX0VESVRPUl9UT19QRU5ESU5HX0RJO1xuICAgIChfRURJVE9SX1RPX1NDSEVEVUxFX0YgPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guZ2V0KGUpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESSA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZSk7XG4gICAgYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfTtcbiAgZS5yZW1vdmVNYXJrID0ga2V5ID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJMjtcbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZSk7XG4gICAgcmVtb3ZlTWFyayhrZXkpO1xuICB9O1xuICBlLmRlbGV0ZUJhY2t3YXJkID0gdW5pdCA9PiB7XG4gICAgaWYgKHVuaXQgIT09ICdsaW5lJykge1xuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICAgIH1cbiAgICBpZiAoZS5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZS5zZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgcGFyZW50QmxvY2tFbnRyeSA9IEVkaXRvci5hYm92ZShlLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGUsIG4pLFxuICAgICAgICBhdDogZS5zZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKHBhcmVudEJsb2NrRW50cnkpIHtcbiAgICAgICAgdmFyIFssIHBhcmVudEJsb2NrUGF0aF0gPSBwYXJlbnRCbG9ja0VudHJ5O1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudFJhbmdlID0gRWRpdG9yLnJhbmdlKGUsIHBhcmVudEJsb2NrUGF0aCwgZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lUmFuZ2UgPSBmaW5kQ3VycmVudExpbmVSYW5nZShlLCBwYXJlbnRFbGVtZW50UmFuZ2UpO1xuICAgICAgICBpZiAoIVJhbmdlLmlzQ29sbGFwc2VkKGN1cnJlbnRMaW5lUmFuZ2UpKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZSwge1xuICAgICAgICAgICAgYXQ6IGN1cnJlbnRMaW5lUmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhpcyBhdHRlbXB0cyB0byByZXNldCB0aGUgTk9ERV9UT19LRVkgZW50cnkgdG8gdGhlIGNvcnJlY3QgdmFsdWVcbiAgLy8gYXMgYXBwbHkoKSBjaGFuZ2VzIHRoZSBvYmplY3QgcmVmZXJlbmNlIGFuZCBoZW5jZSBpbnZhbGlkYXRlcyB0aGUgTk9ERV9UT19LRVkgZW50cnlcbiAgZS5hcHBseSA9IG9wID0+IHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBwYXRoUmVmTWF0Y2hlcyA9IFtdO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSk7XG4gICAgaWYgKHBlbmRpbmdEaWZmcyAhPT0gbnVsbCAmJiBwZW5kaW5nRGlmZnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nRGlmZnMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBwZW5kaW5nRGlmZnMubWFwKHRleHREaWZmID0+IHRyYW5zZm9ybVRleHREaWZmKHRleHREaWZmLCBvcCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlLCB0cmFuc2Zvcm1lZCk7XG4gICAgfVxuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlKTtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlLCB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ1NlbGVjdGlvbiwgb3ApKTtcbiAgICB9XG4gICAgdmFyIHBlbmRpbmdBY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGUpO1xuICAgIGlmIChwZW5kaW5nQWN0aW9uICE9PSBudWxsICYmIHBlbmRpbmdBY3Rpb24gIT09IHZvaWQgMCAmJiBwZW5kaW5nQWN0aW9uLmF0KSB7XG4gICAgICB2YXIgYXQgPSBQb2ludC5pc1BvaW50KHBlbmRpbmdBY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ0FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0FjdGlvbi5hdCkgPyB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApIDogdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdBY3Rpb24uYXQsIG9wKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZSwgYXQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBlbmRpbmdBY3Rpb24pLCB7fSwge1xuICAgICAgICBhdFxuICAgICAgfSkgOiBudWxsKTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIG9wLnBhdGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0VESVRPUl9UT19VU0VSX1NFTEVDO1xuICAgICAgICAgIC8vIFNlbGVjdGlvbiB3YXMgbWFudWFsbHkgc2V0LCBkb24ndCByZXN0b3JlIHRoZSB1c2VyIHNlbGVjdGlvbiBhZnRlciB0aGUgY2hhbmdlLlxuICAgICAgICAgIChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGUpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMudW5yZWYoKTtcbiAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5wYXRoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMob3AucGF0aCk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgcHJldlBhdGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24oUGF0aC5wYXJlbnQob3AucGF0aCksIFBhdGgucGFyZW50KG9wLm5ld1BhdGgpKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBjb21tb25QYXRoKSk7XG4gICAgICAgICAgdmFyIGNoYW5nZWRQYXRoO1xuICAgICAgICAgIGlmIChQYXRoLmlzQmVmb3JlKG9wLnBhdGgsIG9wLm5ld1BhdGgpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5wYXRoKSkpO1xuICAgICAgICAgICAgY2hhbmdlZFBhdGggPSBvcC5uZXdQYXRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5uZXdQYXRoKSkpO1xuICAgICAgICAgICAgY2hhbmdlZFBhdGggPSBvcC5wYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KGNoYW5nZWRQYXRoKSk7XG4gICAgICAgICAgdmFyIGNoYW5nZWROb2RlS2V5ID0gRE9NRWRpdG9yLmZpbmRLZXkoZSwgY2hhbmdlZE5vZGUpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkUGF0aFJlZiA9IEVkaXRvci5wYXRoUmVmKGUsIFBhdGgucGFyZW50KGNoYW5nZWRQYXRoKSk7XG4gICAgICAgICAgcGF0aFJlZk1hdGNoZXMucHVzaChbY2hhbmdlZFBhdGhSZWYsIGNoYW5nZWROb2RlS2V5XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHkob3ApO1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBJU19OT0RFX01BUF9ESVJUWS5zZXQoZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgW3BhdGgsIGtleV0gb2YgbWF0Y2hlcykge1xuICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGUsIHBhdGgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuICAgIGZvciAodmFyIFtwYXRoUmVmLCBfa2V5XSBvZiBwYXRoUmVmTWF0Y2hlcykge1xuICAgICAgaWYgKHBhdGhSZWYuY3VycmVudCkge1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5ub2RlKGUsIHBhdGhSZWYuY3VycmVudCk7XG4gICAgICAgIE5PREVfVE9fS0VZLnNldChfbm9kZSwgX2tleSk7XG4gICAgICB9XG4gICAgICBwYXRoUmVmLnVucmVmKCk7XG4gICAgfVxuICB9O1xuICBlLnNldEZyYWdtZW50RGF0YSA9IGRhdGEgPT4ge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZTtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICB2YXIgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IHN0YXJ0LnBhdGhcbiAgICB9KTtcbiAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBlbmQucGF0aFxuICAgIH0pO1xuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmICFzdGFydFZvaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgZmFrZSBzZWxlY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGEgQmFzZTY0LWVuY29kZWQgY29weSBvZiB0aGVcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG4gICAgdmFyIGRvbVJhbmdlID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBkb21SYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgdmFyIGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbMF07XG4gICAgLy8gTWFrZSBzdXJlIGF0dGFjaCBpcyBub24tZW1wdHksIHNpbmNlIGVtcHR5IG5vZGVzIHdpbGwgbm90IGdldCBjb3BpZWQuXG4gICAgY29udGVudHMuY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQgJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIGF0dGFjaCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQ09NUEFUOiBJZiB0aGUgZW5kIG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gbW92ZSB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIHJhbmdlIGZyb20gdGhlIHZvaWQgbm9kZSdzIHNwYWNlciBzcGFuLCB0byB0aGUgZW5kIG9mIHRoZSB2b2lkIG5vZGUnc1xuICAgIC8vIGNvbnRlbnQsIHNpbmNlIHRoZSBzcGFjZXIgaXMgYmVmb3JlIHZvaWQncyBjb250ZW50IGluIHRoZSBET00uXG4gICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgIHZhciBbdm9pZE5vZGVdID0gZW5kVm9pZDtcbiAgICAgIHZhciByID0gZG9tUmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgdmFyIGRvbU5vZGUgPSBET01FZGl0b3IudG9ET01Ob2RlKGUsIHZvaWROb2RlKTtcbiAgICAgIHIuc2V0RW5kQWZ0ZXIoZG9tTm9kZSk7XG4gICAgICBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IElmIHRoZSBzdGFydCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIGF0dGFjaCB0aGUgZW5jb2RlZFxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSB2b2lkIG5vZGUncyBjb250ZW50IG5vZGUgaW5zdGVhZCBvZiB0aGUgc3BhY2VyLCBiZWNhdXNlXG4gICAgLy8gYXR0YWNoaW5nIGl0IHRvIGVtcHR5IGA8ZGl2Pi88c3Bhbj5gIG5vZGVzIHdpbGwgZW5kIHVwIGhhdmluZyBpdCBlcmFzZWQgYnlcbiAgICAvLyBtb3N0IGJyb3dzZXJzLiAoMjAxOC8wNC8yNylcbiAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1zcGFjZXJdJyk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgemVyby13aWR0aCBzcGFjZSBzcGFucyBmcm9tIHRoZSBjbG9uZWQgRE9NIHNvIHRoYXQgdGhleSBkb24ndFxuICAgIC8vIHNob3cgdXAgZWxzZXdoZXJlIHdoZW4gcGFzdGVkLlxuICAgIEFycmF5LmZyb20oY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSkuZm9yRWFjaCh6dyA9PiB7XG4gICAgICB2YXIgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ24nO1xuICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyAnXFxuJyA6ICcnO1xuICAgIH0pO1xuICAgIC8vIFNldCBhIGBkYXRhLXNsYXRlLWZyYWdtZW50YCBhdHRyaWJ1dGUgb24gYSBub24tZW1wdHkgbm9kZSwgc28gaXQgc2hvd3MgdXBcbiAgICAvLyBpbiB0aGUgSFRNTCwgYW5kIGNhbiBiZSB1c2VkIGZvciBpbnRyYS1TbGF0ZSBwYXN0aW5nLiBJZiBpdCdzIGEgdGV4dFxuICAgIC8vIG5vZGUsIHdyYXAgaXQgaW4gYSBgPHNwYW4+YCBzbyB3ZSBoYXZlIHNvbWV0aGluZyB0byBzZXQgYW4gYXR0cmlidXRlIG9uLlxuICAgIGlmIChpc0RPTVRleHQoYXR0YWNoKSkge1xuICAgICAgdmFyIHNwYW4gPSBhdHRhY2gub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAvLyBDT01QQVQ6IEluIENocm9tZSBhbmQgU2FmYXJpLCBpZiB3ZSBkb24ndCBhZGQgdGhlIGB3aGl0ZS1zcGFjZWAgc3R5bGVcbiAgICAgIC8vIHRoZW4gbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIHdpbGwgYmUgaWdub3JlZC4gKDIwMTcvMDkvMjEpXG4gICAgICBzcGFuLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlJztcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYXR0YWNoKTtcbiAgICAgIGNvbnRlbnRzLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgYXR0YWNoID0gc3BhbjtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gZS5nZXRGcmFnbWVudCgpO1xuICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShmcmFnbWVudCk7XG4gICAgdmFyIGVuY29kZWQgPSB3aW5kb3cuYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSk7XG4gICAgYXR0YWNoLnNldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1mcmFnbWVudCcsIGVuY29kZWQpO1xuICAgIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL1wiLmNvbmNhdChjbGlwYm9hcmRGb3JtYXRLZXkpLCBlbmNvZGVkKTtcbiAgICAvLyBBZGQgdGhlIGNvbnRlbnQgdG8gYSA8ZGl2PiBzbyB0aGF0IHdlIGNhbiBnZXQgaXRzIGlubmVyIEhUTUwuXG4gICAgdmFyIGRpdiA9IGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAndHJ1ZScpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgZGl2LmlubmVySFRNTCk7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgZ2V0UGxhaW5UZXh0KGRpdikpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICBlLmluc2VydERhdGEgPSBkYXRhID0+IHtcbiAgICBpZiAoIWUuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpKSB7XG4gICAgICBlLmluc2VydFRleHREYXRhKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgZS5pbnNlcnRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICAvKipcbiAgICAgKiBDaGVja2luZyBjb3BpZWQgZnJhZ21lbnQgZnJvbSBhcHBsaWNhdGlvbi94LXNsYXRlLWZyYWdtZW50IG9yIGRhdGEtc2xhdGUtZnJhZ21lbnRcbiAgICAgKi9cbiAgICB2YXIgZnJhZ21lbnQgPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9cIi5jb25jYXQoY2xpcGJvYXJkRm9ybWF0S2V5KSkgfHwgZ2V0U2xhdGVGcmFnbWVudEF0dHJpYnV0ZShkYXRhKTtcbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIGUuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGUuaW5zZXJ0VGV4dERhdGEgPSBkYXRhID0+IHtcbiAgICB2YXIgdGV4dCA9IGRhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlLCB7XG4gICAgICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlLmluc2VydFRleHQobGluZSk7XG4gICAgICAgIHNwbGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGUub25DaGFuZ2UgPSBvcHRpb25zID0+IHtcbiAgICB2YXIgb25Db250ZXh0Q2hhbmdlID0gRURJVE9SX1RPX09OX0NIQU5HRS5nZXQoZSk7XG4gICAgaWYgKG9uQ29udGV4dENoYW5nZSkge1xuICAgICAgb25Db250ZXh0Q2hhbmdlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIGU7XG59O1xudmFyIGdldE1hdGNoZXMgPSAoZSwgcGF0aCkgPT4ge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBbbiwgcF0gb2YgRWRpdG9yLmxldmVscyhlLCB7XG4gICAgYXQ6IHBhdGhcbiAgfSkpIHtcbiAgICB2YXIga2V5ID0gRE9NRWRpdG9yLmZpbmRLZXkoZSwgbik7XG4gICAgbWF0Y2hlcy5wdXNoKFtwLCBrZXldKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbnZhciBUUklQTEVfQ0xJQ0sgPSAzO1xuXG4vKipcbiAqIEhvdGtleSBtYXBwaW5ncyBmb3IgZWFjaCBwbGF0Zm9ybS5cbiAqL1xudmFyIEhPVEtFWVMgPSB7XG4gIGJvbGQ6ICdtb2QrYicsXG4gIGNvbXBvc2U6IFsnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3VwJywgJ2JhY2tzcGFjZScsICdlbnRlciddLFxuICBtb3ZlQmFja3dhcmQ6ICdsZWZ0JyxcbiAgbW92ZUZvcndhcmQ6ICdyaWdodCcsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdjdHJsK2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdjdHJsK3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6ICdzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlRm9yd2FyZDogJ3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRCYWNrd2FyZDogJ3NoaWZ0K2xlZnQnLFxuICBleHRlbmRGb3J3YXJkOiAnc2hpZnQrcmlnaHQnLFxuICBpdGFsaWM6ICdtb2QraScsXG4gIGluc2VydFNvZnRCcmVhazogJ3NoaWZ0K2VudGVyJyxcbiAgc3BsaXRCbG9jazogJ2VudGVyJyxcbiAgdW5kbzogJ21vZCt6J1xufTtcbnZhciBBUFBMRV9IT1RLRVlTID0ge1xuICBtb3ZlTGluZUJhY2t3YXJkOiAnb3B0K3VwJyxcbiAgbW92ZUxpbmVGb3J3YXJkOiAnb3B0K2Rvd24nLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnb3B0K2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdvcHQrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogWydjdHJsK2JhY2tzcGFjZScsICdjdHJsK2gnXSxcbiAgZGVsZXRlRm9yd2FyZDogWydjdHJsK2RlbGV0ZScsICdjdHJsK2QnXSxcbiAgZGVsZXRlTGluZUJhY2t3YXJkOiAnY21kK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVMaW5lRm9yd2FyZDogWydjbWQrc2hpZnQ/K2RlbGV0ZScsICdjdHJsK2snXSxcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnb3B0K3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ29wdCtzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kTGluZUJhY2t3YXJkOiAnb3B0K3NoaWZ0K3VwJyxcbiAgZXh0ZW5kTGluZUZvcndhcmQ6ICdvcHQrc2hpZnQrZG93bicsXG4gIHJlZG86ICdjbWQrc2hpZnQreicsXG4gIHRyYW5zcG9zZUNoYXJhY3RlcjogJ2N0cmwrdCdcbn07XG52YXIgV0lORE9XU19IT1RLRVlTID0ge1xuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdjdHJsK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ2N0cmwrc2hpZnQ/K2RlbGV0ZScsXG4gIHJlZG86IFsnY3RybCt5JywgJ2N0cmwrc2hpZnQreiddXG59O1xuLyoqXG4gKiBDcmVhdGUgYSBwbGF0Zm9ybS1hd2FyZSBob3RrZXkgY2hlY2tlci5cbiAqL1xudmFyIGNyZWF0ZSA9IGtleSA9PiB7XG4gIHZhciBnZW5lcmljID0gSE9US0VZU1trZXldO1xuICB2YXIgYXBwbGUgPSBBUFBMRV9IT1RLRVlTW2tleV07XG4gIHZhciB3aW5kb3dzID0gV0lORE9XU19IT1RLRVlTW2tleV07XG4gIHZhciBpc0dlbmVyaWMgPSBnZW5lcmljICYmIGlzSG90a2V5KGdlbmVyaWMpO1xuICB2YXIgaXNBcHBsZSA9IGFwcGxlICYmIGlzSG90a2V5KGFwcGxlKTtcbiAgdmFyIGlzV2luZG93cyA9IHdpbmRvd3MgJiYgaXNIb3RrZXkod2luZG93cyk7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgaWYgKGlzR2VuZXJpYyAmJiBpc0dlbmVyaWMoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoSVNfQVBQTEUgJiYgaXNBcHBsZSAmJiBpc0FwcGxlKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFJU19BUFBMRSAmJiBpc1dpbmRvd3MgJiYgaXNXaW5kb3dzKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufTtcbi8qKlxuICogSG90a2V5cy5cbiAqL1xudmFyIGhvdGtleXMgPSB7XG4gIGlzQm9sZDogY3JlYXRlKCdib2xkJyksXG4gIGlzQ29tcG9zZTogY3JlYXRlKCdjb21wb3NlJyksXG4gIGlzTW92ZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVCYWNrd2FyZCcpLFxuICBpc01vdmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlQmFja3dhcmQnKSxcbiAgaXNEZWxldGVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlTGluZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUZvcndhcmQnKSxcbiAgaXNEZWxldGVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEJhY2t3YXJkJyksXG4gIGlzRGVsZXRlV29yZEZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRCYWNrd2FyZCcpLFxuICBpc0V4dGVuZEZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kRm9yd2FyZCcpLFxuICBpc0V4dGVuZExpbmVCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRMaW5lRm9yd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lRm9yd2FyZCcpLFxuICBpc0l0YWxpYzogY3JlYXRlKCdpdGFsaWMnKSxcbiAgaXNNb3ZlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVMaW5lQmFja3dhcmQnKSxcbiAgaXNNb3ZlTGluZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVGb3J3YXJkJyksXG4gIGlzTW92ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdtb3ZlV29yZEJhY2t3YXJkJyksXG4gIGlzTW92ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ21vdmVXb3JkRm9yd2FyZCcpLFxuICBpc1JlZG86IGNyZWF0ZSgncmVkbycpLFxuICBpc1NvZnRCcmVhazogY3JlYXRlKCdpbnNlcnRTb2Z0QnJlYWsnKSxcbiAgaXNTcGxpdEJsb2NrOiBjcmVhdGUoJ3NwbGl0QmxvY2snKSxcbiAgaXNUcmFuc3Bvc2VDaGFyYWN0ZXI6IGNyZWF0ZSgndHJhbnNwb3NlQ2hhcmFjdGVyJyksXG4gIGlzVW5kbzogY3JlYXRlKCd1bmRvJylcbn07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xudmFyIHNoYWxsb3dDb21wYXJlID0gKG9iajEsIG9iajIpID0+IE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoICYmIE9iamVjdC5rZXlzKG9iajEpLmV2ZXJ5KGtleSA9PiBvYmoyLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqMVtrZXldID09PSBvYmoyW2tleV0pO1xudmFyIGlzRGVjb3JhdGlvbkZsYWdzRXF1YWwgPSAocmFuZ2UsIG90aGVyKSA9PiB7XG4gIHZhciByYW5nZU93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQpO1xuICB2YXIgb3RoZXJPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdGhlciwgX2V4Y2x1ZGVkMik7XG4gIHJldHVybiByYW5nZVtQTEFDRUhPTERFUl9TWU1CT0xdID09PSBvdGhlcltQTEFDRUhPTERFUl9TWU1CT0xdICYmIHNoYWxsb3dDb21wYXJlKHJhbmdlT3duUHJvcHMsIG90aGVyT3duUHJvcHMpO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXG4gKlxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcbiAqIGtlcHQgaW4gb3JkZXIsIGFuZCB0aGUgb2RkIGNhc2Ugd2hlcmUgdGhleSBhcmVuJ3QgaXMgb2theSB0byByZS1yZW5kZXIgZm9yLlxuICovXG52YXIgaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbCA9IChsaXN0LCBhbm90aGVyKSA9PiB7XG4gIGlmIChsaXN0Lmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldO1xuICAgIGlmICghUmFuZ2UuZXF1YWxzKHJhbmdlLCBvdGhlcikgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxuICpcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cbiAqL1xudmFyIGlzVGV4dERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcbiAgICAvLyBjb21wYXJlIG9ubHkgb2Zmc2V0cyBiZWNhdXNlIHBhdGhzIGRvZXNuJ3QgbWF0dGVyIGZvciB0ZXh0XG4gICAgaWYgKHJhbmdlLmFuY2hvci5vZmZzZXQgIT09IG90aGVyLmFuY2hvci5vZmZzZXQgfHwgcmFuZ2UuZm9jdXMub2Zmc2V0ICE9PSBvdGhlci5mb2N1cy5vZmZzZXQgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCB7IENBTl9VU0VfRE9NLCBET01FZGl0b3IsIERPTUVsZW1lbnQsIERPTU5vZGUsIERPTVJhbmdlLCBET01TZWxlY3Rpb24sIERPTVN0YXRpY1JhbmdlLCBET01UZXh0LCBFRElUT1JfVE9fRUxFTUVOVCwgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiwgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULCBFRElUT1JfVE9fT05fQ0hBTkdFLCBFRElUT1JfVE9fUEVORElOR19BQ1RJT04sIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLCBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MsIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiwgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQsIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCwgRURJVE9SX1RPX1VTRVJfTUFSS1MsIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTiwgRURJVE9SX1RPX1dJTkRPVywgRUxFTUVOVF9UT19OT0RFLCBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQsIGhvdGtleXMgYXMgSG90a2V5cywgSVNfQU5EUk9JRCwgSVNfQ0hST01FLCBJU19DT01QT1NJTkcsIElTX0ZJUkVGT1gsIElTX0ZJUkVGT1hfTEVHQUNZLCBJU19GT0NVU0VELCBJU19JT1MsIElTX05PREVfTUFQX0RJUlRZLCBJU19SRUFEX09OTFksIElTX1VDX01PQklMRSwgSVNfV0VCS0lULCBJU19XRUNIQVRCUk9XU0VSLCBLZXksIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MLCBOT0RFX1RPX0VMRU1FTlQsIE5PREVfVE9fSU5ERVgsIE5PREVfVE9fS0VZLCBOT0RFX1RPX1BBUkVOVCwgUExBQ0VIT0xERVJfU1lNQk9MLCBUUklQTEVfQ0xJQ0ssIGFwcGx5U3RyaW5nRGlmZiwgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0RGVmYXVsdFZpZXcsIGdldFNlbGVjdGlvbiwgaGFzU2hhZG93Um9vdCwgaXNBZnRlciwgaXNCZWZvcmUsIGlzRE9NRWxlbWVudCwgaXNET01Ob2RlLCBpc0RPTVNlbGVjdGlvbiwgaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbCwgaXNQbGFpblRleHRPbmx5UGFzdGUsIGlzVGV4dERlY29yYXRpb25zRXF1YWwsIGlzVHJhY2tlZE11dGF0aW9uLCBtZXJnZVN0cmluZ0RpZmZzLCBub3JtYWxpemVET01Qb2ludCwgbm9ybWFsaXplUG9pbnQsIG5vcm1hbGl6ZVJhbmdlLCBub3JtYWxpemVTdHJpbmdEaWZmLCB0YXJnZXRSYW5nZSwgdmVyaWZ5RGlmZlN0YXRlLCB3aXRoRE9NIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/slate-dom/dist/index.es.js\n"));

/***/ }),

/***/ "./node_modules/slate-react/dist/index.es.js":
/*!***************************************************!*\
  !*** ./node_modules/slate-react/dist/index.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: () => (/* binding */ DefaultElement),\n/* harmony export */   DefaultLeaf: () => (/* binding */ DefaultLeaf),\n/* harmony export */   DefaultPlaceholder: () => (/* binding */ DefaultPlaceholder),\n/* harmony export */   Editable: () => (/* binding */ Editable),\n/* harmony export */   NODE_TO_INDEX: () => (/* reexport safe */ slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX),\n/* harmony export */   NODE_TO_PARENT: () => (/* reexport safe */ slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT),\n/* harmony export */   ReactEditor: () => (/* binding */ ReactEditor),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   useComposing: () => (/* binding */ useComposing),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useFocused: () => (/* binding */ useFocused),\n/* harmony export */   useReadOnly: () => (/* binding */ useReadOnly),\n/* harmony export */   useSelected: () => (/* binding */ useSelected),\n/* harmony export */   useSlate: () => (/* binding */ useSlate),\n/* harmony export */   useSlateSelection: () => (/* binding */ useSlateSelection),\n/* harmony export */   useSlateSelector: () => (/* binding */ useSlateSelector),\n/* harmony export */   useSlateStatic: () => (/* binding */ useSlateStatic),\n/* harmony export */   useSlateWithV: () => (/* binding */ useSlateWithV),\n/* harmony export */   withReact: () => (/* binding */ withReact)\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"./node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"./node_modules/scroll-into-view-if-needed/dist/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slate-dom */ \"./node_modules/slate-dom/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @juggle/resize-observer */ \"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * A React context for sharing the editor object.\n */\nvar EditorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * Get the current editor object from the React context.\n */\nvar useSlateStatic = () => {\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar ReactEditor = slate_dom__WEBPACK_IMPORTED_MODULE_4__.DOMEditor;\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25;\n// Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200;\n// Replace with `const debug = console.log` to debug\nvar debug = function debug() {};\n// Type guard to check if a value is a DataTransfer\nvar isDataTransfer = value => (value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n  var applyPendingSelection = () => {\n    var pendingSelection = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.get(editor);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeRange)(editor, pendingSelection);\n      if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n      }\n    }\n  };\n  var performAction = () => {\n    var action = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.delete(editor);\n    if (!action) {\n      return;\n    }\n    if (action.at) {\n      var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizePoint)(editor, action.at) : (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeRange)(editor, action.at);\n      if (!target) {\n        return;\n      }\n      var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n      if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n      }\n    }\n    action.run();\n  };\n  var flush = () => {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n    var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor), slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = hasPendingDiffs();\n    var diff;\n    while (diff = (_EDITOR_TO_PENDING_DI = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {\n      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n      var pendingMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n      if (pendingMarks !== undefined) {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n      var range = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.targetRange)(diff);\n      if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n      }\n      if (diff.diff.text) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n      }\n      // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n      if (!(0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.verifyDiffState)(editor, diff)) {\n        scheduleSelectionChange = false;\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.delete(editor);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action';\n        // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 || selectionRef.unref();\n      }\n    }\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n    if (selection && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n      slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n    }\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    }\n    // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.get(editor);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n    compositionEndTimeoutId = setTimeout(() => {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n  var handleCompositionStart = _event => {\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, true);\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n    if (!placeholderElement) {\n      return;\n    }\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n    placeholderElement.style.removeProperty('display');\n  };\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI3;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n    if (idx < 0) {\n      var normalized = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeStringDiff)(target.text, diff);\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n      updatePlaceholderVisibility();\n      return;\n    }\n    var merged = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.mergeStringDiffs)(target.text, pendingDiffs[idx].diff, diff);\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n    pendingDiffs[idx] = _objectSpread$5(_objectSpread$5({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n    if (hasPendingAction()) {\n      flush();\n    }\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    });\n    // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n    actionTimeoutId = setTimeout(flush);\n  };\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n      return;\n    }\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n    var [nativeTargetRange] = event.getTargetRanges();\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n    if (!targetRange) {\n      return;\n    }\n    // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n    var canStoreDiff = true;\n    if (type.startsWith('delete')) {\n      if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n        var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n        var _leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _start.path);\n        if (_leaf.text.length === _start.offset && _end.offset === 0) {\n          var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n            at: _start.path,\n            match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n          });\n          if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], _end.path)) {\n            targetRange = {\n              anchor: _end,\n              focus: _end\n            };\n          }\n        }\n      }\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n      var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n      var diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset\n      };\n      var pendingDiffs = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor);\n      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(change => slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];\n      var text = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.applyStringDiff)(leaf.text, ...diffs);\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false;\n      }\n      if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n        if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          var point = {\n            path: targetRange.anchor.path,\n            offset: start.offset\n          };\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n          handleUserSelect(range);\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset\n          });\n        }\n        return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n          direction\n        }), {\n          at: targetRange\n        });\n      }\n    }\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n          if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n            var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n          var {\n            anchor: _anchor\n          } = targetRange;\n          // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n          var nativeCollapsed = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMSelection)(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n          if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if (isDataTransfer(data)) {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n          var _text = data !== null && data !== void 0 ? data : '';\n          // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            _text = _text.replace('\\uFEFF', '');\n          }\n          // Pastes from the Android clipboard will generate `insertText` events.\n          // If the copied text contains any newlines, Android will append an\n          // extra newline to the end of the copied text.\n          if (type === 'insertText' && /.*\\n.*\\n$/.test(_text)) {\n            _text = _text.slice(0, -1);\n          }\n          // If the text includes a newline, split it at newlines and paste each component\n          // string, with soft breaks in between each.\n          if (_text.includes('\\n')) {\n            return scheduleAction(() => {\n              var parts = _text.split('\\n');\n              parts.forEach((line, i) => {\n                if (line) {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                }\n                if (i !== parts.length - 1) {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                }\n              });\n            }, {\n              at: targetRange\n            });\n          }\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start2, _end2] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var _diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text: _text\n            };\n            // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n            if (_text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n              if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                _diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = _diff;\n              } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$5(_objectSpread$5({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + _text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n            if (canStoreDiff) {\n              storeDiff(_start2.path, _diff);\n              return;\n            }\n          }\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n  var hasPendingAction = () => {\n    return !!slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI4;\n    return !!((_EDITOR_TO_PENDING_DI4 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n  };\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n  var isFlushing = () => {\n    return flushing;\n  };\n  var handleUserSelect = range => {\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.set(editor, range);\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var {\n      selection\n    } = editor;\n    if (!range) {\n      return;\n    }\n    var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n    if (mutations.some(mutation => (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTrackedMutation)(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();\n    }\n  };\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\nvar useIsomorphicLayoutEffect = slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, [mutationObserver, node, options]);\n}\n\nvar _excluded$2 = [\"node\"];\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nvar useAndroidInputManager = !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? () => null : _ref => {\n  var {\n      node\n    } = _ref,\n    options = _objectWithoutProperties(_ref, _excluded$2);\n  if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n    return null;\n  }\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => createAndroidInputManager(_objectSpread$4({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n  if (isMounted) {\n    inputManager.flush();\n  }\n  return inputManager;\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Leaf content strings.\n */\nvar String$1 = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n  var isMarkPlaceholder = Boolean(leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.MARK_PLACEHOLDER_SYMBOL]);\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n    });\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  }\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  }\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\n * Leaf strings with text in them.\n */\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  };\n  var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent);\n  // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    }\n    // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n  });\n  // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n    ref: ref\n  }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  }, props.children);\n}));\n/**\n * Leaf strings without text, render as zero-width strings.\n */\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$3({}, attributes), !(slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_IOS) || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// Delay the placeholder on Android to prevent the keyboard from closing.\n// (https://github.com/ianstormtaylor/slate/pull/5368)\nvar PLACEHOLDER_DELAY = slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? 300 : 0;\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect();\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null;\n    }\n  }\n}\nfunction clearTimeoutRef(timeoutRef) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = null;\n  }\n}\n/**\n * Individual leaves in a text node with unique formatting.\n */\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, _objectSpread$2({}, props))\n  } = props;\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var [showPlaceholder, setShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n  var showPlaceholderTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var callbackPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(placeholderEl => {\n    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n    if (placeholderEl == null) {\n      var _leaf$onPlaceholderRe;\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n      (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf, null);\n    } else {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n      if (!placeholderResizeObserver.current) {\n        // Create a new observer and observe the placeholder element.\n        var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_5__.ResizeObserver;\n        placeholderResizeObserver.current = new ResizeObserver$1(() => {\n          var _leaf$onPlaceholderRe2;\n          (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n        });\n      }\n      placeholderResizeObserver.current.observe(placeholderEl);\n      placeholderRef.current = placeholderEl;\n    }\n  }, [placeholderRef, leaf, editor]);\n  var children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String$1, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n  var leafIsPlaceholder = Boolean(leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder, so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(() => {\n          setShowPlaceholder(true);\n          showPlaceholderTimeoutRef.current = null;\n        }, PLACEHOLDER_DELAY);\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef);\n      setShowPlaceholder(false);\n    }\n    return () => clearTimeoutRef(showPlaceholderTimeoutRef);\n  }, [leafIsPlaceholder, setShowPlaceholder]);\n  if (leafIsPlaceholder && showPlaceholder) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n          // Fixes https://github.com/udecode/plate/issues/2315\n          WebkitUserModify: slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT ? 'inherit' : undefined\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef\n      }\n    };\n    children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, renderPlaceholder(placeholderProps), children);\n  }\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\nvar MemoizedLeaf = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL] === prev.leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$2({}, attributes), children);\n};\n\n/**\n * Text.\n */\nvar Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var leaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  }\n  // Update element-related weak maps with the DOM element ref.\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(span => {\n    var KEY_TO_ELEMENT = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (span) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, span);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(text, span);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(span, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(text);\n      if (ref.current) {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.delete(ref.current);\n      }\n    }\n    ref.current = span;\n  }, [ref, editor, key, text]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: callbackRef\n  }, children);\n};\nvar MemoizedText = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTextDecorationsEqual)(next.decorations, prev.decorations);\n});\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Element.\n */\nvar Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, _objectSpread$1({}, p)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, ref);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(element, ref);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  });\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  }\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n    var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n    var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  }\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n    children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(_text, 0);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(_text, element);\n  }\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\nvar MemoizedElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isElementDecorationsEqual)(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(prev.selection, next.selection));\n});\n/**\n * The default element renderer.\n */\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\n * A React context for sharing the `decorate` prop of the editable.\n */\nvar DecorateContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(() => []);\n/**\n * Get the current `decorate` prop of the editable.\n */\nvar useDecorate = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n};\n\n/**\n * A React context for sharing the `selected` state of an element.\n */\nvar SelectedContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `selected` state of an element.\n */\nvar useSelected = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectedContext);\n};\n\n/**\n * Children.\n */\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.set(editor, false);\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, p);\n    var sel = selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n    for (var dec of decorations) {\n      var d = slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(dec, range);\n      if (d) {\n        ds.push(d);\n      }\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n)) {\n      children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(n, i);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(n, node);\n  }\n  return children;\n};\n\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */\nvar ReadOnlyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `readOnly` state of the editor.\n */\nvar useReadOnly = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * Get the current editor object from the React context.\n */\nvar useSlate = () => {\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar useSlateWithV = () => {\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  return context;\n};\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n  var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n  var clear = () => {\n    bufferedMutations = [];\n  };\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n    var trackedMutations = mutations.filter(mutation => (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTrackedMutation)(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(mutation => {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return;\n        }\n        mutation.removedNodes.forEach(node => {\n          mutation.target.insertBefore(node, mutation.nextSibling);\n        });\n        mutation.addedNodes.forEach(node => {\n          mutation.target.removeChild(node);\n        });\n      });\n      // Clear buffered mutations to ensure we don't undo them twice\n      clear();\n    }\n  }\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n};\n// We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"context\", null);\n    _defineProperty(this, \"manager\", null);\n    _defineProperty(this, \"mutationObserver\", null);\n  }\n  observe() {\n    var _this$mutationObserve;\n    var {\n      node\n    } = this.props;\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n  }\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n      (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);\n    }\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();\n    return null;\n  }\n  componentDidUpdate() {\n    var _this$manager3;\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();\n    this.observe();\n  }\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();\n  }\n  render() {\n    return this.props.children;\n  }\n}\n_defineProperty(RestoreDOMComponent, \"contextType\", EditorContext);\nvar RestoreDOM = slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\n\n/**\n * A React context for sharing the `composing` state of the editor.\n */\nvar ComposingContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `composing` state of the editor.\n */\nvar useComposing = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ComposingContext);\n};\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\", \"disableDefaultStyles\"],\n  _excluded2 = [\"text\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Children = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\n * Editable.\n */\nvar Editable = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, forwardedRef) => {\n  var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, _objectSpread({}, props)), []);\n  var {\n      autoFocus,\n      decorate = defaultDecorate,\n      onDOMBeforeInput: propsOnDOMBeforeInput,\n      placeholder,\n      readOnly = false,\n      renderElement,\n      renderLeaf,\n      renderPlaceholder = defaultRenderPlaceholder,\n      scrollSelectionIntoView = defaultScrollSelectionIntoView,\n      style: userStyle = {},\n      as: Component = 'div',\n      disableDefaultStyles = false\n    } = props,\n    attributes = _objectWithoutProperties(props, _excluded$1);\n  var editor = useSlate();\n  // Rerender editor when composition status changed\n  var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n  var [placeholderHeight, setPlaceholderHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n  var processing = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_FORCE_RENDER.set(editor, forceRender);\n  // Update internal state on each render.\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_READ_ONLY.set(editor, readOnly);\n  // Keep track of some state for the event handler logic.\n  var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []);\n  // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  /**\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\n   *\n   * It is defined as a reference to simplify hook dependencies and clarify that\n   * it needs to be initialized.\n   */\n  var androidInputManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(() => {\n    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n      onDOMSelectionChange();\n      return;\n    }\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (!processing.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && root instanceof ShadowRoot) {\n      processing.current = true;\n      var active = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getActiveElement)();\n      if (active) {\n        document.execCommand('indent');\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n      processing.current = false;\n      return;\n    }\n    var androidInputManager = androidInputManagerRef.current;\n    if ((slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var _root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = _root;\n      var _el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(_root);\n      if (activeElement === _el) {\n        state.latestElement = activeElement;\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.set(editor, true);\n      } else {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.delete(editor);\n      }\n      if (!domSelection) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeInEditor = ReactEditor.hasTarget(editor, focusNode);\n      if (anchorNodeSelectable && focusNodeInEditor) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range);\n          }\n        }\n      }\n      // Deselect the editor if the dom selection is not selectable in readonly mode\n      if (readOnly && (!anchorNodeSelectable || !focusNodeInEditor)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n    }\n  }, 100), [editor, readOnly, state]);\n  var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    var _androidInputManagerR, _androidInputManagerR2;\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n    if (ref.current && (window = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getDefaultView)(ref.current))) {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_WINDOW.set(editor, window);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.set(editor, ref.current);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(editor, ref.current);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(editor);\n    }\n    // Make sure the DOM selection state is in sync.\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(root);\n    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n      return;\n    }\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None';\n      // If the DOM selection is properly unset, we're done.\n      if (!selection && !hasDomSelection) {\n        return;\n      }\n      // Get anchorNode and focusNode\n      var focusNode = domSelection.focusNode;\n      var anchorNode;\n      // COMPAT: In firefox the normal seletion way does not work\n      // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n      if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX && domSelection.rangeCount > 1) {\n        var firstRange = domSelection.getRangeAt(0);\n        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);\n        // Right to left\n        if (firstRange.startContainer === focusNode) {\n          anchorNode = lastRange.endContainer;\n        } else {\n          // Left to right\n          anchorNode = firstRange.startContainer;\n        }\n      } else {\n        anchorNode = domSelection.anchorNode;\n      }\n      // verify that the dom selection is in the editor\n      var editorElement = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n      if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n        hasDomSelectionInEditor = true;\n      }\n      // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n        if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n          var _anchorNode;\n          if (!state.hasMarkPlaceholder) {\n            return;\n          }\n          // Ensure selection is inside the mark placeholder\n          if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      }\n      // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      }\n      // Otherwise the DOM selection is out of sync, so update it.\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n      if (newDomRange) {\n        if (ReactEditor.isComposing(editor) && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n          domSelection.collapseToEnd();\n        } else if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n      return newDomRange;\n    };\n    // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n    if (domSelection.rangeCount <= 1) {\n      setDomSelection();\n    }\n    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';\n    if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {\n            // Ignore, dom and state might be out of sync\n          }\n        };\n        // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (processing !== null && processing !== void 0 && processing.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && root instanceof ShadowRoot) {\n      var ranges = event.getTargetRanges();\n      var range = ranges[0];\n      var newRange = new window.Range();\n      newRange.setStart(range.startContainer, range.startOffset);\n      newRange.setEnd(range.endContainer, range.endOffset);\n      // Translate the DOM Range into a Slate Range\n      var slateRange = ReactEditor.toSlateRange(editor, newRange, {\n        exactMatch: false,\n        suppressThrow: false\n      });\n      slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, slateRange);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      return;\n    }\n    onUserInput();\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManagerRef.current) {\n        return androidInputManagerRef.current.handleDOMBeforeInput(event);\n      }\n      // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText';\n      // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n      var native = false;\n      if (type === 'insertText' && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) &&\n      // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) &&\n      // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        native = true;\n        // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n        if (editor.marks) {\n          native = false;\n        }\n        // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint)\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n          var _node$parentElement, _window$getComputedSt;\n          // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n          // Therefore we don't allow native events to insert text at the end of anchor nodes.\n          var {\n            anchor\n          } = selection;\n          var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n          var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n          var _window = ReactEditor.getWindow(editor);\n          if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n            var _lastText$textContent;\n            // Find the last text node inside the anchor.\n            var lastText = _window === null || _window === void 0 ? void 0 : _window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n            if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n              native = false;\n            }\n          }\n          // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n          // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n          if (native && node.parentElement && (_window === null || _window === void 0 || (_window$getComputedSt = _window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n            var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n              at: anchor.path,\n              match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n            });\n            if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes('\\t')) {\n              native = false;\n            }\n          }\n        }\n      }\n      // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n      // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint via ReactEditor.toSlateRange)\n      if ((!type.startsWith('delete') || type.startsWith('deleteBy')) && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n        var [targetRange] = event.getTargetRanges();\n        if (targetRange) {\n          var _range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n          if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, _range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n            if (selectionRef) {\n              slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      }\n      // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n      if (isCompositionChange) {\n        return;\n      }\n      if (!native) {\n        event.preventDefault();\n      }\n      // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n      if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            break;\n          }\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n            break;\n          }\n        case 'deleteContentBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n            break;\n          }\n        case 'deleteEntireSoftLine':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteWordBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'deleteWordForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'insertLineBreak':\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n          break;\n        case 'insertParagraph':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n            break;\n          }\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n              }\n            }\n            // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n              } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n              }\n            }\n            break;\n          }\n      }\n      // Restore the actual user section if nothing manually set it.\n      var toRestore = (_EDITOR_TO_USER_SELEC = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.delete(editor);\n      if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n      }\n    }\n  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(node => {\n    if (node == null) {\n      onDOMSelectionChange.cancel();\n      scheduleOnDOMSelectionChange.cancel();\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.delete(editor);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(editor);\n      if (ref.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    } else {\n      // Attach a native DOM event handler for `beforeinput` events, because React's\n      // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n      // real `beforeinput` events sadly... (2019/11/04)\n      // https://github.com/facebook/react/issues/11211\n      if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        node.addEventListener('beforeinput', onDOMBeforeInput);\n      }\n    }\n    ref.current = node;\n    if (typeof forwardedRef === 'function') {\n      forwardedRef(node);\n    } else if (forwardedRef) {\n      forwardedRef.current = node;\n    }\n  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput, forwardedRef]);\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    // Attach a native DOM event handler for `selectionchange`, because React's\n    // built-in `onSelect` handler doesn't fire for all selection changes. It's\n    // a leaky polyfill that only fires on keypresses or clicks. Instead, we\n    // want to fire for any change to the selection inside the editor.\n    // (2019/11/04) https://github.com/facebook/react/issues/5785\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    // Listen for dragend and drop globally. In Firefox, if a drop handler\n    // initiates an operation that causes the originally dragged element to\n    // unmount, that element will not emit a dragend event. (2024/06/21)\n    var stoppedDragging = () => {\n      state.isDraggingInternally = false;\n    };\n    window.document.addEventListener('dragend', stoppedDragging);\n    window.document.addEventListener('drop', stoppedDragging);\n    return () => {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n      window.document.removeEventListener('dragend', stoppedDragging);\n      window.document.removeEventListener('drop', stoppedDragging);\n    };\n  }, [scheduleOnDOMSelectionChange, state]);\n  var decorations = decorate([editor, []]);\n  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === '' && !isComposing;\n  var placeHolderResizeHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(placeholderEl => {\n    if (placeholderEl && showPlaceholder) {\n      var _placeholderEl$getBou;\n      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n    } else {\n      setPlaceholderHeight(undefined);\n    }\n  }, [showPlaceholder]);\n  if (showPlaceholder) {\n    var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n    decorations.push({\n      [slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      onPlaceholderResize: placeHolderResizeHandler,\n      anchor: start,\n      focus: start\n    });\n  }\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n  if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n    var rest = _objectWithoutProperties(leaf, _excluded2);\n    // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(_objectSpread(_objectSpread(_objectSpread({\n        [slate_dom__WEBPACK_IMPORTED_MODULE_4__.MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  }\n  // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n        var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path);\n        // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n          loose: true\n        })) {\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ComposingContext.Provider, {\n    value: isComposing\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, _objectSpread(_objectSpread({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes), {}, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: callbackRef,\n    style: _objectSpread(_objectSpread({}, disableDefaultStyles ? {} : _objectSpread({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, placeholderHeight ? {\n      minHeight: placeholderHeight\n    } : {})), userStyle),\n    onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n        }\n      }\n    }, [attributes.onBeforeInput, editor, readOnly]),\n    onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (isEventHandled(event, attributes.onInput)) {\n        return;\n      }\n      if (androidInputManagerRef.current) {\n        androidInputManagerRef.current.handleInput();\n        return;\n      }\n      // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n      for (var op of deferredOperations.current) {\n        op();\n      }\n      deferredOperations.current = [];\n      // COMPAT: Since `beforeinput` doesn't fully `preventDefault`,\n      // there's a chance that content might be placed in the browser's undo stack.\n      // This means undo can be triggered even when the div is not focused,\n      // and it only triggers the input event for the node. (2024/10/09)\n      if (!ReactEditor.isFocused(editor)) {\n        var native = event.nativeEvent;\n        var maybeHistoryEditor = editor;\n        if (native.inputType === 'historyUndo' && typeof maybeHistoryEditor.undo === 'function') {\n          maybeHistoryEditor.undo();\n          return;\n        }\n        if (native.inputType === 'historyRedo' && typeof maybeHistoryEditor.redo === 'function') {\n          maybeHistoryEditor.redo();\n          return;\n        }\n      }\n    }, [attributes.onInput, editor]),\n    onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      }\n      // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n      if (relatedTarget === el) {\n        return;\n      }\n      // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n      if ((0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMElement)(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      }\n      // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n      if (relatedTarget != null && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      }\n      // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n      if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n        var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(root);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n      }\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.delete(editor);\n    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),\n    onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n          return;\n        }\n        if (event.detail === slate_dom__WEBPACK_IMPORTED_MODULE_4__.TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n          if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n            var _block$;\n            var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n              match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n          return;\n        }\n        if (readOnly) {\n          return;\n        }\n        var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n        var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: end\n        });\n        if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n          var _range2 = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range2);\n        }\n      }\n    }, [editor, attributes.onClick, readOnly]),\n    onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR3;\n        if (ReactEditor.isComposing(editor)) {\n          Promise.resolve().then(() => {\n            setIsComposing(false);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n          });\n        }\n        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);\n        if (isEventHandled(event, attributes.onCompositionEnd) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n          return;\n        }\n        // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX_LEGACY && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_IOS && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WECHATBROWSER && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_UC_MOBILE && event.data) {\n          var placeholderMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n          // Ensure we insert text with the marks the user was actually seeing\n          if (placeholderMarks !== undefined) {\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n          var userMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.get(editor);\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd, editor]),\n    onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate, editor]),\n    onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR4;\n        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);\n        if (isEventHandled(event, attributes.onCompositionStart) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n          return;\n        }\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n          return;\n        }\n      }\n    }, [attributes.onCompositionStart, editor]),\n    onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy, editor]),\n    onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n        if (selection) {\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n          } else {\n            var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onCut]),\n    onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver, editor]),\n    onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: path,\n          voids: true\n        });\n        // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n        if (voidMatch) {\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n        }\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, editor, attributes.onDragStart, state]),\n    onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault();\n        // Keep a reference to the dragged range before updating selection\n        var draggedRange = editor.selection;\n        // Find the range where the drop happened\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n        if (state.isDraggingInternally) {\n          if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n        ReactEditor.insertData(editor, data);\n        // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n    }, [readOnly, editor, attributes.onDrop, state]),\n    onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      }\n    }, [readOnly, state, attributes, editor]),\n    onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement;\n        // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, state, editor, attributes.onFocus]),\n    onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        var _androidInputManagerR5;\n        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event;\n        // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === 'rtl';\n        // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n          return;\n        }\n        // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        }\n        // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: isRTL ? 'end' : 'start'\n            });\n          }\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: isRTL ? 'start' : 'end'\n            });\n          }\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        }\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isBold(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isItalic(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n        } else {\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_CHROME || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteBackward(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n              var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n              if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onKeyDown]),\n    onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        // COMPAT: Safari InputEvents generated by pasting won't include\n        // application/x-slate-fragment items, so use the\n        // ClipboardEvent here. (2023/03/15)\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isPlainTextOnlyPaste)(event.nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, editor, attributes.onPaste])\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  }))))));\n});\n/**\n * The default placeholder element\n */\nvar DefaultPlaceholder = _ref => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread({}, attributes), children, slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null))\n  );\n};\n/**\n * A default memoized decorate function.\n */\nvar defaultDecorate = () => [];\n/**\n * A default implement to scroll dom range into view.\n */\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n      scrollMode: 'if-needed'\n    });\n    // @ts-expect-error an unorthodox delete D:\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\n * Check if an event is overrided by a handler.\n */\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\n * Check if the event's target is an input element\n */\nvar isDOMEventTargetInput = event => {\n  return (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\n * Check if a DOM event is overrided by a handler.\n */\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.defaultPrevented;\n};\n\n/**\n * A React context for sharing the `focused` state of the editor.\n */\nvar FocusedContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `focused` state of the editor.\n */\nvar useFocused = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\n * A React context for sharing the editor selector context in a way to control rerenders\n */\nvar SlateSelectorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar refEquality = (a, b) => a === b;\n/**\n * use redux style selectors to prevent rerendering on every keystroke.\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\n *\n * Example:\n * ```\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\n * ```\n */\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n  var {\n    getSlate,\n    addEventListener\n  } = context;\n  var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n  var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(() => null);\n  var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var selectedState;\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n    throw err;\n  }\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(() => {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        if (err instanceof Error) {\n          latestSubscriptionCallbackError.current = err;\n        } else {\n          latestSubscriptionCallbackError.current = new Error(String(err));\n        }\n      }\n      forceRender();\n    }\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return () => unsubscribe();\n  },\n  // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\n * Create selector context with editor updating on every editor change\n */\nfunction useSelectorContext(editor) {\n  var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]).current;\n  var slateRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)({\n    editor\n  }).current;\n  var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(editor => {\n    slateRef.editor = editor;\n    eventListeners.forEach(listener => listener(editor));\n  }, [eventListeners, slateRef]);\n  var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: callback => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\n\nvar REACT_MAJOR_VERSION = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split('.')[0], 10);\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"onSelectionChange\", \"onValueChange\", \"initialValue\"];\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */\nvar Slate = props => {\n  var {\n      editor,\n      children,\n      onChange,\n      onSelectionChange,\n      onValueChange,\n      initialValue\n    } = props,\n    rest = _objectWithoutProperties(props, _excluded);\n  var [context, setContext] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(() => {\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(initialValue)) {\n      throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(initialValue)));\n    }\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n    }\n    editor.children = initialValue;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = useSelectorContext(editor);\n  var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(options => {\n    var _options$operation;\n    if (onChange) {\n      onChange(editor.children);\n    }\n    switch (options === null || options === void 0 || (_options$operation = options.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type) {\n      case 'set_selection':\n        onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);\n        break;\n      default:\n        onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);\n    }\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [editor, handleSelectorChange, onChange, onSelectionChange, onValueChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n    return () => {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ON_CHANGE.set(editor, () => {});\n    };\n  }, [editor, onContextChange]);\n  var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  }, [editor]);\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n    if (REACT_MAJOR_VERSION >= 17) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\n * Get the current editor object from the React context.\n * @deprecated Use useSlateStatic instead.\n */\nvar useEditor = () => {\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n/**\n * Get the current slate selection.\n * Only triggers a rerender when the selection actually changes\n */\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withReact = function withReact(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  e = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.withDOM)(e, clipboardFormatKey);\n  var {\n    onChange\n  } = e;\n  e.onChange = options => {\n    // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n    // that the children and selection can get out of sync for one render\n    // pass. So we have to use this unstable API to ensure it batches them.\n    // (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? (react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates) : callback => callback();\n    maybeBatchUpdates(() => {\n      onChange(options);\n    });\n  };\n  return e;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNBO0FBQytIO0FBQzlHO0FBQzZEO0FBQzYzQjtBQUN4N0I7QUFDRDtBQUN4Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnREFBUzs7QUFFM0IsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1gsSUFBSSwwREFBbUI7QUFDdkI7QUFDQSxNQUFNLDBEQUFtQixxQkFBcUI7QUFDOUM7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDLCtDQUFRO0FBQzFDLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBLEdBQUcsZUFBZSwwREFBbUI7QUFDckM7QUFDQSxHQUFHLGVBQWUsMERBQW1CO0FBQ3JDO0FBQ0EsR0FBRyxlQUFlLDBEQUFtQjtBQUNyQztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBSztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtEQUFPO0FBQ2I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEVBQWdDO0FBQ3ZGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVpUDtBQUNqUCIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXREaXJlY3Rpb24gZnJvbSAnZGlyZWN0aW9uJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUsIG1lbW8sIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrLCBDb21wb25lbnQsIHVzZVJlZHVjZXIsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc2Nyb2xsSW50b1ZpZXcgZnJvbSAnc2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWQnO1xuaW1wb3J0IHsgRWRpdG9yLCBSYW5nZSwgVHJhbnNmb3JtcywgTm9kZSwgVGV4dCBhcyBUZXh0JDEsIFBhdGgsIFBvaW50LCBFbGVtZW50IGFzIEVsZW1lbnQkMSwgU2NydWJiZXIgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBET01FZGl0b3IsIEVESVRPUl9UT19VU0VSX01BUktTLCBFRElUT1JfVE9fUEVORElOR19ESUZGUywgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLCBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MsIHRhcmdldFJhbmdlLCB2ZXJpZnlEaWZmU3RhdGUsIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiwgSVNfQ09NUE9TSU5HLCBJU19OT0RFX01BUF9ESVJUWSwgYXBwbHlTdHJpbmdEaWZmLCBpc0RPTVNlbGVjdGlvbiwgaXNUcmFja2VkTXV0YXRpb24sIEVESVRPUl9UT19GT1JDRV9SRU5ERVIsIG5vcm1hbGl6ZVJhbmdlLCBub3JtYWxpemVQb2ludCwgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQsIG5vcm1hbGl6ZVN0cmluZ0RpZmYsIG1lcmdlU3RyaW5nRGlmZnMsIENBTl9VU0VfRE9NLCBJU19BTkRST0lELCBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0gsIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MLCBJU19JT1MsIFBMQUNFSE9MREVSX1NZTUJPTCwgSVNfV0VCS0lULCBpc1RleHREZWNvcmF0aW9uc0VxdWFsLCBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQsIE5PREVfVE9fRUxFTUVOVCwgRUxFTUVOVF9UT19OT0RFLCBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsLCBOT0RFX1RPX0lOREVYLCBOT0RFX1RPX1BBUkVOVCwgSVNfUkVBRF9PTkxZLCBnZXRBY3RpdmVFbGVtZW50LCBnZXRTZWxlY3Rpb24sIElTX0ZPQ1VTRUQsIGdldERlZmF1bHRWaWV3LCBFRElUT1JfVE9fV0lORE9XLCBFRElUT1JfVE9fRUxFTUVOVCwgSVNfRklSRUZPWCwgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLCBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQsIGlzRE9NRWxlbWVudCwgaXNET01Ob2RlLCBUUklQTEVfQ0xJQ0ssIElTX0ZJUkVGT1hfTEVHQUNZLCBJU19XRUNIQVRCUk9XU0VSLCBJU19VQ19NT0JJTEUsIEhvdGtleXMsIElTX0NIUk9NRSwgaXNQbGFpblRleHRPbmx5UGFzdGUsIEVESVRPUl9UT19PTl9DSEFOR0UsIHdpdGhET00gfSBmcm9tICdzbGF0ZS1kb20nO1xuZXhwb3J0IHsgTk9ERV9UT19JTkRFWCwgTk9ERV9UT19QQVJFTlQgfSBmcm9tICdzbGF0ZS1kb20nO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcic7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBlZGl0b3Igb2JqZWN0LlxuICovXG52YXIgRWRpdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxuICovXG52YXIgdXNlU2xhdGVTdGF0aWMgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTdGF0aWNgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFJlYWN0RWRpdG9yID0gRE9NRWRpdG9yO1xuXG5mdW5jdGlvbiBvd25LZXlzJDUoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2RyYWZ0LWpzL2Jsb2IvbWFpbi9zcmMvY29tcG9uZW50L2hhbmRsZXJzL2NvbXBvc2l0aW9uL0RyYWZ0RWRpdG9yQ29tcG9zaXRpb25IYW5kbGVyLmpzI0w0MVxuLy8gV2hlbiB1c2luZyBrZXlib2FyZCBFbmdsaXNoIGFzc29jaWF0aW9uIGZ1bmN0aW9uLCBjb25wb3NpdGlvbkVuZCB0cmlnZ2VyZWQgdG9vIGZhc3QsIHJlc3VsdGluZyBpbiBhZnRlciBgaW5zZXJ0VGV4dGAgc3RpbGwgbWFpbnRhaW4gYXNzb2NpYXRpb24gc3RhdGUuXG52YXIgUkVTT0xWRV9ERUxBWSA9IDI1O1xuLy8gVGltZSB3aXRoIG5vIHVzZXIgaW50ZXJhY3Rpb24gYmVmb3JlIHRoZSBjdXJyZW50IHVzZXIgYWN0aW9uIGlzIGNvbnNpZGVyZWQgYXMgZG9uZS5cbnZhciBGTFVTSF9ERUxBWSA9IDIwMDtcbi8vIFJlcGxhY2Ugd2l0aCBgY29uc3QgZGVidWcgPSBjb25zb2xlLmxvZ2AgdG8gZGVidWdcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG4vLyBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSBEYXRhVHJhbnNmZXJcbnZhciBpc0RhdGFUcmFuc2ZlciA9IHZhbHVlID0+ICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuY29uc3RydWN0b3IubmFtZSkgPT09ICdEYXRhVHJhbnNmZXInO1xuZnVuY3Rpb24gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfcmVmKSB7XG4gIHZhciB7XG4gICAgZWRpdG9yLFxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UsXG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2VcbiAgfSA9IF9yZWY7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgYWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIHZhciBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgdmFyIGFwcGx5UGVuZGluZ1NlbGVjdGlvbiA9ICgpID0+IHtcbiAgICB2YXIgcGVuZGluZ1NlbGVjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCBwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICAgIGlmIChub3JtYWxpemVkICYmICghc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMobm9ybWFsaXplZCwgc2VsZWN0aW9uKSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBwZXJmb3JtQWN0aW9uID0gKCkgPT4ge1xuICAgIHZhciBhY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhY3Rpb24uYXQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBQb2ludC5pc1BvaW50KGFjdGlvbi5hdCkgPyBub3JtYWxpemVQb2ludChlZGl0b3IsIGFjdGlvbi5hdCkgOiBub3JtYWxpemVSYW5nZShlZGl0b3IsIGFjdGlvbi5hdCk7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgX3RhcmdldFJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIF90YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBhY3Rpb24ucnVuKCk7XG4gIH07XG4gIHZhciBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChhY3Rpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChhY3Rpb25UaW1lb3V0SWQpO1xuICAgICAgYWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFoYXNQZW5kaW5nRGlmZnMoKSAmJiAhaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBhcHBseVBlbmRpbmdTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBmbHVzaGluZyA9IGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgZmx1c2hpbmcgPSAnYWN0aW9uJztcbiAgICB9XG4gICAgdmFyIHNlbGVjdGlvblJlZiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgIH0pO1xuICAgIEVESVRPUl9UT19VU0VSX01BUktTLnNldChlZGl0b3IsIGVkaXRvci5tYXJrcyk7XG4gICAgZGVidWcoJ2ZsdXNoJywgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpLCBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSk7XG4gICAgdmFyIHNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlID0gaGFzUGVuZGluZ0RpZmZzKCk7XG4gICAgdmFyIGRpZmY7XG4gICAgd2hpbGUgKGRpZmYgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QRU5ESU5HX0RJWzBdKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJLCBfRURJVE9SX1RPX1BFTkRJTkdfREkyO1xuICAgICAgdmFyIHBlbmRpbmdNYXJrcyA9IEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICAgIGlmIChwZW5kaW5nTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IHBlbmRpbmdNYXJrcztcbiAgICAgIH1cbiAgICAgIGlmIChwZW5kaW5nTWFya3MgJiYgaW5zZXJ0UG9zaXRpb25IaW50ID09PSBmYWxzZSkge1xuICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlID0gdGFyZ2V0UmFuZ2UoZGlmZik7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCByYW5nZSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlmZi5kaWZmLnRleHQpIHtcbiAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkaWZmLmRpZmYudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBkaWZmIG9ubHkgYWZ0ZXIgd2UgaGF2ZSBhcHBsaWVkIGl0IHRvIGFjY291bnQgZm9yIGl0IHdoZW4gdHJhbnNmb3JtaW5nXG4gICAgICAvLyBwZW5kaW5nIHJhbmdlcy5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlZGl0b3IsIChfRURJVE9SX1RPX1BFTkRJTkdfREkyID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fUEVORElOR19ESTIuZmlsdGVyKF9yZWYyID0+IHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZCAhPT0gZGlmZi5pZDtcbiAgICAgIH0pKTtcbiAgICAgIGlmICghdmVyaWZ5RGlmZlN0YXRlKGVkaXRvciwgZGlmZikpIHtcbiAgICAgICAgc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgZmx1c2hpbmcgPSAnYWN0aW9uJztcbiAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IHJlc3RvcmUgdGhlIHBlbmRpbmcgdXNlciAoZG9tKSBzZWxlY3Rpb25cbiAgICAgICAgLy8gc2luY2UgdGhlIGRvY3VtZW50IGFuZCBkb20gc3RhdGUgZG8gbm90IG1hdGNoLlxuICAgICAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICBzZWxlY3Rpb25SZWYgPT09IG51bGwgfHwgc2VsZWN0aW9uUmVmID09PSB2b2lkIDAgfHwgc2VsZWN0aW9uUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25SZWYgPT09IG51bGwgfHwgc2VsZWN0aW9uUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3Rpb25SZWYudW5yZWYoKTtcbiAgICBpZiAoc2VsZWN0aW9uICYmICFFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGVkaXRvcikgJiYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCBlZGl0b3Iuc2VsZWN0aW9uKSkpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcGVyZm9ybUFjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IFRoZSBzZWxlY3Rpb25DaGFuZ2UgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGFjdGlvbiBpcyBwZXJmb3JtZWQsXG4gICAgLy8gc28gd2UgaGF2ZSB0byBtYW51YWxseSBzY2hlZHVsZSBpdCB0byBlbnN1cmUgd2UgZG9uJ3QgJ3Rocm93IGF3YXknIHRoZSBzZWxlY3Rpb25cbiAgICAvLyB3aGlsZSByZW5kZXJpbmcgaWYgd2UgaGF2ZSBwZW5kaW5nIGNoYW5nZXMuXG4gICAgaWYgKHNjaGVkdWxlU2VsZWN0aW9uQ2hhbmdlKSB7XG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgIGFwcGx5UGVuZGluZ1NlbGVjdGlvbigpO1xuICAgIHZhciB1c2VyTWFya3MgPSBFRElUT1JfVE9fVVNFUl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICBpZiAodXNlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkaXRvci5tYXJrcyA9IHVzZXJNYXJrcztcbiAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uRW5kID0gX2V2ZW50ID0+IHtcbiAgICBpZiAoY29tcG9zaXRpb25FbmRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgZmx1c2goKTtcbiAgICB9LCBSRVNPTFZFX0RFTEFZKTtcbiAgfTtcbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQgPSBfZXZlbnQgPT4ge1xuICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBpZiAoY29tcG9zaXRpb25FbmRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCk7XG4gICAgICBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuICB2YXIgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5ID0gZnVuY3Rpb24gdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCkge1xuICAgIHZhciBmb3JjZUhpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBwbGFjZWhvbGRlckVsZW1lbnQgPSBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZ0RpZmZzKCkgfHwgZm9yY2VIaWRlKSB7XG4gICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGxhY2Vob2xkZXJFbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdkaXNwbGF5Jyk7XG4gIH07XG4gIHZhciBzdG9yZURpZmYgPSAocGF0aCwgZGlmZikgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkzO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJMyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkzICE9PSB2b2lkIDAgPyBfRURJVE9SX1RPX1BFTkRJTkdfREkzIDogW107XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgcGVuZGluZ0RpZmZzKTtcbiAgICB2YXIgdGFyZ2V0ID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgdmFyIGlkeCA9IHBlbmRpbmdEaWZmcy5maW5kSW5kZXgoY2hhbmdlID0+IFBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKSk7XG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXQudGV4dCwgZGlmZik7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBwZW5kaW5nRGlmZnMucHVzaCh7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBkaWZmLFxuICAgICAgICAgIGlkOiBpZENvdW50ZXIrK1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2VTdHJpbmdEaWZmcyh0YXJnZXQudGV4dCwgcGVuZGluZ0RpZmZzW2lkeF0uZGlmZiwgZGlmZik7XG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIHBlbmRpbmdEaWZmcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nRGlmZnNbaWR4XSA9IF9vYmplY3RTcHJlYWQkNShfb2JqZWN0U3ByZWFkJDUoe30sIHBlbmRpbmdEaWZmc1tpZHhdKSwge30sIHtcbiAgICAgIGRpZmY6IG1lcmdlZFxuICAgIH0pO1xuICB9O1xuICB2YXIgc2NoZWR1bGVBY3Rpb24gPSBmdW5jdGlvbiBzY2hlZHVsZUFjdGlvbihydW4pIHtcbiAgICB2YXIge1xuICAgICAgYXRcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaCgpO1xuICAgIH1cbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBydW5cbiAgICB9KTtcbiAgICAvLyBDT01QQVQ6IFdoZW4gZGVsZXRpbmcgYmVmb3JlIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IGNocm9tZSBvbmx5IGZpcmVzIGEgYmVmb3JlaW5wdXQsXG4gICAgLy8gKG5vIGlucHV0KSBhbmQgZG9lc24ndCBwZXJmb3JtIGFueSBkb20gbXV0YXRpb25zLiBXaXRob3V0IGEgZmx1c2ggdGltZW91dCB3ZSB3b3VsZCBuZXZlciBmbHVzaFxuICAgIC8vIGluIHRoaXMgY2FzZSBhbmQgdGh1cyBuZXZlciBhY3R1YWxseSBwZXJmb3JtIHRoZSBhY3Rpb24uXG4gICAgYWN0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCk7XG4gIH07XG4gIHZhciBoYW5kbGVET01CZWZvcmVJbnB1dCA9IGV2ZW50ID0+IHtcbiAgICB2YXIgX3RhcmdldFJhbmdlMjtcbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChJU19OT0RFX01BUF9ESVJUWS5nZXQoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgaW5wdXRUeXBlOiB0eXBlXG4gICAgfSA9IGV2ZW50O1xuICAgIHZhciB0YXJnZXRSYW5nZSA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7XG4gICAgaWYgKGluc2VydFBvc2l0aW9uSGludCAhPT0gZmFsc2UgJiYgdHlwZSAhPT0gJ2luc2VydFRleHQnICYmIHR5cGUgIT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnKSB7XG4gICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIFtuYXRpdmVUYXJnZXRSYW5nZV0gPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcbiAgICBpZiAobmF0aXZlVGFyZ2V0UmFuZ2UpIHtcbiAgICAgIHRhcmdldFJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgbmF0aXZlVGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IFNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCwgc28gd2VcbiAgICAvLyBoYXZlIHRvIG1hbnVhbGx5IGdldCB0aGUgc2VsZWN0aW9uIGhlcmUgdG8gZW5zdXJlIGl0J3MgdXAtdG8tZGF0ZS5cbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXRhcmdldFJhbmdlICYmIGRvbVNlbGVjdGlvbikge1xuICAgICAgbmF0aXZlVGFyZ2V0UmFuZ2UgPSBkb21TZWxlY3Rpb247XG4gICAgICB0YXJnZXRSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRhcmdldFJhbmdlID0gKF90YXJnZXRSYW5nZTIgPSB0YXJnZXRSYW5nZSkgIT09IG51bGwgJiYgX3RhcmdldFJhbmdlMiAhPT0gdm9pZCAwID8gX3RhcmdldFJhbmdlMiA6IGVkaXRvci5zZWxlY3Rpb247XG4gICAgaWYgKCF0YXJnZXRSYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBCeSBkZWZhdWx0LCB0aGUgaW5wdXQgbWFuYWdlciB0cmllcyB0byBzdG9yZSB0ZXh0IGRpZmZzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gZGVmZXIgZmx1c2hpbmcgdGhlbSBhdCBhIGxhdGVyIHBvaW50IGluIHRpbWUuIFdlIGRvbid0IHdhbnQgdG8gZmx1c2hcbiAgICAvLyBmb3IgZXZlcnkgaW5wdXQgZXZlbnQgYXMgdGhpcyBjYW4gYmUgZXhwZW5zaXZlLiBIb3dldmVyLCB0aGVyZSBhcmUgc29tZVxuICAgIC8vIHNjZW5hcmlvcyB3aGVyZSB3ZSBjYW5ub3Qgc2FmZWx5IHN0b3JlIHRoZSB0ZXh0IGRpZmYgYW5kIG11c3QgaW5zdGVhZFxuICAgIC8vIHNjaGVkdWxlIGFuIGFjdGlvbiB0byBsZXQgU2xhdGUgbm9ybWFsaXplIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgdmFyIGNhblN0b3JlRGlmZiA9IHRydWU7XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykpIHtcbiAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICB2YXIgW19zdGFydCwgX2VuZF0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIF9zdGFydC5wYXRoKTtcbiAgICAgICAgaWYgKF9sZWFmLnRleHQubGVuZ3RoID09PSBfc3RhcnQub2Zmc2V0ICYmIF9lbmQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBfc3RhcnQucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0JDEuaXNUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG5leHQgJiYgUGF0aC5lcXVhbHMobmV4dFsxXSwgX2VuZC5wYXRoKSkge1xuICAgICAgICAgICAgdGFyZ2V0UmFuZ2UgPSB7XG4gICAgICAgICAgICAgIGFuY2hvcjogX2VuZCxcbiAgICAgICAgICAgICAgZm9jdXM6IF9lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdHlwZS5lbmRzV2l0aCgnQmFja3dhcmQnKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXModGFyZ2V0UmFuZ2UpO1xuICAgICAgdmFyIFtsZWFmLCBwYXRoXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgc3RhcnQucGF0aCk7XG4gICAgICB2YXIgZGlmZiA9IHtcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIHN0YXJ0OiBzdGFydC5vZmZzZXQsXG4gICAgICAgIGVuZDogZW5kLm9mZnNldFxuICAgICAgfTtcbiAgICAgIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciByZWxldmFudFBlbmRpbmdEaWZmcyA9IHBlbmRpbmdEaWZmcyA9PT0gbnVsbCB8fCBwZW5kaW5nRGlmZnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdEaWZmcy5maW5kKGNoYW5nZSA9PiBQYXRoLmVxdWFscyhjaGFuZ2UucGF0aCwgcGF0aCkpO1xuICAgICAgdmFyIGRpZmZzID0gcmVsZXZhbnRQZW5kaW5nRGlmZnMgPyBbcmVsZXZhbnRQZW5kaW5nRGlmZnMuZGlmZiwgZGlmZl0gOiBbZGlmZl07XG4gICAgICB2YXIgdGV4dCA9IGFwcGx5U3RyaW5nRGlmZihsZWFmLnRleHQsIC4uLmRpZmZzKTtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUZXh0IGxlYWYgd2lsbCBiZSByZW1vdmVkLCBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuXG4gICAgICAgIC8vIGFjdGlvbiB0byByZW1vdmUgaXQgc28gdGhhdCBTbGF0ZSBjYW4gbm9ybWFsaXplIGluc3RlYWRcbiAgICAgICAgLy8gb2Ygc3RvcmluZyBhcyBhIGRpZmZcbiAgICAgICAgY2FuU3RvcmVEaWZmID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZCh0YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBQYXRoLmVxdWFscyh0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwgdGFyZ2V0UmFuZ2UuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiB0YXJnZXRSYW5nZS5hbmNob3IucGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQub2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb2ludCwgcG9pbnQpO1xuICAgICAgICAgIGhhbmRsZVVzZXJTZWxlY3QocmFuZ2UpO1xuICAgICAgICAgIHJldHVybiBzdG9yZURpZmYodGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgZW5kOiBlbmQub2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0Lm9mZnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgZGlyZWN0aW9uXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvclxuICAgICAgICAgIH0gPSB0YXJnZXRSYW5nZTtcbiAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBhbmNob3IucGF0aCk7XG4gICAgICAgICAgICBpZiAoYW5jaG9yLm9mZnNldCA8IHRhcmdldE5vZGUudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZihhbmNob3IucGF0aCwge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBhbmNob3Iub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogYW5jaG9yLm9mZnNldCArIDFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbmF0aXZlVGFyZ2V0UmFuZ2U7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvcjogX2FuY2hvclxuICAgICAgICAgIH0gPSB0YXJnZXRSYW5nZTtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgbmF0aXZlIGFuZCBzbGF0ZSBzZWxlY3Rpb24gYmVpbmcgY29sbGFwc2VkXG4gICAgICAgICAgLy8gd2UgYXJlIG1vc3QgbGlrZWx5IGRlbGV0aW5nIGEgemVyby13aWR0aCBwbGFjZWhvbGRlciBhbmQgdGh1cyBzaG91bGQgcGVyZm9ybSBpdFxuICAgICAgICAgIC8vIGFzIGFuIGFjdGlvbiB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvciAobW9zdGx5IGhhcHBlbnMgd2l0aCBtYXJrIHBsYWNlaG9sZGVycylcbiAgICAgICAgICB2YXIgbmF0aXZlQ29sbGFwc2VkID0gaXNET01TZWxlY3Rpb24obmF0aXZlVGFyZ2V0UmFuZ2UpID8gbmF0aXZlVGFyZ2V0UmFuZ2UuaXNDb2xsYXBzZWQgOiAhISgoX25hdGl2ZVRhcmdldFJhbmdlID0gbmF0aXZlVGFyZ2V0UmFuZ2UpICE9PSBudWxsICYmIF9uYXRpdmVUYXJnZXRSYW5nZSAhPT0gdm9pZCAwICYmIF9uYXRpdmVUYXJnZXRSYW5nZS5jb2xsYXBzZWQpO1xuICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgbmF0aXZlQ29sbGFwc2VkICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSAmJiBfYW5jaG9yLm9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZURpZmYoX2FuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICBzdGFydDogX2FuY2hvci5vZmZzZXQgLSAxLFxuICAgICAgICAgICAgICBlbmQ6IF9hbmNob3Iub2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlRW50aXJlU29mdExpbmUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRDb21wb3NpdGlvblRleHQnOlxuICAgICAgY2FzZSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgIGNhc2UgJ2luc2VydFRleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGlzRGF0YVRyYW5zZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpLCB7XG4gICAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfdGV4dCA9IGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6ICcnO1xuICAgICAgICAgIC8vIENPTVBBVDogSWYgd2UgYXJlIHdyaXRpbmcgaW5zaWRlIGEgcGxhY2Vob2xkZXIsIHRoZSBpbWUgaW5zZXJ0cyB0aGUgdGV4dCBpbnNpZGVcbiAgICAgICAgICAvLyB0aGUgcGxhY2Vob2xkZXIgaXRzZWxmIGFuZCB0aHVzIGluY2x1ZGVzIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIGluc2lkZSBlZGl0IGV2ZW50cy5cbiAgICAgICAgICBpZiAoRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBfdGV4dCA9IF90ZXh0LnJlcGxhY2UoJ1xcdUZFRkYnLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFBhc3RlcyBmcm9tIHRoZSBBbmRyb2lkIGNsaXBib2FyZCB3aWxsIGdlbmVyYXRlIGBpbnNlcnRUZXh0YCBldmVudHMuXG4gICAgICAgICAgLy8gSWYgdGhlIGNvcGllZCB0ZXh0IGNvbnRhaW5zIGFueSBuZXdsaW5lcywgQW5kcm9pZCB3aWxsIGFwcGVuZCBhblxuICAgICAgICAgIC8vIGV4dHJhIG5ld2xpbmUgdG8gdGhlIGVuZCBvZiB0aGUgY29waWVkIHRleHQuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0JyAmJiAvLipcXG4uKlxcbiQvLnRlc3QoX3RleHQpKSB7XG4gICAgICAgICAgICBfdGV4dCA9IF90ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgaW5jbHVkZXMgYSBuZXdsaW5lLCBzcGxpdCBpdCBhdCBuZXdsaW5lcyBhbmQgcGFzdGUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAvLyBzdHJpbmcsIHdpdGggc29mdCBicmVha3MgaW4gYmV0d2VlbiBlYWNoLlxuICAgICAgICAgIGlmIChfdGV4dC5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IF90ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgcGFydHMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyh0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwgdGFyZ2V0UmFuZ2UuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBbX3N0YXJ0MiwgX2VuZDJdID0gUmFuZ2UuZWRnZXModGFyZ2V0UmFuZ2UpO1xuICAgICAgICAgICAgdmFyIF9kaWZmID0ge1xuICAgICAgICAgICAgICBzdGFydDogX3N0YXJ0Mi5vZmZzZXQsXG4gICAgICAgICAgICAgIGVuZDogX2VuZDIub2Zmc2V0LFxuICAgICAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENPTVBBVDogU3dpZnRrZXkgaGFzIGEgd2VpcmQgYnVnIHdoZXJlIHRoZSB0YXJnZXQgcmFuZ2Ugb2YgdGhlIDJuZCB3b3JkXG4gICAgICAgICAgICAvLyBpbnNlcnRlZCBhZnRlciBhIG1hcmsgcGxhY2Vob2xkZXIgaXMgaW5zZXJ0ZWQgd2l0aCBhbiBhbmNob3Igb2Zmc2V0IG9mZiBieSAxLlxuICAgICAgICAgICAgLy8gU28gd3JpdGluZyAnc29tZSB0ZXh0JyB3aWxsIHJlc3VsdCBpbiAnc29tZSB0dGV4dCcuIEx1Y2tpbHkgYWxsICdub3JtYWwnIGluc2VydFxuICAgICAgICAgICAgLy8gdGV4dCBldmVudHMgYXJlIGZpcmVkIHdpdGggdGhlIGNvcnJlY3QgdGFyZ2V0IHJhbmdlcywgb25seSB0aGUgZmluYWwgJ2luc2VydENvbXBvc2l0aW9uJ1xuICAgICAgICAgICAgLy8gaXNuJ3QsIHNvIHdlIGNhbiBhZGp1c3QgdGhlIHRhcmdldCByYW5nZSBzdGFydCBvZmZzZXQgaWYgd2UgYXJlIGNvbmZpZGVudCB0aGlzIGlzIHRoZVxuICAgICAgICAgICAgLy8gc3dpZnRrZXkgaW5zZXJ0IGNhdXNpbmcgdGhlIGlzc3VlLlxuICAgICAgICAgICAgaWYgKF90ZXh0ICYmIGluc2VydFBvc2l0aW9uSGludCAmJiB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgICAgICAgICB2YXIgaGludFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuICAgICAgICAgICAgICB2YXIgZGlmZlBvc2l0aW9uID0gX2RpZmYuc3RhcnQgKyBfZGlmZi50ZXh0LnNlYXJjaCgvXFxTfCQvKTtcbiAgICAgICAgICAgICAgaWYgKGRpZmZQb3NpdGlvbiA9PT0gaGludFBvc2l0aW9uICsgMSAmJiBfZGlmZi5lbmQgPT09IGluc2VydFBvc2l0aW9uSGludC5zdGFydCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF9kaWZmLnN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnKSB7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfZGlmZjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIGluc2VydFBvc2l0aW9uSGludC5lbmQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGggPT09IF9zdGFydDIub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gX29iamVjdFNwcmVhZCQ1KF9vYmplY3RTcHJlYWQkNSh7fSwgaW5zZXJ0UG9zaXRpb25IaW50KSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGluc2VydFBvc2l0aW9uSGludC50ZXh0ICsgX3RleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmKSB7XG4gICAgICAgICAgICAgIHN0b3JlRGlmZihfc3RhcnQyLnBhdGgsIF9kaWZmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBfdGV4dCksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgaGFzUGVuZGluZ0FjdGlvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gISFFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvcik7XG4gIH07XG4gIHZhciBoYXNQZW5kaW5nRGlmZnMgPSAoKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTQ7XG4gICAgcmV0dXJuICEhKChfRURJVE9SX1RPX1BFTkRJTkdfREk0ID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREk0Lmxlbmd0aCk7XG4gIH07XG4gIHZhciBoYXNQZW5kaW5nQ2hhbmdlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gaGFzUGVuZGluZ0FjdGlvbigpIHx8IGhhc1BlbmRpbmdEaWZmcygpO1xuICB9O1xuICB2YXIgaXNGbHVzaGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZmx1c2hpbmc7XG4gIH07XG4gIHZhciBoYW5kbGVVc2VyU2VsZWN0ID0gcmFuZ2UgPT4ge1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZWRpdG9yLCByYW5nZSk7XG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoQ2hhbmdlZCA9ICFzZWxlY3Rpb24gfHwgIVBhdGguZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IucGF0aCwgcmFuZ2UuYW5jaG9yLnBhdGgpO1xuICAgIHZhciBwYXJlbnRQYXRoQ2hhbmdlZCA9ICFzZWxlY3Rpb24gfHwgIVBhdGguZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IucGF0aC5zbGljZSgwLCAtMSksIHJhbmdlLmFuY2hvci5wYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKHBhdGhDaGFuZ2VkICYmIGluc2VydFBvc2l0aW9uSGludCB8fCBwYXJlbnRQYXRoQ2hhbmdlZCkge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXRoQ2hhbmdlZCB8fCBoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoLCBGTFVTSF9ERUxBWSk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlSW5wdXQgPSAoKSA9PiB7XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSB8fCAhaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlS2V5RG93biA9IF8gPT4ge1xuICAgIC8vIENPTVBBVDogU3dpZnRrZXkgY2xvc2VzIHRoZSBrZXlib2FyZCB3aGVuIHR5cGluZyBpbnNpZGUgYSBlbXB0eSBub2RlXG4gICAgLy8gZGlyZWN0bHkgbmV4dCB0byBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCAoPSB0aGUgcGxhY2Vob2xkZXIpLlxuICAgIC8vIFRoZSBvbmx5IGV2ZW50IGZpcmVkIHNvb24gZW5vdWdoIGZvciB1cyB0byBhbGxvdyBoaWRpbmcgdGhlIHBsYWNlaG9sZGVyXG4gICAgLy8gd2l0aG91dCBzd2lmdGtleSBwaWNraW5nIGl0IHVwIGlzIHRoZSBrZXlkb3duIGV2ZW50LCBzbyB3ZSBoYXZlIHRvIGhpZGUgaXRcbiAgICAvLyBoZXJlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNDk4OCNpc3N1ZWNvbW1lbnQtMTIwMTA1MDUzNVxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSh0cnVlKTtcbiAgICAgIHNldFRpbWVvdXQodXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KTtcbiAgICB9XG4gIH07XG4gIHZhciBzY2hlZHVsZUZsdXNoID0gKCkgPT4ge1xuICAgIGlmICghaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYW5kbGVEb21NdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9ucy5zb21lKG11dGF0aW9uID0+IGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIG11dGF0aW9ucykpKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19GT1JDRV9SRU5EO1xuICAgICAgLy8gQ2F1c2UgYSByZS1yZW5kZXIgdG8gcmVzdG9yZSB0aGUgZG9tIHN0YXRlIGlmIHdlIGVuY291bnRlciB0cmFja2VkIG11dGF0aW9ucyB3aXRob3V0XG4gICAgICAvLyBhIGNvcnJlc3BvbmRpbmcgcGVuZGluZyBhY3Rpb24uXG4gICAgICAoX0VESVRPUl9UT19GT1JDRV9SRU5EID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19GT1JDRV9SRU5EID09PSB2b2lkIDAgfHwgX0VESVRPUl9UT19GT1JDRV9SRU5EKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGZsdXNoLFxuICAgIHNjaGVkdWxlRmx1c2gsXG4gICAgaGFzUGVuZGluZ0RpZmZzLFxuICAgIGhhc1BlbmRpbmdBY3Rpb24sXG4gICAgaGFzUGVuZGluZ0NoYW5nZXMsXG4gICAgaXNGbHVzaGluZyxcbiAgICBoYW5kbGVVc2VyU2VsZWN0LFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uRW5kLFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQsXG4gICAgaGFuZGxlRE9NQmVmb3JlSW5wdXQsXG4gICAgaGFuZGxlS2V5RG93bixcbiAgICBoYW5kbGVEb21NdXRhdGlvbnMsXG4gICAgaGFuZGxlSW5wdXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICB2YXIgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gaXNNb3VudGVkUmVmLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogUHJldmVudCB3YXJuaW5nIG9uIFNTUiBieSBmYWxsaW5nIGJhY2sgdG8gdXNlRWZmZWN0IHdoZW4gRE9NIGlzbid0IGF2YWlsYWJsZVxuICovXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBbbXV0YXRpb25PYnNlcnZlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBEaXNjYXJkIG11dGF0aW9ucyBjYXVzZWQgZHVyaW5nIHJlbmRlciBwaGFzZS4gVGhpcyB3b3JrcyBkdWUgdG8gcmVhY3QgY2FsbGluZ1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSByZW5kZXIgcGhhc2UgYmVmb3JlIHRoZSBuZXh0IHRpY2suXG4gICAgbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKG5vZGUuY3VycmVudCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbbXV0YXRpb25PYnNlcnZlciwgbm9kZSwgb3B0aW9uc10pO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJub2RlXCJdO1xuZnVuY3Rpb24gb3duS2V5cyQ0KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUckMSA9IHtcbiAgc3VidHJlZTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG59O1xudmFyIHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIgPSAhSVNfQU5EUk9JRCA/ICgpID0+IG51bGwgOiBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICAgIG5vZGVcbiAgICB9ID0gX3JlZixcbiAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQyKTtcbiAgaWYgKCFJU19BTkRST0lEKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgdmFyIFtpbnB1dE1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfb2JqZWN0U3ByZWFkJDQoe1xuICAgIGVkaXRvclxuICB9LCBvcHRpb25zKSkpO1xuICB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGlucHV0TWFuYWdlci5oYW5kbGVEb21NdXRhdGlvbnMsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxKTtcbiAgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILnNldChlZGl0b3IsIGlucHV0TWFuYWdlci5zY2hlZHVsZUZsdXNoKTtcbiAgaWYgKGlzTW91bnRlZCkge1xuICAgIGlucHV0TWFuYWdlci5mbHVzaCgpO1xuICB9XG4gIHJldHVybiBpbnB1dE1hbmFnZXI7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBMZWFmIGNvbnRlbnQgc3RyaW5ncy5cbiAqL1xudmFyIFN0cmluZyQxID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGlzTGFzdCxcbiAgICBsZWFmLFxuICAgIHBhcmVudCxcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGlzTWFya1BsYWNlaG9sZGVyID0gQm9vbGVhbihsZWFmW01BUktfUExBQ0VIT0xERVJfU1lNQk9MXSk7XG4gIC8vIENPTVBBVDogUmVuZGVyIHRleHQgaW5zaWRlIHZvaWQgbm9kZXMgd2l0aCBhIHplcm8td2lkdGggc3BhY2UuXG4gIC8vIFNvIHRoZSBub2RlIGNhbiBjb250YWluIHNlbGVjdGlvbiBidXQgdGhlIHRleHQgaXMgbm90IHZpc2libGUuXG4gIGlmIChlZGl0b3IuaXNWb2lkKHBhcmVudCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBsZW5ndGg6IE5vZGUuc3RyaW5nKHBhcmVudCkubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgLy8gQ09NUEFUOiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBhbiBlbXB0eSBibG9jaywgcmVuZGVyIGEgemVyby1cbiAgLy8gd2lkdGggc3BhY2UgdGhhdCB3aWxsIGNvbnZlcnQgaW50byBhIGxpbmUgYnJlYWsgd2hlbiBjb3B5aW5nIGFuZCBwYXN0aW5nXG4gIC8vIHRvIHN1cHBvcnQgZXhwZWN0ZWQgcGxhaW4gdGV4dC5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycgJiYgcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gdGV4dCAmJiAhZWRpdG9yLmlzSW5saW5lKHBhcmVudCkgJiYgRWRpdG9yLnN0cmluZyhlZGl0b3IsIHBhcmVudFBhdGgpID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTGluZUJyZWFrOiB0cnVlLFxuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH1cbiAgLy8gQ09NUEFUOiBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgaXQncyBiZWNhdXNlIGl0J3Mgb24gdGhlIGVkZ2Ugb2YgYW4gaW5saW5lXG4gIC8vIG5vZGUsIHNvIHdlIHJlbmRlciBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB0aGUgc2VsZWN0aW9uIGNhbiBiZVxuICAvLyBpbnNlcnRlZCBuZXh0IHRvIGl0IHN0aWxsLlxuICBpZiAobGVhZi50ZXh0ID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9XG4gIC8vIENPTVBBVDogQnJvd3NlcnMgd2lsbCBjb2xsYXBzZSB0cmFpbGluZyBuZXcgbGluZXMgYXQgdGhlIGVuZCBvZiBibG9ja3MsXG4gIC8vIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHRyYWlsaW5nIG5ldyBsaW5lcyB0byBwcmV2ZW50IHRoYXQuXG4gIGlmIChpc0xhc3QgJiYgbGVhZi50ZXh0LnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgICAgaXNUcmFpbGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxlYWYudGV4dFxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgdGV4dDogbGVhZi50ZXh0XG4gIH0pO1xufTtcbi8qKlxuICogTGVhZiBzdHJpbmdzIHdpdGggdGV4dCBpbiB0aGVtLlxuICovXG52YXIgVGV4dFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICB0ZXh0LFxuICAgIGlzVHJhaWxpbmcgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBnZXRUZXh0Q29udGVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpLmNvbmNhdChpc1RyYWlsaW5nID8gJ1xcbicgOiAnJyk7XG4gIH07XG4gIHZhciBbaW5pdGlhbFRleHRdID0gdXNlU3RhdGUoZ2V0VGV4dENvbnRlbnQpO1xuICAvLyBUaGlzIGlzIHRoZSBhY3R1YWwgdGV4dCByZW5kZXJpbmcgYm91bmRhcnkgd2hlcmUgd2UgaW50ZXJmYWNlIHdpdGggdGhlIERPTVxuICAvLyBUaGUgdGV4dCBpcyBub3QgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgdmlydHVhbCBET00sIGFzIHNpbmNlIHdlIGhhbmRsZSBiYXNpYyBjaGFyYWN0ZXIgaW5zZXJ0aW9ucyBuYXRpdmVseSxcbiAgLy8gdXBkYXRpbmcgdGhlIERPTSBpcyBub3QgYSBvbmUgd2F5IGRhdGFmbG93IGFueW1vcmUuIFdoYXQgd2UgbmVlZCBoZXJlIGlzIG5vdCByZWNvbmNpbGlhdGlvbiBhbmQgZGlmZmluZ1xuICAvLyB3aXRoIHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIHZpcnR1YWwgRE9NLCBidXQgcmF0aGVyIGRpZmZpbmcgd2l0aCB0aGUgYWN0dWFsIERPTSBlbGVtZW50LCBhbmQgcmVwbGFjZSB0aGUgRE9NIDxzcGFuPiBjb250ZW50XG4gIC8vIGV4YWN0bHkgaWYgYW5kIG9ubHkgaWYgaXRzIGN1cnJlbnQgY29udGVudCBkb2VzIG5vdCBtYXRjaCBvdXIgY3VycmVudCB2aXJ0dWFsIERPTS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBET00gVGV4dE5vZGUgd291bGQgYWx3YXlzIGJlIHJlcGxhY2VkIGJ5IFJlYWN0IGFzIHRoZSB1c2VyIHR5cGVzLCB3aGljaCBpbnRlcmZlcmVzIHdpdGggbmF0aXZlIHRleHQgZmVhdHVyZXMsXG4gIC8vIGVnIG1ha2VzIG5hdGl2ZSBzcGVsbGNoZWNrIG9wdCBvdXQgZnJvbSBjaGVja2luZyB0aGUgdGV4dCBub2RlLlxuICAvLyB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0aW5nIG91ciBzcGFuIGJlZm9yZSBicm93c2VyIHBhaW50XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIG51bGwgY29hbGVzY2luZyB0ZXh0IHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3Qgb3V0cHV0aW5nIFwibnVsbFwiIGFzIGEgc3RyaW5nIGluIHRoZSBleHRyZW1lIGNhc2UgaXQgaXMgbnVsbGlzaCBhdCBydW50aW1lXG4gICAgdmFyIHRleHRXaXRoVHJhaWxpbmcgPSBnZXRUZXh0Q29udGVudCgpO1xuICAgIGlmIChyZWYuY3VycmVudCAmJiByZWYuY3VycmVudC50ZXh0Q29udGVudCAhPT0gdGV4dFdpdGhUcmFpbGluZykge1xuICAgICAgcmVmLmN1cnJlbnQudGV4dENvbnRlbnQgPSB0ZXh0V2l0aFRyYWlsaW5nO1xuICAgIH1cbiAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCBzcGVjaWZ5aW5nIGRlcGVuZGVuY2llcywgc28gdGhhdCB0aGlzIGVmZmVjdCBydW5zIG9uIGV2ZXJ5IHJlbmRlclxuICAgIC8vIGFzIHRoaXMgZWZmZWN0aXZlbHkgcmVwbGFjZXMgXCJzcGVjaWZ5aW5nIHRoZSB0ZXh0IGluIHRoZSB2aXJ0dWFsIERPTSB1bmRlciB0aGUgPHNwYW4+IGJlbG93XCIgb24gZWFjaCByZW5kZXJcbiAgfSk7XG4gIC8vIFdlIGludGVudGlvbmFsbHkgcmVuZGVyIGEgbWVtb2l6ZWQgPHNwYW4+IHRoYXQgb25seSByZWNlaXZlcyB0aGUgaW5pdGlhbCB0ZXh0IGNvbnRlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gIC8vIFdlIGRlZmVyIHRvIHRoZSBsYXlvdXQgZWZmZWN0IGFib3ZlIHRvIHVwZGF0ZSB0aGUgYHRleHRDb250ZW50YCBvZiB0aGUgc3BhbiBlbGVtZW50IHdoZW4gbmVlZGVkLlxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0JDEsIHtcbiAgICByZWY6IHJlZlxuICB9LCBpbml0aWFsVGV4dCk7XG59O1xudmFyIE1lbW9pemVkVGV4dCQxID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiZGF0YS1zbGF0ZS1zdHJpbmdcIjogdHJ1ZSxcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcy5jaGlsZHJlbik7XG59KSk7XG4vKipcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXG4gKi9cbnZhciBaZXJvV2lkdGhTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVuZ3RoID0gMCxcbiAgICBpc0xpbmVCcmVhayA9IGZhbHNlLFxuICAgIGlzTWFya1BsYWNlaG9sZGVyID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJzogaXNMaW5lQnJlYWsgPyAnbicgOiAneicsXG4gICAgJ2RhdGEtc2xhdGUtbGVuZ3RoJzogbGVuZ3RoXG4gIH07XG4gIGlmIChpc01hcmtQbGFjZWhvbGRlcikge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlciddID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9vYmplY3RTcHJlYWQkMyh7fSwgYXR0cmlidXRlcyksICEoSVNfQU5EUk9JRCB8fCBJU19JT1MpIHx8ICFpc0xpbmVCcmVhayA/ICdcXHVGRUZGJyA6IG51bGwsIGlzTGluZUJyZWFrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSA6IG51bGwpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDIoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIERlbGF5IHRoZSBwbGFjZWhvbGRlciBvbiBBbmRyb2lkIHRvIHByZXZlbnQgdGhlIGtleWJvYXJkIGZyb20gY2xvc2luZy5cbi8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81MzY4KVxudmFyIFBMQUNFSE9MREVSX0RFTEFZID0gSVNfQU5EUk9JRCA/IDMwMCA6IDA7XG5mdW5jdGlvbiBkaXNjb25uZWN0UGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlcihwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLCByZWxlYXNlT2JzZXJ2ZXIpIHtcbiAgaWYgKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgaWYgKHJlbGVhc2VPYnNlcnZlcikge1xuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyVGltZW91dFJlZih0aW1lb3V0UmVmKSB7XG4gIGlmICh0aW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICB9XG59XG4vKipcbiAqIEluZGl2aWR1YWwgbGVhdmVzIGluIGEgdGV4dCBub2RlIHdpdGggdW5pcXVlIGZvcm1hdHRpbmcuXG4gKi9cbnZhciBMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlYWYsXG4gICAgaXNMYXN0LFxuICAgIHRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYgPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0TGVhZiwgX29iamVjdFNwcmVhZCQyKHt9LCBwcm9wcykpXG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyID0gdXNlUmVmKG51bGwpO1xuICB2YXIgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBbc2hvd1BsYWNlaG9sZGVyLCBzZXRTaG93UGxhY2Vob2xkZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB2YXIgc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGNhbGxiYWNrUGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjayhwbGFjZWhvbGRlckVsID0+IHtcbiAgICBkaXNjb25uZWN0UGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlcihwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLCBwbGFjZWhvbGRlckVsID09IG51bGwpO1xuICAgIGlmIChwbGFjZWhvbGRlckVsID09IG51bGwpIHtcbiAgICAgIHZhciBfbGVhZiRvblBsYWNlaG9sZGVyUmU7XG4gICAgICBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIChfbGVhZiRvblBsYWNlaG9sZGVyUmUgPSBsZWFmLm9uUGxhY2Vob2xkZXJSZXNpemUpID09PSBudWxsIHx8IF9sZWFmJG9uUGxhY2Vob2xkZXJSZSA9PT0gdm9pZCAwIHx8IF9sZWFmJG9uUGxhY2Vob2xkZXJSZS5jYWxsKGxlYWYsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5zZXQoZWRpdG9yLCBwbGFjZWhvbGRlckVsKTtcbiAgICAgIGlmICghcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50KSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYnNlcnZlciBhbmQgb2JzZXJ2ZSB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudC5cbiAgICAgICAgdmFyIFJlc2l6ZU9ic2VydmVyJDEgPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgUmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlciQxKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2xlYWYkb25QbGFjZWhvbGRlclJlMjtcbiAgICAgICAgICAoX2xlYWYkb25QbGFjZWhvbGRlclJlMiA9IGxlYWYub25QbGFjZWhvbGRlclJlc2l6ZSkgPT09IG51bGwgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlMiA9PT0gdm9pZCAwIHx8IF9sZWFmJG9uUGxhY2Vob2xkZXJSZTIuY2FsbChsZWFmLCBwbGFjZWhvbGRlckVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQub2JzZXJ2ZShwbGFjZWhvbGRlckVsKTtcbiAgICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSBwbGFjZWhvbGRlckVsO1xuICAgIH1cbiAgfSwgW3BsYWNlaG9sZGVyUmVmLCBsZWFmLCBlZGl0b3JdKTtcbiAgdmFyIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3RyaW5nJDEsIHtcbiAgICBpc0xhc3Q6IGlzTGFzdCxcbiAgICBsZWFmOiBsZWFmLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHRleHQ6IHRleHRcbiAgfSk7XG4gIHZhciBsZWFmSXNQbGFjZWhvbGRlciA9IEJvb2xlYW4obGVhZltQTEFDRUhPTERFUl9TWU1CT0xdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobGVhZklzUGxhY2Vob2xkZXIpIHtcbiAgICAgIGlmICghc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIERlbGF5IHRoZSBwbGFjZWhvbGRlciwgc28gaXQgd2lsbCBub3QgcmVuZGVyIGluIGEgc2VsZWN0aW9uXG4gICAgICAgIHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHNldFNob3dQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgICBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9LCBQTEFDRUhPTERFUl9ERUxBWSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dFJlZihzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmKTtcbiAgICAgIHNldFNob3dQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXRSZWYoc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZik7XG4gIH0sIFtsZWFmSXNQbGFjZWhvbGRlciwgc2V0U2hvd1BsYWNlaG9sZGVyXSk7XG4gIGlmIChsZWFmSXNQbGFjZWhvbGRlciAmJiBzaG93UGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXJQcm9wcyA9IHtcbiAgICAgIGNoaWxkcmVuOiBsZWFmLnBsYWNlaG9sZGVyLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAnZGF0YS1zbGF0ZS1wbGFjZWhvbGRlcic6IHRydWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICBvcGFjaXR5OiAnMC4zMzMnLFxuICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS91ZGVjb2RlL3BsYXRlL2lzc3Vlcy8yMzE1XG4gICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogSVNfV0VCS0lUID8gJ2luaGVyaXQnIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgICAgIHJlZjogY2FsbGJhY2tQbGFjZWhvbGRlclJlZlxuICAgICAgfVxuICAgIH07XG4gICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVuZGVyUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJQcm9wcyksIGNoaWxkcmVuKTtcbiAgfVxuICAvLyBDT01QQVQ6IEhhdmluZyB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVzIG9uIHRoZXNlIGxlYWYgZWxlbWVudHMgZW5zdXJlcyB0aGF0XG4gIC8vIGluIGNlcnRhaW4gbWlzYmVoYXZpbmcgYnJvd3NlcnMgdGhleSBhcmVuJ3Qgd2VpcmRseSBjbG9uZWQvZGVzdHJveWVkIGJ5XG4gIC8vIGNvbnRlbnRlZGl0YWJsZSBiZWhhdmlvcnMuICgyMDE5LzA1LzA4KVxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1sZWFmJzogdHJ1ZVxuICB9O1xuICByZXR1cm4gcmVuZGVyTGVhZih7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBsZWFmLFxuICAgIHRleHRcbiAgfSk7XG59O1xudmFyIE1lbW9pemVkTGVhZiA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKExlYWYsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgVGV4dCQxLmVxdWFscyhuZXh0LmxlYWYsIHByZXYubGVhZikgJiYgbmV4dC5sZWFmW1BMQUNFSE9MREVSX1NZTUJPTF0gPT09IHByZXYubGVhZltQTEFDRUhPTERFUl9TWU1CT0xdO1xufSk7XG52YXIgRGVmYXVsdExlYWYgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX29iamVjdFNwcmVhZCQyKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXG4gKiBUZXh0LlxuICovXG52YXIgVGV4dCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBpc0xhc3QsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgbGVhdmVzID0gVGV4dCQxLmRlY29yYXRpb25zKHRleHQsIGRlY29yYXRpb25zKTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxlYWYgPSBsZWF2ZXNbaV07XG4gICAgY2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRMZWFmLCB7XG4gICAgICBpc0xhc3Q6IGlzTGFzdCAmJiBpID09PSBsZWF2ZXMubGVuZ3RoIC0gMSxcbiAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LmlkLCBcIi1cIikuY29uY2F0KGkpLFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgbGVhZjogbGVhZixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWZcbiAgICB9KSk7XG4gIH1cbiAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICB2YXIgY2FsbGJhY2tSZWYgPSB1c2VDYWxsYmFjayhzcGFuID0+IHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKHNwYW4pIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgfHwgS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgc3Bhbik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KHRleHQsIHNwYW4pO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChzcGFuLCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCB8fCBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUodGV4dCk7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgRUxFTUVOVF9UT19OT0RFLmRlbGV0ZShyZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlZi5jdXJyZW50ID0gc3BhbjtcbiAgfSwgW3JlZiwgZWRpdG9yLCBrZXksIHRleHRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ0ZXh0XCIsXG4gICAgcmVmOiBjYWxsYmFja1JlZlxuICB9LCBjaGlsZHJlbik7XG59O1xudmFyIE1lbW9pemVkVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKFRleHQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbChuZXh0LmRlY29yYXRpb25zLCBwcmV2LmRlY29yYXRpb25zKTtcbn0pO1xuXG5mdW5jdGlvbiBvd25LZXlzJDEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBFbGVtZW50LlxuICovXG52YXIgRWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQgPSBwID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFbGVtZW50LCBfb2JqZWN0U3ByZWFkJDEoe30sIHApKSxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVhZE9ubHkgPSB1c2VSZWFkT25seSgpO1xuICB2YXIgaXNJbmxpbmUgPSBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCk7XG4gIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgZWxlbWVudCk7XG4gIHZhciByZWYgPSB1c2VDYWxsYmFjayhyZWYgPT4ge1xuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKHJlZikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCB8fCBLRVlfVE9fRUxFTUVOVC5zZXQoa2V5LCByZWYpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlbGVtZW50LCByZWYpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwIHx8IEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIGtleSwgZWxlbWVudF0pO1xuICB2YXIgY2hpbGRyZW4gPSB1c2VDaGlsZHJlbih7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0pO1xuICAvLyBBdHRyaWJ1dGVzIHRoYXQgdGhlIGRldmVsb3BlciBtdXN0IG1peCBpbnRvIHRoZSBlbGVtZW50IGluIHRoZWlyXG4gIC8vIGN1c3RvbSBub2RlIHJlbmRlcmVyIGNvbXBvbmVudC5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbm9kZSc6ICdlbGVtZW50JyxcbiAgICByZWZcbiAgfTtcbiAgaWYgKGlzSW5saW5lKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1pbmxpbmUnXSA9IHRydWU7XG4gIH1cbiAgLy8gSWYgaXQncyBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmUgY2hpbGRyZW4sIGFkZCB0aGUgcHJvcGVyIGBkaXJgIGF0dHJpYnV0ZVxuICAvLyBmb3IgdGV4dCBkaXJlY3Rpb24uXG4gIGlmICghaXNJbmxpbmUgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIHZhciB0ZXh0ID0gTm9kZS5zdHJpbmcoZWxlbWVudCk7XG4gICAgdmFyIGRpciA9IGdldERpcmVjdGlvbih0ZXh0KTtcbiAgICBpZiAoZGlyID09PSAncnRsJykge1xuICAgICAgYXR0cmlidXRlcy5kaXIgPSBkaXI7XG4gICAgfVxuICB9XG4gIC8vIElmIGl0J3MgYSB2b2lkIG5vZGUsIHdyYXAgdGhlIGNoaWxkcmVuIGluIGV4dHJhIHZvaWQtc3BlY2lmaWMgZWxlbWVudHMuXG4gIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgZWxlbWVudCkpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLXZvaWQnXSA9IHRydWU7XG4gICAgaWYgKCFyZWFkT25seSAmJiBpc0lubGluZSkge1xuICAgICAgYXR0cmlidXRlcy5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIFRhZyA9IGlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgdmFyIFtbX3RleHRdXSA9IE5vZGUudGV4dHMoZWxlbWVudCk7XG4gICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgIFwiZGF0YS1zbGF0ZS1zcGFjZXJcIjogdHJ1ZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogJzAnLFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgZGVjb3JhdGlvbnM6IFtdLFxuICAgICAgaXNMYXN0OiBmYWxzZSxcbiAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgIHRleHQ6IF90ZXh0XG4gICAgfSkpO1xuICAgIE5PREVfVE9fSU5ERVguc2V0KF90ZXh0LCAwKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQoX3RleHQsIGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiByZW5kZXJFbGVtZW50KHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSk7XG59O1xudmFyIE1lbW9pemVkRWxlbWVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKEVsZW1lbnQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBwcmV2LmVsZW1lbnQgPT09IG5leHQuZWxlbWVudCAmJiBwcmV2LnJlbmRlckVsZW1lbnQgPT09IG5leHQucmVuZGVyRWxlbWVudCAmJiBwcmV2LnJlbmRlckxlYWYgPT09IG5leHQucmVuZGVyTGVhZiAmJiBwcmV2LnJlbmRlclBsYWNlaG9sZGVyID09PSBuZXh0LnJlbmRlclBsYWNlaG9sZGVyICYmIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwocHJldi5kZWNvcmF0aW9ucywgbmV4dC5kZWNvcmF0aW9ucykgJiYgKHByZXYuc2VsZWN0aW9uID09PSBuZXh0LnNlbGVjdGlvbiB8fCAhIXByZXYuc2VsZWN0aW9uICYmICEhbmV4dC5zZWxlY3Rpb24gJiYgUmFuZ2UuZXF1YWxzKHByZXYuc2VsZWN0aW9uLCBuZXh0LnNlbGVjdGlvbikpO1xufSk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVsZW1lbnQgcmVuZGVyZXIuXG4gKi9cbnZhciBEZWZhdWx0RWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIFRhZyA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/ICdzcGFuJyA6ICdkaXYnO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBhdHRyaWJ1dGVzKSwge30sIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9XG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGRlY29yYXRlYCBwcm9wIG9mIHRoZSBlZGl0YWJsZS5cbiAqL1xudmFyIERlY29yYXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KCgpID0+IFtdKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGBkZWNvcmF0ZWAgcHJvcCBvZiB0aGUgZWRpdGFibGUuXG4gKi9cbnZhciB1c2VEZWNvcmF0ZSA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRGVjb3JhdGVDb250ZXh0KTtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG4gKi9cbnZhciBTZWxlY3RlZENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG4gKi9cbnZhciB1c2VTZWxlY3RlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoU2VsZWN0ZWRDb250ZXh0KTtcbn07XG5cbi8qKlxuICogQ2hpbGRyZW4uXG4gKi9cbnZhciB1c2VDaGlsZHJlbiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBub2RlLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSA9IHByb3BzO1xuICB2YXIgZGVjb3JhdGUgPSB1c2VEZWNvcmF0ZSgpO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgSVNfTk9ERV9NQVBfRElSVFkuc2V0KGVkaXRvciwgZmFsc2UpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgaXNMZWFmQmxvY2sgPSBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXRoLmNvbmNhdChpKTtcbiAgICB2YXIgbiA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBuKTtcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwKTtcbiAgICB2YXIgc2VsID0gc2VsZWN0aW9uICYmIFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgZHMgPSBkZWNvcmF0ZShbbiwgcF0pO1xuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIGQgPSBSYW5nZS5pbnRlcnNlY3Rpb24oZGVjLCByYW5nZSk7XG4gICAgICBpZiAoZCkge1xuICAgICAgICBkcy5wdXNoKGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChuKSkge1xuICAgICAgY2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0ZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIGtleTogXCJwcm92aWRlci1cIi5jb25jYXQoa2V5LmlkKSxcbiAgICAgICAgdmFsdWU6ICEhc2VsXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZEVsZW1lbnQsIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRzLFxuICAgICAgICBlbGVtZW50OiBuLFxuICAgICAgICBrZXk6IGtleS5pZCxcbiAgICAgICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICBzZWxlY3Rpb246IHNlbFxuICAgICAgfSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiBkcyxcbiAgICAgICAga2V5OiBrZXkuaWQsXG4gICAgICAgIGlzTGFzdDogaXNMZWFmQmxvY2sgJiYgaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICAgICAgdGV4dDogblxuICAgICAgfSkpO1xuICAgIH1cbiAgICBOT0RFX1RPX0lOREVYLnNldChuLCBpKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQobiwgbm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGByZWFkT25seWAgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIFJlYWRPbmx5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGByZWFkT25seWAgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIHVzZVJlYWRPbmx5ID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChSZWFkT25seUNvbnRleHQpO1xufTtcblxudmFyIFNsYXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxuICovXG52YXIgdXNlU2xhdGUgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cbiAgdmFyIHtcbiAgICBlZGl0b3JcbiAgfSA9IGNvbnRleHQ7XG4gIHJldHVybiBlZGl0b3I7XG59O1xudmFyIHVzZVNsYXRlV2l0aFYgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5mdW5jdGlvbiB1c2VUcmFja1VzZXJJbnB1dCgpIHtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWNlaXZlZFVzZXJJbnB1dCA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBhbmltYXRpb25GcmFtZUlkUmVmID0gdXNlUmVmKDApO1xuICB2YXIgb25Vc2VySW5wdXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCA9IHRydWU7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQpO1xuICAgIGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCA9IGZhbHNlO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQpLCBbXSk7XG4gIHJldHVybiB7XG4gICAgcmVjZWl2ZWRVc2VySW5wdXQsXG4gICAgb25Vc2VySW5wdXRcbiAgfTtcbn1cblxudmFyIGNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyID0gKGVkaXRvciwgcmVjZWl2ZWRVc2VySW5wdXQpID0+IHtcbiAgdmFyIGJ1ZmZlcmVkTXV0YXRpb25zID0gW107XG4gIHZhciBjbGVhciA9ICgpID0+IHtcbiAgICBidWZmZXJlZE11dGF0aW9ucyA9IFtdO1xuICB9O1xuICB2YXIgcmVnaXN0ZXJNdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmICghcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdHJhY2tlZE11dGF0aW9ucyA9IG11dGF0aW9ucy5maWx0ZXIobXV0YXRpb24gPT4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKSk7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMucHVzaCguLi50cmFja2VkTXV0YXRpb25zKTtcbiAgfTtcbiAgZnVuY3Rpb24gcmVzdG9yZURPTSgpIHtcbiAgICBpZiAoYnVmZmVyZWRNdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgYnVmZmVyZWRNdXRhdGlvbnMucmV2ZXJzZSgpLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXN0b3JlIHRoZSBET00gZm9yIGNoYXJhY3RlckRhdGEgbXV0YXRpb25zXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGludGVycnVwdHMgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtdXRhdGlvbi5yZW1vdmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi50YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIG11dGF0aW9uLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBtdXRhdGlvbi50YXJnZXQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBDbGVhciBidWZmZXJlZCBtdXRhdGlvbnMgdG8gZW5zdXJlIHdlIGRvbid0IHVuZG8gdGhlbSB0d2ljZVxuICAgICAgY2xlYXIoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWdpc3Rlck11dGF0aW9ucyxcbiAgICByZXN0b3JlRE9NLFxuICAgIGNsZWFyXG4gIH07XG59O1xuXG52YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIFdlIGhhdmUgdG8gdXNlIGEgY2xhc3MgY29tcG9uZW50IGhlcmUgc2luY2Ugd2UgcmVseSBvbiBgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVgIHdoaWNoIGhhcyBubyBGQyBlcXVpdmFsZW50XG4vLyB0byBydW4gY29kZSBzeW5jaHJvbm91c2x5IGltbWVkaWF0ZWx5IGJlZm9yZSByZWFjdCBjb21taXRzIHRoZSBjb21wb25lbnQgdXBkYXRlIHRvIHRoZSBET00uXG5jbGFzcyBSZXN0b3JlRE9NQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZXh0XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hbmFnZXJcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibXV0YXRpb25PYnNlcnZlclwiLCBudWxsKTtcbiAgfVxuICBvYnNlcnZlKCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmU7XG4gICAgdmFyIHtcbiAgICAgIG5vZGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZSA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlID09PSB2b2lkIDAgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlLm9ic2VydmUobm9kZS5jdXJyZW50LCBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcpO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciB7XG4gICAgICByZWNlaXZlZFVzZXJJbnB1dFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHZhciBlZGl0b3IgPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5tYW5hZ2VyID0gY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCk7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5tYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKTtcbiAgICB0aGlzLm9ic2VydmUoKTtcbiAgfVxuICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkbXV0YXRpb25PYnNlcnZlMiwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMywgX3RoaXMkbWFuYWdlcjI7XG4gICAgdmFyIHBlbmRpbmdNdXRhdGlvbnMgPSAoX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlMi50YWtlUmVjb3JkcygpO1xuICAgIGlmIChwZW5kaW5nTXV0YXRpb25zICE9PSBudWxsICYmIHBlbmRpbmdNdXRhdGlvbnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nTXV0YXRpb25zLmxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzJG1hbmFnZXI7XG4gICAgICAoX3RoaXMkbWFuYWdlciA9IHRoaXMubWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkbWFuYWdlciA9PT0gdm9pZCAwIHx8IF90aGlzJG1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMocGVuZGluZ011dGF0aW9ucyk7XG4gICAgfVxuICAgIChfdGhpcyRtdXRhdGlvbk9ic2VydmUzID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzID09PSB2b2lkIDAgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMy5kaXNjb25uZWN0KCk7XG4gICAgKF90aGlzJG1hbmFnZXIyID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyMiA9PT0gdm9pZCAwIHx8IF90aGlzJG1hbmFnZXIyLnJlc3RvcmVET00oKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG1hbmFnZXIzO1xuICAgIChfdGhpcyRtYW5hZ2VyMyA9IHRoaXMubWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkbWFuYWdlcjMgPT09IHZvaWQgMCB8fCBfdGhpcyRtYW5hZ2VyMy5jbGVhcigpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmU0O1xuICAgIChfdGhpcyRtdXRhdGlvbk9ic2VydmU0ID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmU0ID09PSB2b2lkIDAgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlNC5kaXNjb25uZWN0KCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoUmVzdG9yZURPTUNvbXBvbmVudCwgXCJjb250ZXh0VHlwZVwiLCBFZGl0b3JDb250ZXh0KTtcbnZhciBSZXN0b3JlRE9NID0gSVNfQU5EUk9JRCA/IFJlc3RvcmVET01Db21wb25lbnQgOiBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGNvbXBvc2luZ2Agc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIENvbXBvc2luZ0NvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBgY29tcG9zaW5nYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICovXG52YXIgdXNlQ29tcG9zaW5nID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChDb21wb3NpbmdDb250ZXh0KTtcbn07XG5cbnZhciBfZXhjbHVkZWQkMSA9IFtcImF1dG9Gb2N1c1wiLCBcImRlY29yYXRlXCIsIFwib25ET01CZWZvcmVJbnB1dFwiLCBcInBsYWNlaG9sZGVyXCIsIFwicmVhZE9ubHlcIiwgXCJyZW5kZXJFbGVtZW50XCIsIFwicmVuZGVyTGVhZlwiLCBcInJlbmRlclBsYWNlaG9sZGVyXCIsIFwic2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXdcIiwgXCJzdHlsZVwiLCBcImFzXCIsIFwiZGlzYWJsZURlZmF1bHRTdHlsZXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJ0ZXh0XCJdO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgQ2hpbGRyZW4gPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdXNlQ2hpbGRyZW4ocHJvcHMpKTtcbi8qKlxuICogRWRpdGFibGUuXG4gKi9cbnZhciBFZGl0YWJsZSA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIHZhciBkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIgPSB1c2VDYWxsYmFjayhwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0UGxhY2Vob2xkZXIsIF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSksIFtdKTtcbiAgdmFyIHtcbiAgICAgIGF1dG9Gb2N1cyxcbiAgICAgIGRlY29yYXRlID0gZGVmYXVsdERlY29yYXRlLFxuICAgICAgb25ET01CZWZvcmVJbnB1dDogcHJvcHNPbkRPTUJlZm9yZUlucHV0LFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICByZWFkT25seSA9IGZhbHNlLFxuICAgICAgcmVuZGVyRWxlbWVudCxcbiAgICAgIHJlbmRlckxlYWYsXG4gICAgICByZW5kZXJQbGFjZWhvbGRlciA9IGRlZmF1bHRSZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3LFxuICAgICAgc3R5bGU6IHVzZXJTdHlsZSA9IHt9LFxuICAgICAgYXM6IENvbXBvbmVudCA9ICdkaXYnLFxuICAgICAgZGlzYWJsZURlZmF1bHRTdHlsZXMgPSBmYWxzZVxuICAgIH0gPSBwcm9wcyxcbiAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkMSk7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuICAvLyBSZXJlbmRlciBlZGl0b3Igd2hlbiBjb21wb3NpdGlvbiBzdGF0dXMgY2hhbmdlZFxuICB2YXIgW2lzQ29tcG9zaW5nLCBzZXRJc0NvbXBvc2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBkZWZlcnJlZE9wZXJhdGlvbnMgPSB1c2VSZWYoW10pO1xuICB2YXIgW3BsYWNlaG9sZGVySGVpZ2h0LCBzZXRQbGFjZWhvbGRlckhlaWdodF0gPSB1c2VTdGF0ZSgpO1xuICB2YXIgcHJvY2Vzc2luZyA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciB7XG4gICAgb25Vc2VySW5wdXQsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXRcbiAgfSA9IHVzZVRyYWNrVXNlcklucHV0KCk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLnNldChlZGl0b3IsIGZvcmNlUmVuZGVyKTtcbiAgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlIG9uIGVhY2ggcmVuZGVyLlxuICBJU19SRUFEX09OTFkuc2V0KGVkaXRvciwgcmVhZE9ubHkpO1xuICAvLyBLZWVwIHRyYWNrIG9mIHNvbWUgc3RhdGUgZm9yIHRoZSBldmVudCBoYW5kbGVyIGxvZ2ljLlxuICB2YXIgc3RhdGUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNEcmFnZ2luZ0ludGVybmFsbHk6IGZhbHNlLFxuICAgIGlzVXBkYXRpbmdTZWxlY3Rpb246IGZhbHNlLFxuICAgIGxhdGVzdEVsZW1lbnQ6IG51bGwsXG4gICAgaGFzTWFya1BsYWNlaG9sZGVyOiBmYWxzZVxuICB9KSwgW10pO1xuICAvLyBUaGUgYXV0b0ZvY3VzIFRleHRhcmVhSFRNTEF0dHJpYnV0ZSBkb2Vzbid0IGRvIGFueXRoaW5nIG9uIGEgZGl2LCBzbyBpdFxuICAvLyBuZWVkcyB0byBiZSBtYW51YWxseSBmb2N1c2VkLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCAmJiBhdXRvRm9jdXMpIHtcbiAgICAgIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzXSk7XG4gIC8qKlxuICAgKiBUaGUgQW5kcm9pZElucHV0TWFuYWdlciBvYmplY3QgaGFzIGEgY3ljbGljYWwgZGVwZW5kZW5jeSBvbiBvbkRPTVNlbGVjdGlvbkNoYW5nZVxuICAgKlxuICAgKiBJdCBpcyBkZWZpbmVkIGFzIGEgcmVmZXJlbmNlIHRvIHNpbXBsaWZ5IGhvb2sgZGVwZW5kZW5jaWVzIGFuZCBjbGFyaWZ5IHRoYXRcbiAgICogaXQgbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICB2YXIgYW5kcm9pZElucHV0TWFuYWdlclJlZiA9IHVzZVJlZigpO1xuICAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgc2VsZWN0aW9uY2hhbmdlYCBldmVudCB0byBiZSBhYmxlIHRvIHVwZGF0ZSBhbnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBvblNlbGVjdGAgaXMgbGVha3lcbiAgLy8gYW5kIG5vbi1zdGFuZGFyZCBzbyBpdCBkb2Vzbid0IGZpcmUgdW50aWwgYWZ0ZXIgYSBzZWxlY3Rpb24gaGFzIGJlZW5cbiAgLy8gcmVsZWFzZWQuIFRoaXMgY2F1c2VzIGlzc3VlcyBpbiBzaXR1YXRpb25zIHdoZXJlIGFub3RoZXIgY2hhbmdlIGhhcHBlbnNcbiAgLy8gd2hpbGUgYSBzZWxlY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZC5cbiAgdmFyIG9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlTWVtbygoKSA9PiB0aHJvdHRsZSgoKSA9PiB7XG4gICAgaWYgKElTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcbiAgICBpZiAoIXByb2Nlc3NpbmcuY3VycmVudCAmJiBJU19XRUJLSVQgJiYgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHByb2Nlc3NpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICB2YXIgYWN0aXZlID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5kZW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgICBwcm9jZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXIgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQ7XG4gICAgaWYgKChJU19BTkRST0lEIHx8ICFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSAmJiAoIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gfHwgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpICYmICFzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSkge1xuICAgICAgdmFyIF9yb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgICB2YXIge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gX3Jvb3Q7XG4gICAgICB2YXIgX2VsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oX3Jvb3QpO1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IF9lbCkge1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgZm9jdXNOb2RlXG4gICAgICB9ID0gZG9tU2VsZWN0aW9uO1xuICAgICAgdmFyIGFuY2hvck5vZGVTZWxlY3RhYmxlID0gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBhbmNob3JOb2RlKSB8fCBSZWFjdEVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIGFuY2hvck5vZGUpO1xuICAgICAgdmFyIGZvY3VzTm9kZUluRWRpdG9yID0gUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZm9jdXNOb2RlKTtcbiAgICAgIGlmIChhbmNob3JOb2RlU2VsZWN0YWJsZSAmJiBmb2N1c05vZGVJbkVkaXRvcikge1xuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhc1BlbmRpbmdDaGFuZ2VzKCkpICYmICEoYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgfHwgYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERlc2VsZWN0IHRoZSBlZGl0b3IgaWYgdGhlIGRvbSBzZWxlY3Rpb24gaXMgbm90IHNlbGVjdGFibGUgaW4gcmVhZG9ubHkgbW9kZVxuICAgICAgaWYgKHJlYWRPbmx5ICYmICghYW5jaG9yTm9kZVNlbGVjdGFibGUgfHwgIWZvY3VzTm9kZUluRWRpdG9yKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCAxMDApLCBbZWRpdG9yLCByZWFkT25seSwgc3RhdGVdKTtcbiAgdmFyIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VNZW1vKCgpID0+IGRlYm91bmNlKG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCAwKSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCA9IHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIoe1xuICAgIG5vZGU6IHJlZixcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSLCBfYW5kcm9pZElucHV0TWFuYWdlclIyO1xuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgd2luZG93O1xuICAgIGlmIChyZWYuY3VycmVudCAmJiAod2luZG93ID0gZ2V0RGVmYXVsdFZpZXcocmVmLmN1cnJlbnQpKSkge1xuICAgICAgRURJVE9SX1RPX1dJTkRPVy5zZXQoZWRpdG9yLCB3aW5kb3cpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLmN1cnJlbnQsIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIGluIHN5bmMuXG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgIGlmICghZG9tU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSB8fCAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfYW5kcm9pZElucHV0TWFuYWdlclIgIT09IHZvaWQgMCAmJiBfYW5kcm9pZElucHV0TWFuYWdlclIuaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZXREb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uID0gZG9tU2VsZWN0aW9uLnR5cGUgIT09ICdOb25lJztcbiAgICAgIC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIHByb3Blcmx5IHVuc2V0LCB3ZSdyZSBkb25lLlxuICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgIWhhc0RvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBHZXQgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlXG4gICAgICB2YXIgZm9jdXNOb2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgIHZhciBhbmNob3JOb2RlO1xuICAgICAgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZXRpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81NDg2I2lzc3VlLTE4MjA3MjAyMjMpXG4gICAgICBpZiAoSVNfRklSRUZPWCAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgdmFyIGZpcnN0UmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgdmFyIGxhc3RSYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50IC0gMSk7XG4gICAgICAgIC8vIFJpZ2h0IHRvIGxlZnRcbiAgICAgICAgaWYgKGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICBhbmNob3JOb2RlID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgfVxuICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGRvbSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvclxuICAgICAgdmFyIGVkaXRvckVsZW1lbnQgPSBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IGZhbHNlO1xuICAgICAgaWYgKGVkaXRvckVsZW1lbnQuY29udGFpbnMoYW5jaG9yTm9kZSkgJiYgZWRpdG9yRWxlbWVudC5jb250YWlucyhmb2N1c05vZGUpKSB7XG4gICAgICAgIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIGluIHRoZSBlZGl0b3IgYW5kIHRoZSBlZGl0b3Igc2VsZWN0aW9uIGlzIGFscmVhZHkgY29ycmVjdCwgd2UncmUgZG9uZS5cbiAgICAgIGlmIChoYXNEb21TZWxlY3Rpb24gJiYgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgJiYgc2VsZWN0aW9uICYmICFmb3JjZUNoYW5nZSkge1xuICAgICAgICB2YXIgc2xhdGVSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IHRydWUsXG4gICAgICAgICAgLy8gZG9tU2VsZWN0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIFNsYXRlIHJhbmdlXG4gICAgICAgICAgLy8gKGUuZy4gd2hlbiBjbGlja2luZyBvbiBjb250ZW50RWRpdGFibGU6ZmFsc2UgZWxlbWVudClcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2xhdGVSYW5nZSAmJiBSYW5nZS5lcXVhbHMoc2xhdGVSYW5nZSwgc2VsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBfYW5jaG9yTm9kZTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmhhc01hcmtQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbnN1cmUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlclxuICAgICAgICAgIGlmICgoX2FuY2hvck5vZGUgPSBhbmNob3JOb2RlKSAhPT0gbnVsbCAmJiBfYW5jaG9yTm9kZSAhPT0gdm9pZCAwICYmIChfYW5jaG9yTm9kZSA9IF9hbmNob3JOb2RlLnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hbmNob3JOb2RlICE9PSB2b2lkIDAgJiYgX2FuY2hvck5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gd2hlbiA8RWRpdGFibGUvPiBpcyBiZWluZyBjb250cm9sbGVkIHRocm91Z2ggZXh0ZXJuYWwgdmFsdWVcbiAgICAgIC8vIHRoZW4gaXRzIGNoaWxkcmVuIG1pZ2h0IGp1c3QgY2hhbmdlIC0gRE9NIHJlc3BvbmRzIHRvIGl0IG9uIGl0cyBvd25cbiAgICAgIC8vIGJ1dCBTbGF0ZSdzIHZhbHVlIGlzIG5vdCBiZWluZyB1cGRhdGVkIHRocm91Z2ggYW55IG9wZXJhdGlvblxuICAgICAgLy8gYW5kIHRodXMgaXQgZG9lc24ndCB0cmFuc2Zvcm0gc2VsZWN0aW9uIG9uIGl0cyBvd25cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgIVJlYWN0RWRpdG9yLmhhc1JhbmdlKGVkaXRvciwgc2VsZWN0aW9uKSkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dCBvZiBzeW5jLCBzbyB1cGRhdGUgaXQuXG4gICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBuZXdEb21SYW5nZSA9IHNlbGVjdGlvbiAmJiBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChuZXdEb21SYW5nZSkge1xuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiAhSVNfQU5EUk9JRCkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5jb2xsYXBzZVRvRW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQsIG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIG5ld0RvbVJhbmdlLnN0YXJ0T2Zmc2V0LCBuZXdEb21SYW5nZS5lbmRDb250YWluZXIsIG5ld0RvbVJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcoZWRpdG9yLCBuZXdEb21SYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RG9tUmFuZ2U7XG4gICAgfTtcbiAgICAvLyBJbiBmaXJlZm94IGlmIHRoZXJlIGlzIG1vcmUgdGhlbiAxIHJhbmdlIGFuZCB3ZSBjYWxsIHNldERvbVNlbGVjdGlvbiB3ZSByZW1vdmUgdGhlIGFiaWxpdHkgdG8gc2VsZWN0IG1vcmUgY2VsbHMgaW4gYSB0YWJsZVxuICAgIGlmIChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA8PSAxKSB7XG4gICAgICBzZXREb21TZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgdmFyIGVuc3VyZVNlbGVjdGlvbiA9ICgoX2FuZHJvaWRJbnB1dE1hbmFnZXJSMiA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FuZHJvaWRJbnB1dE1hbmFnZXJSMi5pc0ZsdXNoaW5nKCkpID09PSAnYWN0aW9uJztcbiAgICBpZiAoIUlTX0FORFJPSUQgfHwgIWVuc3VyZVNlbGVjdGlvbikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dElkID0gbnVsbDtcbiAgICB2YXIgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnN1cmVEb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgICAgc2V0RG9tU2VsZWN0aW9uKGZvcmNlQ2hhbmdlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUsIGRvbSBhbmQgc3RhdGUgbWlnaHQgYmUgb3V0IG9mIHN5bmNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbXBhdDogQW5kcm9pZCBJTUVzIHRyeSB0byBmb3JjZSB0aGVpciBzZWxlY3Rpb24gYnkgbWFudWFsbHkgcmUtYXBwbHlpbmcgaXQgZXZlbiBhZnRlciB3ZSBzZXQgaXQuXG4gICAgICAgIC8vIFRoaXMgZXNzZW50aWFsbHkgd291bGQgbWFrZSBzZXR0aW5nIHRoZSBzbGF0ZSBzZWxlY3Rpb24gZHVyaW5nIGFuIHVwZGF0ZSBtZWFuaW5nbGVzcywgc28gd2UgZm9yY2UgaXRcbiAgICAgICAgLy8gYWdhaW4gaGVyZS4gV2UgY2FuJ3Qgb25seSBkbyBpdCBpbiB0aGUgc2V0VGltZW91dCBhZnRlciB0aGUgYW5pbWF0aW9uIGZyYW1lIHNpbmNlIHRoYXQgd291bGQgY2F1c2UgYVxuICAgICAgICAvLyB2aXNpYmxlIGZsaWNrZXIuXG4gICAgICAgIGVuc3VyZURvbVNlbGVjdGlvbigpO1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBpbiBhbiBhbmltYXRpb24gZnJhbWUgdmlzdWFsbHkgY29ycmVjdGx5IHNldHMgdGhlIHNlbGVjdGlvbixcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHVwZGF0ZSBHQm9hcmRzIHNwZWxsY2hlY2tlciBzdGF0ZS4gV2UgaGF2ZSB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VsZWN0aW9uIGNoYW5nZSBhZnRlclxuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gZnJhbWUgdG8gZW5zdXJlIGl0IGRpc3BsYXlzIHRoZSBjb3JyZWN0IHN0YXRlLlxuICAgICAgICAgIGVuc3VyZURvbVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcbiAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBiZWZvcmVpbnB1dGAgZXZlbnQgdG8gZ2V0IHJlYWwgXCJMZXZlbCAyXCIgZXZlbnRzLiBUaGlzXG4gIC8vIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgYmVmb3JlaW5wdXRgIGlzIGZha2UgYW5kIG5ldmVyIHJlYWxseSBhdHRhY2hlc1xuICAvLyB0byB0aGUgcmVhbCBldmVudCBzYWRseS4gKDIwMTkvMTEvMDEpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTEyMTFcbiAgdmFyIG9uRE9NQmVmb3JlSW5wdXQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgaWYgKHByb2Nlc3NpbmcgIT09IG51bGwgJiYgcHJvY2Vzc2luZyAhPT0gdm9pZCAwICYmIHByb2Nlc3NpbmcuY3VycmVudCAmJiBJU19XRUJLSVQgJiYgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHZhciByYW5nZXMgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcbiAgICAgIHZhciByYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgIHZhciBuZXdSYW5nZSA9IG5ldyB3aW5kb3cuUmFuZ2UoKTtcbiAgICAgIG5ld1JhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICBuZXdSYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgLy8gVHJhbnNsYXRlIHRoZSBET00gUmFuZ2UgaW50byBhIFNsYXRlIFJhbmdlXG4gICAgICB2YXIgc2xhdGVSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIG5ld1JhbmdlLCB7XG4gICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNsYXRlUmFuZ2UpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvblVzZXJJbnB1dCgpO1xuICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0RPTUV2ZW50SGFuZGxlZChldmVudCwgcHJvcHNPbkRPTUJlZm9yZUlucHV0KSkge1xuICAgICAgdmFyIF9FRElUT1JfVE9fVVNFUl9TRUxFQztcbiAgICAgIC8vIENPTVBBVDogQmVmb3JlSW5wdXQgZXZlbnRzIGFyZW4ndCBjYW5jZWxhYmxlIG9uIGFuZHJvaWQsIHNvIHdlIGhhdmUgdG8gaGFuZGxlIHRoZW0gZGlmZmVyZW50bHkgdXNpbmcgdGhlIGFuZHJvaWQgaW5wdXQgbWFuYWdlci5cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudC5oYW5kbGVET01CZWZvcmVJbnB1dChldmVudCk7XG4gICAgICB9XG4gICAgICAvLyBTb21lIElNRXMvQ2hyb21lIGV4dGVuc2lvbnMgbGlrZSBlLmcuIEdyYW1tYXJseSBzZXQgdGhlIHNlbGVjdGlvbiBpbW1lZGlhdGVseSBiZWZvcmVcbiAgICAgIC8vIHRyaWdnZXJpbmcgYSBgYmVmb3JlaW5wdXRgIGV4cGVjdGluZyB0aGUgY2hhbmdlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgICAgLy8gc2V0IHNlbGVjdGlvbi5cbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICB2YXIge1xuICAgICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyIHx8IGV2ZW50LmRhdGEgfHwgdW5kZWZpbmVkO1xuICAgICAgdmFyIGlzQ29tcG9zaXRpb25DaGFuZ2UgPSB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JyB8fCB0eXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JztcbiAgICAgIC8vIENPTVBBVDogdXNlIGNvbXBvc2l0aW9uIGNoYW5nZSBldmVudHMgYXMgYSBoaW50IHRvIHdoZXJlIHdlIHNob3VsZCBpbnNlcnRcbiAgICAgIC8vIGNvbXBvc2l0aW9uIHRleHQgaWYgd2UgYXJlbid0IGNvbXBvc2luZyB0byB3b3JrIGFyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvaXNzdWVzLzUwMzhcbiAgICAgIGlmIChpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0JyAmJiBzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJlxuICAgICAgLy8gT25seSB1c2UgbmF0aXZlIGNoYXJhY3RlciBpbnNlcnRpb24gZm9yIHNpbmdsZSBjaGFyYWN0ZXJzIGEteiBvciBzcGFjZSBmb3Igbm93LlxuICAgICAgLy8gTG9uZy1wcmVzcyBldmVudHMgKGhvbGQgYSArIHByZXNzIDQgPSDDpCkgdG8gY2hvb3NlIGEgc3BlY2lhbCBjaGFyYWN0ZXIgb3RoZXJ3aXNlXG4gICAgICAvLyBjYXVzZXMgZHVwbGljYXRlIGluc2VydHMuXG4gICAgICBldmVudC5kYXRhICYmIGV2ZW50LmRhdGEubGVuZ3RoID09PSAxICYmIC9bYS16IF0vaS50ZXN0KGV2ZW50LmRhdGEpICYmXG4gICAgICAvLyBDaHJvbWUgaGFzIGlzc3VlcyBjb3JyZWN0bHkgZWRpdGluZyB0aGUgc3RhcnQgb2Ygbm9kZXM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNDk0MDVcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYW4gaW5saW5lIGVsZW1lbnQsIGUuZy4gYSBsaW5rLCBhbmQgeW91IHNlbGVjdFxuICAgICAgLy8gcmlnaHQgYWZ0ZXIgaXQgKHRoZSBzdGFydCBvZiB0aGUgbmV4dCBub2RlKS5cbiAgICAgIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIG5hdGl2ZSA9IHRydWU7XG4gICAgICAgIC8vIFNraXAgbmF0aXZlIGlmIHRoZXJlIGFyZSBtYXJrcywgYXNcbiAgICAgICAgLy8gYGluc2VydFRleHRgIHdpbGwgaW5zZXJ0IGEgbm9kZSwgbm90IGp1c3QgdGV4dC5cbiAgICAgICAgaWYgKGVkaXRvci5tYXJrcykge1xuICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBOT0RFX01BUCBpcyBkaXJ0eSwgd2UgY2FuJ3QgdHJ1c3QgdGhlIHNlbGVjdGlvbiBhbmNob3IgKGVnIFJlYWN0RWRpdG9yLnRvRE9NUG9pbnQpXG4gICAgICAgIGlmICghSVNfTk9ERV9NQVBfRElSVFkuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICB2YXIgX25vZGUkcGFyZW50RWxlbWVudCwgX3dpbmRvdyRnZXRDb21wdXRlZFN0O1xuICAgICAgICAgIC8vIENocm9tZSBhbHNvIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIGVuZCBvZiBhbmNob3IgZWxlbWVudHM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNTkxMDBcbiAgICAgICAgICAvLyBUaGVyZWZvcmUgd2UgZG9uJ3QgYWxsb3cgbmF0aXZlIGV2ZW50cyB0byBpbnNlcnQgdGV4dCBhdCB0aGUgZW5kIG9mIGFuY2hvciBub2Rlcy5cbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICB2YXIgW25vZGUsIG9mZnNldF0gPSBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICAgICAgICB2YXIgYW5jaG9yTm9kZSA9IChfbm9kZSRwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfbm9kZSRwYXJlbnRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ2EnKTtcbiAgICAgICAgICB2YXIgX3dpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgICAgICAgIGlmIChuYXRpdmUgJiYgYW5jaG9yTm9kZSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBfbGFzdFRleHQkdGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHRleHQgbm9kZSBpbnNpZGUgdGhlIGFuY2hvci5cbiAgICAgICAgICAgIHZhciBsYXN0VGV4dCA9IF93aW5kb3cgPT09IG51bGwgfHwgX3dpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdy5kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGFuY2hvck5vZGUsIE5vZGVGaWx0ZXIuU0hPV19URVhUKS5sYXN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0VGV4dCA9PT0gbm9kZSAmJiAoKF9sYXN0VGV4dCR0ZXh0Q29udGVudCA9IGxhc3RUZXh0LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfbGFzdFRleHQkdGV4dENvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sYXN0VGV4dCR0ZXh0Q29udGVudC5sZW5ndGgpID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENocm9tZSBoYXMgaXNzdWVzIHdpdGggdGhlIHByZXNlbmNlIG9mIHRhYiBjaGFyYWN0ZXJzIGluc2lkZSBlbGVtZW50cyB3aXRoIHdoaXRlU3BhY2UgPSAncHJlJ1xuICAgICAgICAgIC8vIGNhdXNpbmcgYWJub3JtYWwgaW5zZXJ0IGJlaGF2aW9yOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjE5MTM5XG4gICAgICAgICAgaWYgKG5hdGl2ZSAmJiBub2RlLnBhcmVudEVsZW1lbnQgJiYgKF93aW5kb3cgPT09IG51bGwgfHwgX3dpbmRvdyA9PT0gdm9pZCAwIHx8IChfd2luZG93JGdldENvbXB1dGVkU3QgPSBfd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZS5wYXJlbnRFbGVtZW50KSkgPT09IG51bGwgfHwgX3dpbmRvdyRnZXRDb21wdXRlZFN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGdldENvbXB1dGVkU3Qud2hpdGVTcGFjZSkgPT09ICdwcmUnKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBhbmNob3IucGF0aCxcbiAgICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBOb2RlLnN0cmluZyhibG9ja1swXSkuaW5jbHVkZXMoJ1xcdCcpKSB7XG4gICAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBGb3IgdGhlIGRlbGV0aW5nIGZvcndhcmQvYmFja3dhcmQgaW5wdXQgdHlwZXMgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gY2hhbmdlIHRoZSBzZWxlY3Rpb24gYmVjYXVzZSBpdCBpcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIGJlIGRlbGV0ZWQsXG4gICAgICAvLyBhbmQgdGhvc2UgY29tbWFuZHMgZGV0ZXJtaW5lIHRoYXQgZm9yIHRoZW1zZWx2ZXMuXG4gICAgICAvLyBJZiB0aGUgTk9ERV9NQVAgaXMgZGlydHksIHdlIGNhbid0IHRydXN0IHRoZSBzZWxlY3Rpb24gYW5jaG9yIChlZyBSZWFjdEVkaXRvci50b0RPTVBvaW50IHZpYSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UpXG4gICAgICBpZiAoKCF0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZScpIHx8IHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlQnknKSkgJiYgIUlTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICAgIHZhciBbdGFyZ2V0UmFuZ2VdID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG4gICAgICAgIGlmICh0YXJnZXRSYW5nZSkge1xuICAgICAgICAgIHZhciBfcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCB0YXJnZXRSYW5nZSwge1xuICAgICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCBfcmFuZ2UpKSB7XG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SZWYgPSAhaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJlZikge1xuICAgICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uc2V0KGVkaXRvciwgc2VsZWN0aW9uUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2l0aW9uIGNoYW5nZSB0eXBlcyBvY2N1ciB3aGlsZSBhIHVzZXIgaXMgY29tcG9zaW5nIHRleHQgYW5kIGNhbid0IGJlXG4gICAgICAvLyBjYW5jZWxsZWQuIExldCB0aGVtIHRocm91Z2ggYW5kIHdhaXQgZm9yIHRoZSBjb21wb3NpdGlvbiB0byBlbmQuXG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW5hdGl2ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBJZiB0aGUgc2VsZWN0aW9uIGlzIGV4cGFuZGVkLCBldmVuIGlmIHRoZSBjb21tYW5kIHNlZW1zIGxpa2VcbiAgICAgIC8vIGEgZGVsZXRlIGZvcndhcmQvYmFja3dhcmQgY29tbWFuZCBpdCBzaG91bGQgZGVsZXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSAmJiB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZScpKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlLmVuZHNXaXRoKCdCYWNrd2FyZCcpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlRW50aXJlU29mdExpbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgICBjYXNlICdpbnNlcnRGcm9tWWFuayc6XG4gICAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICAgIGNhc2UgJ2luc2VydFRleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJykge1xuICAgICAgICAgICAgICAvLyBDT01QQVQ6IGluIFNhZmFyaSwgYGNvbXBvc2l0aW9uZW5kYCBpcyBkaXNwYXRjaGVkIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGZvciBcImluc2VydEZyb21Db21wb3NpdGlvblwiLiBCdXQgaWYgd2Ugd2FpdCBmb3IgaXRcbiAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGFib3J0IGJlY2F1c2Ugd2UncmUgc3RpbGwgY29tcG9zaW5nIGFuZCB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgIC8vIHdvbid0IGJlIHVwZGF0ZWQgcHJvcGVybHkuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9pbnB1dC1ldmVudHMtMi9cbiAgICAgICAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIGEgd2VhayBjb21wYXJpc29uIGluc3RlYWQgb2YgJ2luc3RhbmNlb2YnIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBwcm9ncmFtbWF0aWMgYWNjZXNzIG9mIHBhc3RlIGV2ZW50cyBjb21pbmcgZnJvbSBleHRlcm5hbCB3aW5kb3dzXG4gICAgICAgICAgICAvLyBsaWtlIGN5cHJlc3Mgd2hlcmUgY3kud2luZG93IGRvZXMgbm90IHdvcmsgcmVhbGlibHlcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUpID09PSAnRGF0YVRyYW5zZmVyJykge1xuICAgICAgICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAvLyBPbmx5IGluc2VydFRleHQgb3BlcmF0aW9ucyB1c2UgdGhlIG5hdGl2ZSBmdW5jdGlvbmFsaXR5LCBmb3Igbm93LlxuICAgICAgICAgICAgICAvLyBQb3RlbnRpYWxseSBleHBhbmQgdG8gc2luZ2xlIGNoYXJhY3RlciBkZWxldGVzLCBhcyB3ZWxsLlxuICAgICAgICAgICAgICBpZiAobmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQucHVzaCgoKSA9PiBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRhdGEpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIHRoZSBhY3R1YWwgdXNlciBzZWN0aW9uIGlmIG5vdGhpbmcgbWFudWFsbHkgc2V0IGl0LlxuICAgICAgdmFyIHRvUmVzdG9yZSA9IChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICBpZiAodG9SZXN0b3JlICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHRvUmVzdG9yZSkpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdG9SZXN0b3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlZGl0b3IsIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCBvblVzZXJJbnB1dCwgcHJvcHNPbkRPTUJlZm9yZUlucHV0LCByZWFkT25seSwgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICB2YXIgY2FsbGJhY2tSZWYgPSB1c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICBFRElUT1JfVE9fRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGlmIChyZWYuY3VycmVudCAmJiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgYGJlZm9yZWlucHV0YCBldmVudCBpc24ndCByZWNvZ25pemVkLlxuICAgICAgICByZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdHRhY2ggYSBuYXRpdmUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCBiZWNhdXNlIFJlYWN0J3NcbiAgICAgIC8vIGJ1aWx0LWluIGBvbkJlZm9yZUlucHV0YCBpcyBhY3R1YWxseSBhIGxlYWt5IHBvbHlmaWxsIHRoYXQgZG9lc24ndCBleHBvc2VcbiAgICAgIC8vIHJlYWwgYGJlZm9yZWlucHV0YCBldmVudHMgc2FkbHkuLi4gKDIwMTkvMTEvMDQpXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG4gICAgICBpZiAoSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvcndhcmRlZFJlZihub2RlKTtcbiAgICB9IGVsc2UgaWYgKGZvcndhcmRlZFJlZikge1xuICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIH1cbiAgfSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLCBlZGl0b3IsIG9uRE9NQmVmb3JlSW5wdXQsIGZvcndhcmRlZFJlZl0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgc2VsZWN0aW9uY2hhbmdlYCwgYmVjYXVzZSBSZWFjdCdzXG4gICAgLy8gYnVpbHQtaW4gYG9uU2VsZWN0YCBoYW5kbGVyIGRvZXNuJ3QgZmlyZSBmb3IgYWxsIHNlbGVjdGlvbiBjaGFuZ2VzLiBJdCdzXG4gICAgLy8gYSBsZWFreSBwb2x5ZmlsbCB0aGF0IG9ubHkgZmlyZXMgb24ga2V5cHJlc3NlcyBvciBjbGlja3MuIEluc3RlYWQsIHdlXG4gICAgLy8gd2FudCB0byBmaXJlIGZvciBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgLy8gKDIwMTkvMTEvMDQpIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNTc4NVxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAvLyBMaXN0ZW4gZm9yIGRyYWdlbmQgYW5kIGRyb3AgZ2xvYmFsbHkuIEluIEZpcmVmb3gsIGlmIGEgZHJvcCBoYW5kbGVyXG4gICAgLy8gaW5pdGlhdGVzIGFuIG9wZXJhdGlvbiB0aGF0IGNhdXNlcyB0aGUgb3JpZ2luYWxseSBkcmFnZ2VkIGVsZW1lbnQgdG9cbiAgICAvLyB1bm1vdW50LCB0aGF0IGVsZW1lbnQgd2lsbCBub3QgZW1pdCBhIGRyYWdlbmQgZXZlbnQuICgyMDI0LzA2LzIxKVxuICAgIHZhciBzdG9wcGVkRHJhZ2dpbmcgPSAoKSA9PiB7XG4gICAgICBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSA9IGZhbHNlO1xuICAgIH07XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBzdG9wcGVkRHJhZ2dpbmcpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgc3RvcHBlZERyYWdnaW5nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBzdG9wcGVkRHJhZ2dpbmcpO1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBzdG9wcGVkRHJhZ2dpbmcpO1xuICAgIH07XG4gIH0sIFtzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLCBzdGF0ZV0pO1xuICB2YXIgZGVjb3JhdGlvbnMgPSBkZWNvcmF0ZShbZWRpdG9yLCBbXV0pO1xuICB2YXIgc2hvd1BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5mcm9tKE5vZGUudGV4dHMoZWRpdG9yKSkubGVuZ3RoID09PSAxICYmIE5vZGUuc3RyaW5nKGVkaXRvcikgPT09ICcnICYmICFpc0NvbXBvc2luZztcbiAgdmFyIHBsYWNlSG9sZGVyUmVzaXplSGFuZGxlciA9IHVzZUNhbGxiYWNrKHBsYWNlaG9sZGVyRWwgPT4ge1xuICAgIGlmIChwbGFjZWhvbGRlckVsICYmIHNob3dQbGFjZWhvbGRlcikge1xuICAgICAgdmFyIF9wbGFjZWhvbGRlckVsJGdldEJvdTtcbiAgICAgIHNldFBsYWNlaG9sZGVySGVpZ2h0KChfcGxhY2Vob2xkZXJFbCRnZXRCb3UgPSBwbGFjZWhvbGRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSA9PT0gbnVsbCB8fCBfcGxhY2Vob2xkZXJFbCRnZXRCb3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wbGFjZWhvbGRlckVsJGdldEJvdS5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQbGFjZWhvbGRlckhlaWdodCh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3Nob3dQbGFjZWhvbGRlcl0pO1xuICBpZiAoc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgW1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIG9uUGxhY2Vob2xkZXJSZXNpemU6IHBsYWNlSG9sZGVyUmVzaXplSGFuZGxlcixcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogc3RhcnRcbiAgICB9KTtcbiAgfVxuICB2YXIge1xuICAgIG1hcmtzXG4gIH0gPSBlZGl0b3I7XG4gIHN0YXRlLmhhc01hcmtQbGFjZWhvbGRlciA9IGZhbHNlO1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBtYXJrcykge1xuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhsZWFmLCBfZXhjbHVkZWQyKTtcbiAgICAvLyBXaGlsZSBtYXJrcyBpc24ndCBhICdjb21wbGV0ZScgdGV4dCwgd2UgY2FuIHN0aWxsIHVzZSBsb29zZSBUZXh0LmVxdWFsc1xuICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG4gICAgaWYgKCFUZXh0JDEuZXF1YWxzKGxlYWYsIG1hcmtzLCB7XG4gICAgICBsb29zZTogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgdmFyIHVuc2V0ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHJlc3QpLm1hcChtYXJrID0+IFttYXJrLCBudWxsXSkpO1xuICAgICAgZGVjb3JhdGlvbnMucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIFtNQVJLX1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWVcbiAgICAgIH0sIHVuc2V0KSwgbWFya3MpLCB7fSwge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzOiBhbmNob3JcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgLy8gVXBkYXRlIEVESVRPUl9UT19NQVJLX1BMQUNFSE9MREVSX01BUktTIGluIHNldFRpbWVvdXQgdXNlRWZmZWN0IHRvIGVuc3VyZSB3ZSBkb24ndCBzZXQgaXRcbiAgLy8gYmVmb3JlIHdlIHJlY2VpdmUgdGhlIGNvbXBvc2l0aW9uIGVuZCBldmVudC5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBhbmNob3I6IF9hbmNob3JcbiAgICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgdmFyIF90ZXh0ID0gTm9kZS5sZWFmKGVkaXRvciwgX2FuY2hvci5wYXRoKTtcbiAgICAgICAgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAgICAgLy8gaGVyZSB3aGljaCBvbmx5IGNvbXBhcmVzIG1hcmtzIGFueXdheS5cbiAgICAgICAgaWYgKG1hcmtzICYmICFUZXh0JDEuZXF1YWxzKF90ZXh0LCBtYXJrcywge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlZGl0b3IsIG1hcmtzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFkT25seUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVhZE9ubHlcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9zaW5nQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBpc0NvbXBvc2luZ1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWNvcmF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGVjb3JhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzdG9yZURPTSwge1xuICAgIG5vZGU6IHJlZixcbiAgICByZWNlaXZlZFVzZXJJbnB1dDogcmVjZWl2ZWRVc2VySW5wdXRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgIHJvbGU6IHJlYWRPbmx5ID8gdW5kZWZpbmVkIDogJ3RleHRib3gnLFxuICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiB0cnVlXG4gIH0sIGF0dHJpYnV0ZXMpLCB7fSwge1xuICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZSdkXG4gICAgLy8gaGF2ZSB0byB1c2UgaGFja3MgdG8gbWFrZSB0aGVzZSByZXBsYWNlbWVudC1iYXNlZCBmZWF0dXJlcyB3b3JrLlxuICAgIC8vIEZvciBTU1Igc2l0dWF0aW9ucyBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgaXMgZmFsc2UgYW5kIHJlc3VsdHMgaW4gcHJvcFxuICAgIC8vIG1pc21hdGNoIHdhcm5pbmcgYXBwIG1vdmVzIHRvIGJyb3dzZXIuIFBhc3MtdGhyb3VnaCBjb25zdW1lciBwcm9wcyB3aGVuXG4gICAgLy8gbm90IENBTl9VU0VfRE9NIChTU1IpIGFuZCBkZWZhdWx0IHRvIGZhbHN5IHZhbHVlXG4gICAgc3BlbGxDaGVjazogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuc3BlbGxDaGVjayA6IGZhbHNlLFxuICAgIGF1dG9Db3JyZWN0OiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ29ycmVjdCA6ICdmYWxzZScsXG4gICAgYXV0b0NhcGl0YWxpemU6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9DYXBpdGFsaXplIDogJ2ZhbHNlJyxcbiAgICBcImRhdGEtc2xhdGUtZWRpdG9yXCI6IHRydWUsXG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ2YWx1ZVwiLFxuICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRoaXNcbiAgICBjb250ZW50RWRpdGFibGU6ICFyZWFkT25seSxcbiAgICAvLyBpbiBzb21lIGNhc2VzLCBhIGRlY29yYXRpb24gbmVlZHMgYWNjZXNzIHRvIHRoZSByYW5nZSAvIHNlbGVjdGlvbiB0byBkZWNvcmF0ZSBhIHRleHQgbm9kZSxcbiAgICAvLyB0aGVuIHlvdSB3aWxsIHNlbGVjdCB0aGUgd2hvbGUgdGV4dCBub2RlIHdoZW4geW91IHNlbGVjdCBwYXJ0IHRoZSBvZiB0ZXh0XG4gICAgLy8gdGhpcyBtYWdpYyB6SW5kZXg9XCItMVwiIHdpbGwgZml4IGl0XG4gICAgemluZGV4OiAtMSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgcmVmOiBjYWxsYmFja1JlZixcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkaXNhYmxlRGVmYXVsdFN0eWxlcyA/IHt9IDogX29iamVjdFNwcmVhZCh7XG4gICAgICAvLyBBbGxvdyBwb3NpdGlvbmluZyByZWxhdGl2ZSB0byB0aGUgZWRpdGFibGUgZWxlbWVudC5cbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgLy8gUHJlc2VydmUgYWRqYWNlbnQgd2hpdGVzcGFjZSBhbmQgbmV3IGxpbmVzLlxuICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgIC8vIEFsbG93IHdvcmRzIHRvIGJyZWFrIGlmIHRoZXkgYXJlIHRvbyBsb25nLlxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgIH0sIHBsYWNlaG9sZGVySGVpZ2h0ID8ge1xuICAgICAgbWluSGVpZ2h0OiBwbGFjZWhvbGRlckhlaWdodFxuICAgIH0gOiB7fSkpLCB1c2VyU3R5bGUpLFxuICAgIG9uQmVmb3JlSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgbGVha3kgcG9seWZpbGwgaW5zdGVhZCBqdXN0IGZvciBpdC4gSXRcbiAgICAgIC8vIG9ubHkgd29ya3MgZm9yIHRoZSBgaW5zZXJ0VGV4dGAgaW5wdXQgdHlwZS5cbiAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUICYmICFyZWFkT25seSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCkgJiYgUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgdmFyIF90ZXh0MiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBfdGV4dDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCwgZWRpdG9yLCByZWFkT25seV0pLFxuICAgIG9uSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbklucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudC5oYW5kbGVJbnB1dCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBGbHVzaCBuYXRpdmUgb3BlcmF0aW9ucywgYXMgbmF0aXZlIGV2ZW50cyB3aWxsIGhhdmUgcHJvcG9nYXRlZFxuICAgICAgLy8gYW5kIHdlIGNhbiBjb3JyZWN0bHkgY29tcGFyZSBET00gdGV4dCB2YWx1ZXMgaW4gY29tcG9uZW50c1xuICAgICAgLy8gdG8gc3RvcCByZW5kZXJpbmcsIHNvIHRoYXQgYnJvd3NlciBmdW5jdGlvbnMgbGlrZSBhdXRvY29ycmVjdFxuICAgICAgLy8gYW5kIHNwZWxsY2hlY2sgd29yayBhcyBleHBlY3RlZC5cbiAgICAgIGZvciAodmFyIG9wIG9mIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50KSB7XG4gICAgICAgIG9wKCk7XG4gICAgICB9XG4gICAgICBkZWZlcnJlZE9wZXJhdGlvbnMuY3VycmVudCA9IFtdO1xuICAgICAgLy8gQ09NUEFUOiBTaW5jZSBgYmVmb3JlaW5wdXRgIGRvZXNuJ3QgZnVsbHkgYHByZXZlbnREZWZhdWx0YCxcbiAgICAgIC8vIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBjb250ZW50IG1pZ2h0IGJlIHBsYWNlZCBpbiB0aGUgYnJvd3NlcidzIHVuZG8gc3RhY2suXG4gICAgICAvLyBUaGlzIG1lYW5zIHVuZG8gY2FuIGJlIHRyaWdnZXJlZCBldmVuIHdoZW4gdGhlIGRpdiBpcyBub3QgZm9jdXNlZCxcbiAgICAgIC8vIGFuZCBpdCBvbmx5IHRyaWdnZXJzIHRoZSBpbnB1dCBldmVudCBmb3IgdGhlIG5vZGUuICgyMDI0LzEwLzA5KVxuICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICB2YXIgbmF0aXZlID0gZXZlbnQubmF0aXZlRXZlbnQ7XG4gICAgICAgIHZhciBtYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGlmIChuYXRpdmUuaW5wdXRUeXBlID09PSAnaGlzdG9yeVVuZG8nICYmIHR5cGVvZiBtYXliZUhpc3RvcnlFZGl0b3IudW5kbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1heWJlSGlzdG9yeUVkaXRvci51bmRvKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmUuaW5wdXRUeXBlID09PSAnaGlzdG9yeVJlZG8nICYmIHR5cGVvZiBtYXliZUhpc3RvcnlFZGl0b3IucmVkbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25JbnB1dCwgZWRpdG9yXSksXG4gICAgb25CbHVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkgfHwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgfHwgaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CbHVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT01QQVQ6IElmIHRoZSBjdXJyZW50IGBhY3RpdmVFbGVtZW50YCBpcyBzdGlsbCB0aGUgcHJldmlvdXNcbiAgICAgIC8vIG9uZSwgdGhpcyBpcyBkdWUgdG8gdGhlIHdpbmRvdyBiZWluZyBibHVycmVkIHdoZW4gdGhlIHRhYlxuICAgICAgLy8gaXRzZWxmIGJlY29tZXMgdW5mb2N1c2VkLCBzbyB3ZSB3YW50IHRvIGFib3J0IGVhcmx5IHRvIGFsbG93IHRvXG4gICAgICAvLyBlZGl0b3IgdG8gc3RheSBmb2N1c2VkIHdoZW4gdGhlIHRhYiBiZWNvbWVzIGZvY3VzZWQgYWdhaW4uXG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgaWYgKHN0YXRlLmxhdGVzdEVsZW1lbnQgPT09IHJvb3QuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIHJldHVybmluZ1xuICAgICAgLy8gdG8gdGhlIGVkaXRvciBmcm9tIGFuIGVtYmVkZGVkIGVkaXRhYmxlIGVsZW1lbnQgKGVnLiBhbiA8aW5wdXQ+XG4gICAgICAvLyBlbGVtZW50IGluc2lkZSBhIHZvaWQgbm9kZSkuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyBmcm9tXG4gICAgICAvLyB0aGUgZWRpdG9yIHRvIGluc2lkZSBhIHZvaWQgbm9kZSdzIHNwYWNlciBlbGVtZW50LlxuICAgICAgaWYgKGlzRE9NRWxlbWVudChyZWxhdGVkVGFyZ2V0KSAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1zcGFjZXInKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgbW92aW5nIHRvIGFcbiAgICAgIC8vIG5vbi0gZWRpdGFibGUgc2VjdGlvbiBvZiBhbiBlbGVtZW50IHRoYXQgaXNuJ3QgYSB2b2lkIG5vZGUgKGVnLlxuICAgICAgLy8gYSBsaXN0IGl0ZW0gb2YgdGhlIGNoZWNrIGxpc3QgZXhhbXBsZSkuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCAhPSBudWxsICYmIGlzRE9NTm9kZShyZWxhdGVkVGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBTYWZhcmkgZG9lc24ndCBhbHdheXMgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZXZlbiBpZiB0aGUgY29udGVudC1cbiAgICAgIC8vIGVkaXRhYmxlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBmb2N1cy4gUmVmZXIgdG86XG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM1MzI0Ny9mb3JjZS1jb250ZW50ZWRpdGFibGUtZGl2LXRvLXN0b3AtYWNjZXB0aW5nLWlucHV0LWFmdGVyLWl0LWxvc2VzLWZvY3VzLXVuZGVyLXdlYlxuICAgICAgaWYgKElTX1dFQktJVCkge1xuICAgICAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24sIHN0YXRlLmxhdGVzdEVsZW1lbnQsIGVkaXRvciwgYXR0cmlidXRlcy5vbkJsdXJdKSxcbiAgICBvbkNsaWNrOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DbGljaykgJiYgaXNET01Ob2RlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgLy8gQXQgdGhpcyB0aW1lLCB0aGUgU2xhdGUgZG9jdW1lbnQgbWF5IGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudCxcbiAgICAgICAgLy8gYmVjYXVzZSBvbkNsaWNrIGhhbmRsZXJzIGNhbiBjaGFuZ2UgdGhlIGRvY3VtZW50IGJlZm9yZSB3ZSBnZXQgaGVyZS5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG11c3QgY2hlY2sgdGhhdCB0aGlzIHBhdGggYWN0dWFsbHkgZXhpc3RzLFxuICAgICAgICAvLyBhbmQgdGhhdCBpdCBzdGlsbCByZWZlcnMgdG8gdGhlIHNhbWUgbm9kZS5cbiAgICAgICAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpIHx8IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCkgIT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbCA9PT0gVFJJUExFX0NMSUNLICYmIHBhdGgubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICB2YXIgYmxvY2tQYXRoID0gcGF0aDtcbiAgICAgICAgICBpZiAoIShFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSkpKSB7XG4gICAgICAgICAgICB2YXIgX2Jsb2NrJDtcbiAgICAgICAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBibG9ja1BhdGggPSAoX2Jsb2NrJCA9IGJsb2NrID09PSBudWxsIHx8IGJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja1sxXSkgIT09IG51bGwgJiYgX2Jsb2NrJCAhPT0gdm9pZCAwID8gX2Jsb2NrJCA6IHBhdGguc2xpY2UoMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3N0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3N0YXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydFZvaWQgJiYgZW5kVm9pZCAmJiBQYXRoLmVxdWFscyhzdGFydFZvaWRbMV0sIGVuZFZvaWRbMV0pKSB7XG4gICAgICAgICAgdmFyIF9yYW5nZTIgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBfc3RhcnQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3JhbmdlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQ2xpY2ssIHJlYWRPbmx5XSksXG4gICAgb25Db21wb3NpdGlvbkVuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclIzO1xuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9PT0gdm9pZCAwIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjMuaGFuZGxlQ29tcG9zaXRpb25FbmQoZXZlbnQpO1xuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCkgfHwgSVNfQU5EUk9JRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IEluIENocm9tZSwgYGJlZm9yZWlucHV0YCBldmVudHMgZm9yIGNvbXBvc2l0aW9uc1xuICAgICAgICAvLyBhcmVuJ3QgY29ycmVjdCBhbmQgbmV2ZXIgZmlyZSB0aGUgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIlxuICAgICAgICAvLyB0eXBlIHRoYXQgd2UgbmVlZC4gU28gaW5zdGVhZCwgaW5zZXJ0IHdoZW5ldmVyIGEgY29tcG9zaXRpb25cbiAgICAgICAgLy8gZW5kcyBzaW5jZSBpdCB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGNvbW1pdHRlZCB0byB0aGUgRE9NLlxuICAgICAgICBpZiAoIUlTX1dFQktJVCAmJiAhSVNfRklSRUZPWF9MRUdBQ1kgJiYgIUlTX0lPUyAmJiAhSVNfV0VDSEFUQlJPV1NFUiAmJiAhSVNfVUNfTU9CSUxFICYmIGV2ZW50LmRhdGEpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJNYXJrcyA9IEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGluc2VydCB0ZXh0IHdpdGggdGhlIG1hcmtzIHRoZSB1c2VyIHdhcyBhY3R1YWxseSBzZWVpbmdcbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5zZXQoZWRpdG9yLCBlZGl0b3IubWFya3MpO1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtzID0gcGxhY2Vob2xkZXJNYXJrcztcbiAgICAgICAgICB9XG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICAgICAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgaWYgKHVzZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0b3IubWFya3MgPSB1c2VyTWFya3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCwgZWRpdG9yXSksXG4gICAgb25Db21wb3NpdGlvblVwZGF0ZTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlKSkge1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlLCBlZGl0b3JdKSxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNDtcbiAgICAgICAgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjQgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjQgPT09IHZvaWQgMCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI0LmhhbmRsZUNvbXBvc2l0aW9uU3RhcnQoZXZlbnQpO1xuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0KSB8fCBJU19BTkRST0lEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzQ29tcG9zaW5nKHRydWUpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydCwgZWRpdG9yXSksXG4gICAgb25Db3B5OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29weSkgJiYgIWlzRE9NRXZlbnRUYXJnZXRJbnB1dChldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2NvcHknKTtcbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvcHksIGVkaXRvcl0pLFxuICAgIG9uQ3V0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkN1dCkgJiYgIWlzRE9NRXZlbnRUYXJnZXRJbnB1dChldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2N1dCcpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuICAgICAgICAgICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQ3V0XSksXG4gICAgb25EcmFnT3ZlcjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uRHJhZ092ZXIsIGVkaXRvcl0pLFxuICAgIG9uRHJhZ1N0YXJ0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ1N0YXJ0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHN0YXJ0aW5nIGEgZHJhZyBvbiBhIHZvaWQgbm9kZSwgbWFrZSBzdXJlIGl0IGlzIHNlbGVjdGVkXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgc2hvd3MgdXAgaW4gdGhlIHNlbGVjdGlvbidzIGZyYWdtZW50LlxuICAgICAgICBpZiAodm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSB0cnVlO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5kYXRhVHJhbnNmZXIsICdkcmFnJyk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQsIHN0YXRlXSksXG4gICAgb25Ecm9wOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJvcCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZHJhZ2dlZCByYW5nZSBiZWZvcmUgdXBkYXRpbmcgc2VsZWN0aW9uXG4gICAgICAgIHZhciBkcmFnZ2VkUmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSB3aGVyZSB0aGUgZHJvcCBoYXBwZW5lZFxuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci5maW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgICAgICBpZiAoZHJhZ2dlZFJhbmdlICYmICFSYW5nZS5lcXVhbHMoZHJhZ2dlZFJhbmdlLCByYW5nZSkgJiYgIUVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBkcmFnZ2VkUmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIC8vIFdoZW4gZHJhZ2dpbmcgZnJvbSBhbm90aGVyIHNvdXJjZSBpbnRvIHRoZSBlZGl0b3IsIGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gdGhhdCB0aGUgY3VycmVudCBlZGl0b3IgZG9lcyBub3QgaGF2ZSBmb2N1cy5cbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbkRyb3AsIHN0YXRlXSksXG4gICAgb25EcmFnRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ICYmIGF0dHJpYnV0ZXMub25EcmFnRW5kICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYXR0cmlidXRlcy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgc3RhdGUsIGF0dHJpYnV0ZXMsIGVkaXRvcl0pLFxuICAgIG9uRm9jdXM6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkZvY3VzKSkge1xuICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAvLyBDT01QQVQ6IElmIHRoZSBlZGl0b3IgaGFzIG5lc3RlZCBlZGl0YWJsZSBlbGVtZW50cywgdGhlIGZvY3VzXG4gICAgICAgIC8vIGNhbiBnbyB0byB0aGVtLiBJbiBGaXJlZm94LCB0aGlzIG11c3QgYmUgcHJldmVudGVkIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBpc3N1ZXMgd2l0aCBrZXlib2FyZCBuYXZpZ2F0aW9uLiAoMjAxNy8wMy8zMClcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBzdGF0ZSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uRm9jdXNdKSxcbiAgICBvbktleURvd246IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclI1O1xuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSNSA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNSA9PT0gdm9pZCAwIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUuaGFuZGxlS2V5RG93bihldmVudCk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAvLyBDT01QQVQ6IFRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQgaXNuJ3QgZmlyZWQgcmVsaWFibHkgaW4gYWxsIGJyb3dzZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzb21ldGltZXMgbWlnaHQgZW5kIHVwIHN0dWNrIGluIGEgY29tcG9zaXRpb24gc3RhdGUgZXZlbiB0aG91Z2ggd2VcbiAgICAgICAgLy8gYXJlbid0IGNvbXBvc2luZyBhbnkgbW9yZS5cbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgbmF0aXZlRXZlbnQuaXNDb21wb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uS2V5RG93bikgfHwgUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGVkaXRvci5jaGlsZHJlbltzZWxlY3Rpb24gIT09IG51bGwgPyBzZWxlY3Rpb24uZm9jdXMucGF0aFswXSA6IDBdO1xuICAgICAgICB2YXIgaXNSVEwgPSBnZXREaXJlY3Rpb24oTm9kZS5zdHJpbmcoZWxlbWVudCkpID09PSAncnRsJztcbiAgICAgICAgLy8gQ09NUEFUOiBTaW5jZSB3ZSBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9uXG4gICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCB0aGUgYnJvd3NlciBkb2Vzbid0IHRoaW5rIHRoZXJlJ3MgZXZlclxuICAgICAgICAvLyBhbnkgaGlzdG9yeSBzdGFjayB0byB1bmRvIG9yIHJlZG8sIHNvIHdlIGhhdmUgdG8gbWFuYWdlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgb3Vyc2VsdmVzLiAoMjAxOS8xMS8wNilcbiAgICAgICAgaWYgKEhvdGtleXMuaXNSZWRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG1heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICBpZiAodHlwZW9mIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZUhpc3RvcnlFZGl0b3IucmVkbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhvdGtleXMuaXNVbmRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIF9tYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9tYXliZUhpc3RvcnlFZGl0b3IudW5kbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcGVybHkuIEluIENocm9tZSwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBleHRlbmRlZC5cbiAgICAgICAgLy8gQW5kIGluIEZpcmVmb3gsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgY29sbGFwc2VkLlxuICAgICAgICAvLyAoMjAxNy8xMC8xNylcbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cycsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogSWYgYSB2b2lkIG5vZGUgaXMgc2VsZWN0ZWQsIG9yIGEgemVyby13aWR0aCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYWRqYWNlbnQgdG8gYW4gaW5saW5lIGlzIHNlbGVjdGVkLCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG1hbnVhbGx5IGJlY2F1c2UgYnJvd3NlcnMgd29uJ3QgYmUgYWJsZSB0byBza2lwIG92ZXJcbiAgICAgICAgLy8gdGhlIHZvaWQgbm9kZSB3aXRoIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIG5vdCBiZWluZyBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6IGlzUlRMID8gJ2VuZCcgOiAnc3RhcnQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiBpc1JUTCA/ICdzdGFydCcgOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBndWVzc2luZyBhdCB0aGUgaW5wdXQgaW50ZW50aW9uIGZvciBob3RrZXlzLlxuICAgICAgICAvLyBDT01QQVQ6IEluIGlPUywgc29tZSBvZiB0aGVzZSBob3RrZXlzIGFyZSBoYW5kbGVkIGluIHRoZVxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBjb3JlIGJlaGF2aW9yIGZvciB0aGVzZSwgYnV0IHRoZXkgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIERPTSBpZiB3ZSBkb24ndCBwcmV2ZW50IHRoZW0sIHNvIHdlIGhhdmUgdG8uXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNCb2xkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzSXRhbGljKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzVHJhbnNwb3NlQ2hhcmFjdGVyKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTb2Z0QnJlYWsobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc1NwbGl0QmxvY2sobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChJU19DSFJPTUUgfHwgSVNfV0VCS0lUKSB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IENocm9tZSBhbmQgU2FmYXJpIHN1cHBvcnQgYGJlZm9yZWlucHV0YCBldmVudCBidXQgZG8gbm90IGZpcmVcbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IHdoZW4gZGVsZXRpbmcgYmFja3dhcmRzIGluIGEgc2VsZWN0ZWQgdm9pZCBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzRGVsZXRlRm9yd2FyZChuYXRpdmVFdmVudCkpICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuICAgICAgICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGN1cnJlbnROb2RlKSAmJiAoRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgY3VycmVudE5vZGUpIHx8IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgY3VycmVudE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uS2V5RG93bl0pLFxuICAgIG9uUGFzdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vblBhc3RlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgYG9uUGFzdGVgIGhlcmUgaW5zdGVhZC5cbiAgICAgICAgLy8gQ09NUEFUOiBGaXJlZm94LCBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCBlbWl0IGBiZWZvcmVpbnB1dGAgZXZlbnRzXG4gICAgICAgIC8vIHdoZW4gXCJwYXN0ZSB3aXRob3V0IGZvcm1hdHRpbmdcIiBpcyB1c2VkLCBzbyBmYWxsYmFjay4gKDIwMjAvMDIvMjApXG4gICAgICAgIC8vIENPTVBBVDogU2FmYXJpIElucHV0RXZlbnRzIGdlbmVyYXRlZCBieSBwYXN0aW5nIHdvbid0IGluY2x1ZGVcbiAgICAgICAgLy8gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBpdGVtcywgc28gdXNlIHRoZVxuICAgICAgICAvLyBDbGlwYm9hcmRFdmVudCBoZXJlLiAoMjAyMy8wMy8xNSlcbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgaXNQbGFpblRleHRPbmx5UGFzdGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IElTX1dFQktJVCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25QYXN0ZV0pXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGlsZHJlbiwge1xuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlZGl0b3IsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb246IGVkaXRvci5zZWxlY3Rpb25cbiAgfSkpKSkpKTtcbn0pO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciBlbGVtZW50XG4gKi9cbnZhciBEZWZhdWx0UGxhY2Vob2xkZXIgPSBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBDT01QQVQ6IEFydGlmaWNpYWxseSBhZGQgYSBsaW5lLWJyZWFrIHRvIHRoZSBlbmQgb24gdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnRcbiAgICAvLyB0byBwcmV2ZW50IEFuZHJvaWQgSU1FcyB0byBwaWNrIHVwIGl0cyBjb250ZW50IGluIGF1dG9jb3JyZWN0IGFuZCB0byBhdXRvLWNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlclxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9vYmplY3RTcHJlYWQoe30sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbiwgSVNfQU5EUk9JRCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpKVxuICApO1xufTtcbi8qKlxuICogQSBkZWZhdWx0IG1lbW9pemVkIGRlY29yYXRlIGZ1bmN0aW9uLlxuICovXG52YXIgZGVmYXVsdERlY29yYXRlID0gKCkgPT4gW107XG4vKipcbiAqIEEgZGVmYXVsdCBpbXBsZW1lbnQgdG8gc2Nyb2xsIGRvbSByYW5nZSBpbnRvIHZpZXcuXG4gKi9cbnZhciBkZWZhdWx0U2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgPSAoZWRpdG9yLCBkb21SYW5nZSkgPT4ge1xuICAvLyBUaGlzIHdhcyBhZmZlY3RpbmcgdGhlIHNlbGVjdGlvbiBvZiBtdWx0aXBsZSBibG9ja3MgYW5kIGRyYWdnaW5nIGJlaGF2aW9yLFxuICAvLyBzbyBlbmFibGVkIG9ubHkgaWYgdGhlIHNlbGVjdGlvbiBoYXMgYmVlbiBjb2xsYXBzZWQuXG4gIGlmIChkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpKSB7XG4gICAgdmFyIGxlYWZFbCA9IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgbGVhZkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdC5iaW5kKGRvbVJhbmdlKTtcbiAgICBzY3JvbGxJbnRvVmlldyhsZWFmRWwsIHtcbiAgICAgIHNjcm9sbE1vZGU6ICdpZi1uZWVkZWQnXG4gICAgfSk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhbiB1bm9ydGhvZG94IGRlbGV0ZSBEOlxuICAgIGRlbGV0ZSBsZWFmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0O1xuICB9XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhbiBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxuICovXG52YXIgaXNFdmVudEhhbmRsZWQgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSBjdXN0b20gZXZlbnQgaGFuZGxlciBtYXkgcmV0dXJuIGEgYm9vbGVhbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlIGV2ZW50XG4gIC8vIHNoYWxsIGJlIHRyZWF0ZWQgYXMgYmVpbmcgaGFuZGxlZCBvciBub3QuXG4gIHZhciBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkID0gaGFuZGxlcihldmVudCk7XG4gIGlmIChzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZDtcbiAgfVxuICByZXR1cm4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIHRoZSBldmVudCdzIHRhcmdldCBpcyBhbiBpbnB1dCBlbGVtZW50XG4gKi9cbnZhciBpc0RPTUV2ZW50VGFyZ2V0SW5wdXQgPSBldmVudCA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSAmJiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIGV2ZW50IGlzIG92ZXJyaWRlZCBieSBhIGhhbmRsZXIuXG4gKi9cbnZhciBpc0RPTUV2ZW50SGFuZGxlZCA9IChldmVudCwgaGFuZGxlcikgPT4ge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIGN1c3RvbSBldmVudCBoYW5kbGVyIG1heSByZXR1cm4gYSBib29sZWFuIHRvIHNwZWNpZnkgd2hldGhlciB0aGUgZXZlbnRcbiAgLy8gc2hhbGwgYmUgdHJlYXRlZCBhcyBiZWluZyBoYW5kbGVkIG9yIG5vdC5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcbiAgaWYgKHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkO1xuICB9XG4gIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkO1xufTtcblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBmb2N1c2VkYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICovXG52YXIgRm9jdXNlZENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIHVzZUZvY3VzZWQgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KEZvY3VzZWRDb250ZXh0KTtcbn07XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3I7XG59XG4vKipcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIHNlbGVjdG9yIGNvbnRleHQgaW4gYSB3YXkgdG8gY29udHJvbCByZXJlbmRlcnNcbiAqL1xudmFyIFNsYXRlU2VsZWN0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoe30pO1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG4vKipcbiAqIHVzZSByZWR1eCBzdHlsZSBzZWxlY3RvcnMgdG8gcHJldmVudCByZXJlbmRlcmluZyBvbiBldmVyeSBrZXlzdHJva2UuXG4gKiBCZWFyIGluIG1pbmQgcmVyZW5kZXJpbmcgY2FuIG9ubHkgcHJldmVudGVkIGlmIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhIHZhbHVlIHR5cGUgb3IgZm9yIHJlZmVyZW5jZSB0eXBlcyAoZS5nLiBvYmplY3RzIGFuZCBhcnJheXMpIGFkZCBhIGN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiAgY29uc3QgaXNTZWxlY3Rpb25BY3RpdmUgPSB1c2VTbGF0ZVNlbGVjdG9yKGVkaXRvciA9PiBCb29sZWFuKGVkaXRvci5zZWxlY3Rpb24pKTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VTbGF0ZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHZhciBlcXVhbGl0eUZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiByZWZFcXVhbGl0eTtcbiAgdmFyIFssIGZvcmNlUmVuZGVyXSA9IHVzZVJlZHVjZXIocyA9PiBzICsgMSwgMCk7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZVNlbGVjdG9yQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTZWxlY3RvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG4gIHZhciB7XG4gICAgZ2V0U2xhdGUsXG4gICAgYWRkRXZlbnRMaXN0ZW5lclxuICB9ID0gY29udGV4dDtcbiAgdmFyIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFNlbGVjdG9yID0gdXNlUmVmKCgpID0+IG51bGwpO1xuICB2YXIgbGF0ZXN0U2VsZWN0ZWRTdGF0ZSA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNlbGVjdGVkU3RhdGU7XG4gIHRyeSB7XG4gICAgaWYgKHNlbGVjdG9yICE9PSBsYXRlc3RTZWxlY3Rvci5jdXJyZW50IHx8IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IHNlbGVjdG9yKGdldFNsYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCAmJiBpc0Vycm9yKGVycikpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiXFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcXG5cIi5jb25jYXQobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrLCBcIlxcblxcblwiKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBzZWxlY3RlZFN0YXRlO1xuICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudChnZXRTbGF0ZSgpKTtcbiAgICAgICAgaWYgKGVxdWFsaXR5Rm4obmV3U2VsZWN0ZWRTdGF0ZSwgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBuZXdTZWxlY3RlZFN0YXRlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIGlnbm9yZSBhbGwgZXJyb3JzIGhlcmUsIHNpbmNlIHdoZW4gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpcyByZS1yZW5kZXJlZCwgdGhlIHNlbGVjdG9ycyBhcmUgY2FsbGVkIGFnYWluLCBhbmRcbiAgICAgICAgLy8gd2lsbCB0aHJvdyBhZ2FpbiwgaWYgbmVpdGhlciBwcm9wcyBub3Igc3RvcmUgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlZFxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSBlcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICB9XG4gICAgdmFyIHVuc3Vic2NyaWJlID0gYWRkRXZlbnRMaXN0ZW5lcihjaGVja0ZvclVwZGF0ZXMpO1xuICAgIGNoZWNrRm9yVXBkYXRlcygpO1xuICAgIHJldHVybiAoKSA9PiB1bnN1YnNjcmliZSgpO1xuICB9LFxuICAvLyBkb24ndCByZXJlbmRlciBvbiBlcXVhbGl0eUZuIGNoYW5nZSBzaW5jZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gZGVmaW5lIGl0IGlubGluZVxuICBbYWRkRXZlbnRMaXN0ZW5lciwgZ2V0U2xhdGVdKTtcbiAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG59XG4vKipcbiAqIENyZWF0ZSBzZWxlY3RvciBjb250ZXh0IHdpdGggZWRpdG9yIHVwZGF0aW5nIG9uIGV2ZXJ5IGVkaXRvciBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXNlU2VsZWN0b3JDb250ZXh0KGVkaXRvcikge1xuICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB1c2VSZWYoW10pLmN1cnJlbnQ7XG4gIHZhciBzbGF0ZVJlZiA9IHVzZVJlZih7XG4gICAgZWRpdG9yXG4gIH0pLmN1cnJlbnQ7XG4gIHZhciBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKGVkaXRvciA9PiB7XG4gICAgc2xhdGVSZWYuZWRpdG9yID0gZWRpdG9yO1xuICAgIGV2ZW50TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZWRpdG9yKSk7XG4gIH0sIFtldmVudExpc3RlbmVycywgc2xhdGVSZWZdKTtcbiAgdmFyIHNlbGVjdG9yQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRTbGF0ZTogKCkgPT4gc2xhdGVSZWYuZWRpdG9yLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogY2FsbGJhY2sgPT4ge1xuICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtldmVudExpc3RlbmVycywgc2xhdGVSZWZdKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RvckNvbnRleHQsXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxudmFyIFJFQUNUX01BSk9SX1ZFUlNJT04gPSBwYXJzZUludChSZWFjdC52ZXJzaW9uLnNwbGl0KCcuJylbMF0sIDEwKTtcblxudmFyIF9leGNsdWRlZCA9IFtcImVkaXRvclwiLCBcImNoaWxkcmVuXCIsIFwib25DaGFuZ2VcIiwgXCJvblNlbGVjdGlvbkNoYW5nZVwiLCBcIm9uVmFsdWVDaGFuZ2VcIiwgXCJpbml0aWFsVmFsdWVcIl07XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIHByb3ZpZGVyIHRvIGhhbmRsZSBgb25DaGFuZ2VgIGV2ZW50cywgYmVjYXVzZSB0aGUgZWRpdG9yXG4gKiBpcyBhIG11dGFibGUgc2luZ2xldG9uIHNvIGl0IHdvbid0IGV2ZXIgcmVnaXN0ZXIgYXMgXCJjaGFuZ2VkXCIgb3RoZXJ3aXNlLlxuICovXG52YXIgU2xhdGUgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgICBlZGl0b3IsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIG9uQ2hhbmdlLFxuICAgICAgb25TZWxlY3Rpb25DaGFuZ2UsXG4gICAgICBvblZhbHVlQ2hhbmdlLFxuICAgICAgaW5pdGlhbFZhbHVlXG4gICAgfSA9IHByb3BzLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG4gIHZhciBbY29udGV4dCwgc2V0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgaWYgKCFOb2RlLmlzTm9kZUxpc3QoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBpbml0aWFsVmFsdWUgaXMgaW52YWxpZCEgRXhwZWN0ZWQgYSBsaXN0IG9mIGVsZW1lbnRzIGJ1dCBnb3Q6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoaW5pdGlhbFZhbHVlKSkpO1xuICAgIH1cbiAgICBpZiAoIUVkaXRvci5pc0VkaXRvcihlZGl0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbU2xhdGVdIGVkaXRvciBpcyBpbnZhbGlkISBZb3UgcGFzc2VkOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KGVkaXRvcikpKTtcbiAgICB9XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gaW5pdGlhbFZhbHVlO1xuICAgIE9iamVjdC5hc3NpZ24oZWRpdG9yLCByZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogMCxcbiAgICAgIGVkaXRvclxuICAgIH07XG4gIH0pO1xuICB2YXIge1xuICAgIHNlbGVjdG9yQ29udGV4dCxcbiAgICBvbkNoYW5nZTogaGFuZGxlU2VsZWN0b3JDaGFuZ2VcbiAgfSA9IHVzZVNlbGVjdG9yQ29udGV4dChlZGl0b3IpO1xuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gdXNlQ2FsbGJhY2sob3B0aW9ucyA9PiB7XG4gICAgdmFyIF9vcHRpb25zJG9wZXJhdGlvbjtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKGVkaXRvci5jaGlsZHJlbik7XG4gICAgfVxuICAgIHN3aXRjaCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgfHwgKF9vcHRpb25zJG9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRvcGVyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2UgPT09IG51bGwgfHwgb25TZWxlY3Rpb25DaGFuZ2UgPT09IHZvaWQgMCB8fCBvblNlbGVjdGlvbkNoYW5nZShlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvblZhbHVlQ2hhbmdlID09PSBudWxsIHx8IG9uVmFsdWVDaGFuZ2UgPT09IHZvaWQgMCB8fCBvblZhbHVlQ2hhbmdlKGVkaXRvci5jaGlsZHJlbik7XG4gICAgfVxuICAgIHNldENvbnRleHQocHJldkNvbnRleHQgPT4gKHtcbiAgICAgIHY6IHByZXZDb250ZXh0LnYgKyAxLFxuICAgICAgZWRpdG9yXG4gICAgfSkpO1xuICAgIGhhbmRsZVNlbGVjdG9yQ2hhbmdlKGVkaXRvcik7XG4gIH0sIFtlZGl0b3IsIGhhbmRsZVNlbGVjdG9yQ2hhbmdlLCBvbkNoYW5nZSwgb25TZWxlY3Rpb25DaGFuZ2UsIG9uVmFsdWVDaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsIG9uQ29udGV4dENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtlZGl0b3IsIG9uQ29udGV4dENoYW5nZV0pO1xuICB2YXIgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBmbiA9ICgpID0+IHNldElzRm9jdXNlZChSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG4gICAgaWYgKFJFQUNUX01BSk9SX1ZFUlNJT04gPj0gMTcpIHtcbiAgICAgIC8vIEluIFJlYWN0ID49IDE3IG9uRm9jdXMgYW5kIG9uQmx1ciBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgLy8gVGhlcmVmb3JlIGluIG9yZGVyIGZvciA8RWRpdGFibGUgLz4ncyBoYW5kbGVycyB0byBydW4gZmlyc3QsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcilcbiAgICAgIC8vIHRvIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSwgd2UgaGF2ZSB0byBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyB3aXRob3V0IHVzZUNhcHR1cmUgaGVyZS5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZm4sIHRydWUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVTZWxlY3RvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VsZWN0b3JDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dC5lZGl0b3JcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNGb2N1c2VkXG4gIH0sIGNoaWxkcmVuKSkpKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cbiAqIEBkZXByZWNhdGVkIFVzZSB1c2VTbGF0ZVN0YXRpYyBpbnN0ZWFkLlxuICovXG52YXIgdXNlRWRpdG9yID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZUVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzbGF0ZSBzZWxlY3Rpb24uXG4gKiBPbmx5IHRyaWdnZXJzIGEgcmVyZW5kZXIgd2hlbiB0aGUgc2VsZWN0aW9uIGFjdHVhbGx5IGNoYW5nZXNcbiAqL1xudmFyIHVzZVNsYXRlU2VsZWN0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gdXNlU2xhdGVTZWxlY3RvcihlZGl0b3IgPT4gZWRpdG9yLnNlbGVjdGlvbiwgaXNTZWxlY3Rpb25FcXVhbCk7XG59O1xudmFyIGlzU2VsZWN0aW9uRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiB0cnVlO1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFJhbmdlLmVxdWFscyhhLCBiKTtcbn07XG5cbi8qKlxuICogYHdpdGhSZWFjdGAgYWRkcyBSZWFjdCBhbmQgRE9NIHNwZWNpZmljIGJlaGF2aW9ycyB0byB0aGUgZWRpdG9yLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG11c3QgZXh0ZW5kIFNsYXRlJ3MgQ3VzdG9tVHlwZXMgdG8gdXNlXG4gKiB0aGlzIHBsdWdpbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzExLXR5cGVzY3JpcHQgdG8gbGVhcm4gaG93LlxuICovXG52YXIgd2l0aFJlYWN0ID0gZnVuY3Rpb24gd2l0aFJlYWN0KGVkaXRvcikge1xuICB2YXIgY2xpcGJvYXJkRm9ybWF0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneC1zbGF0ZS1mcmFnbWVudCc7XG4gIHZhciBlID0gZWRpdG9yO1xuICBlID0gd2l0aERPTShlLCBjbGlwYm9hcmRGb3JtYXRLZXkpO1xuICB2YXIge1xuICAgIG9uQ2hhbmdlXG4gIH0gPSBlO1xuICBlLm9uQ2hhbmdlID0gb3B0aW9ucyA9PiB7XG4gICAgLy8gQ09NUEFUOiBSZWFjdCA8IDE4IGRvZXNuJ3QgYmF0Y2ggYHNldFN0YXRlYCBob29rIGNhbGxzLCB3aGljaCBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIGNoaWxkcmVuIGFuZCBzZWxlY3Rpb24gY2FuIGdldCBvdXQgb2Ygc3luYyBmb3Igb25lIHJlbmRlclxuICAgIC8vIHBhc3MuIFNvIHdlIGhhdmUgdG8gdXNlIHRoaXMgdW5zdGFibGUgQVBJIHRvIGVuc3VyZSBpdCBiYXRjaGVzIHRoZW0uXG4gICAgLy8gKDIwMTkvMTIvMDMpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDI1OSNpc3N1ZWNvbW1lbnQtNDM5NzAyMzY3XG4gICAgdmFyIG1heWJlQmF0Y2hVcGRhdGVzID0gUkVBQ1RfTUFKT1JfVkVSU0lPTiA8IDE4ID8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgOiBjYWxsYmFjayA9PiBjYWxsYmFjaygpO1xuICAgIG1heWJlQmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG9uQ2hhbmdlKG9wdGlvbnMpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZTtcbn07XG5cbmV4cG9ydCB7IERlZmF1bHRFbGVtZW50LCBEZWZhdWx0TGVhZiwgRGVmYXVsdFBsYWNlaG9sZGVyLCBFZGl0YWJsZSwgUmVhY3RFZGl0b3IsIFNsYXRlLCB1c2VDb21wb3NpbmcsIHVzZUVkaXRvciwgdXNlRm9jdXNlZCwgdXNlUmVhZE9ubHksIHVzZVNlbGVjdGVkLCB1c2VTbGF0ZSwgdXNlU2xhdGVTZWxlY3Rpb24sIHVzZVNsYXRlU2VsZWN0b3IsIHVzZVNsYXRlU3RhdGljLCB1c2VTbGF0ZVdpdGhWLCB3aXRoUmVhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/slate-react/dist/index.es.js\n"));

/***/ }),

/***/ "./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   above: () => (/* binding */ above),\n/* harmony export */   addMark: () => (/* binding */ addMark),\n/* harmony export */   after: () => (/* binding */ after),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   before: () => (/* binding */ before),\n/* harmony export */   collapse: () => (/* binding */ collapse),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   deleteBackward: () => (/* binding */ deleteBackward),\n/* harmony export */   deleteForward: () => (/* binding */ deleteForward),\n/* harmony export */   deleteFragment: () => (/* binding */ deleteFragment),\n/* harmony export */   deleteText: () => (/* binding */ deleteText),\n/* harmony export */   deselect: () => (/* binding */ deselect),\n/* harmony export */   edges: () => (/* binding */ edges),\n/* harmony export */   elementReadOnly: () => (/* binding */ elementReadOnly),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   getDirtyPaths: () => (/* binding */ getDirtyPaths),\n/* harmony export */   getFragment: () => (/* binding */ getFragment),\n/* harmony export */   getVoid: () => (/* binding */ getVoid),\n/* harmony export */   hasBlocks: () => (/* binding */ hasBlocks),\n/* harmony export */   hasInlines: () => (/* binding */ hasInlines),\n/* harmony export */   hasPath: () => (/* binding */ hasPath),\n/* harmony export */   hasTexts: () => (/* binding */ hasTexts),\n/* harmony export */   insertBreak: () => (/* binding */ insertBreak),\n/* harmony export */   insertFragment: () => (/* binding */ insertFragment),\n/* harmony export */   insertNode: () => (/* binding */ insertNode),\n/* harmony export */   insertNodes: () => (/* binding */ insertNodes),\n/* harmony export */   insertSoftBreak: () => (/* binding */ insertSoftBreak),\n/* harmony export */   insertText: () => (/* binding */ insertText),\n/* harmony export */   isBlock: () => (/* binding */ isBlock),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isEditor: () => (/* binding */ isEditor),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEnd: () => (/* binding */ isEnd),\n/* harmony export */   isNormalizing: () => (/* binding */ isNormalizing),\n/* harmony export */   isStart: () => (/* binding */ isStart),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   leaf: () => (/* binding */ leaf),\n/* harmony export */   levels: () => (/* binding */ levels),\n/* harmony export */   liftNodes: () => (/* binding */ liftNodes),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   mergeNodes: () => (/* binding */ mergeNodes),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   moveNodes: () => (/* binding */ moveNodes),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   node: () => (/* binding */ node),\n/* harmony export */   nodes: () => (/* binding */ nodes),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeNode: () => (/* binding */ normalizeNode),\n/* harmony export */   parent: () => (/* binding */ parent),\n/* harmony export */   path: () => (/* binding */ path),\n/* harmony export */   pathRef: () => (/* binding */ pathRef),\n/* harmony export */   pathRefs: () => (/* binding */ pathRefs),\n/* harmony export */   point: () => (/* binding */ point),\n/* harmony export */   pointRef: () => (/* binding */ pointRef),\n/* harmony export */   pointRefs: () => (/* binding */ pointRefs),\n/* harmony export */   positions: () => (/* binding */ positions),\n/* harmony export */   previous: () => (/* binding */ previous),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   rangeRef: () => (/* binding */ rangeRef),\n/* harmony export */   rangeRefs: () => (/* binding */ rangeRefs),\n/* harmony export */   removeMark: () => (/* binding */ removeMark),\n/* harmony export */   removeNodes: () => (/* binding */ removeNodes),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   setNodes: () => (/* binding */ setNodes),\n/* harmony export */   setNormalizing: () => (/* binding */ setNormalizing),\n/* harmony export */   setPoint: () => (/* binding */ setPoint),\n/* harmony export */   setSelection: () => (/* binding */ setSelection),\n/* harmony export */   shouldMergeNodesRemovePrevNode: () => (/* binding */ shouldMergeNodesRemovePrevNode),\n/* harmony export */   shouldNormalize: () => (/* binding */ shouldNormalize),\n/* harmony export */   splitNodes: () => (/* binding */ splitNodes),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   unhangRange: () => (/* binding */ unhangRange),\n/* harmony export */   unsetNodes: () => (/* binding */ unsetNodes),\n/* harmony export */   unwrapNodes: () => (/* binding */ unwrapNodes),\n/* harmony export */   withoutNormalizing: () => (/* binding */ withoutNormalizing),\n/* harmony export */   wrapNodes: () => (/* binding */ wrapNodes)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"./node_modules/immer/dist/immer.mjs\");\n\n\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n    return paths;\n  },\n  common(path, another) {\n    var common = [];\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n      if (av !== bv) {\n        break;\n      }\n      common.push(av);\n    }\n    return common;\n  },\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n    return 0;\n  },\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n    if (reverse) {\n      list.reverse();\n    }\n    return list;\n  },\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n      default:\n        return false;\n    }\n  },\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n    return path.slice(0, -1);\n  },\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n    var last = path[path.length - 1];\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n    return path.slice(0, -1).concat(last - 1);\n  },\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n    return path.slice(ancestor.length);\n  },\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null;\n    // PERF: use destructing instead of immer\n    var p = [...path];\n    var {\n      affinity = 'forward'\n    } = options;\n    // PERF: Exit early if the operation is guaranteed not to have an effect.\n    if (path.length === 0) {\n      return p;\n    }\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var {\n            path: op\n          } = operation;\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n          break;\n        }\n      case 'remove_node':\n        {\n          var {\n            path: _op\n          } = operation;\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n          break;\n        }\n      case 'merge_node':\n        {\n          var {\n            path: _op2,\n            position\n          } = operation;\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n          break;\n        }\n      case 'split_node':\n        {\n          var {\n            path: _op3,\n            position: _position\n          } = operation;\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n          break;\n        }\n      case 'move_node':\n        {\n          var {\n            path: _op4,\n            newPath: onp\n          } = operation;\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n            p[_op4.length - 1] -= 1;\n          }\n          break;\n        }\n    }\n    return p;\n  }\n};\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var {\n          path,\n          node\n        } = op;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n        parent.children.splice(index, 0, node);\n        if (selection) {\n          for (var [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op);\n          }\n        }\n        break;\n      }\n    case 'insert_text':\n      {\n        var {\n          path: _path,\n          offset,\n          text\n        } = op;\n        if (text.length === 0) break;\n        var _node = Node.leaf(editor, _path);\n        var before = _node.text.slice(0, offset);\n        var after = _node.text.slice(offset);\n        _node.text = before + text + after;\n        if (selection) {\n          for (var [_point, _key] of Range.points(selection)) {\n            selection[_key] = Point.transform(_point, op);\n          }\n        }\n        break;\n      }\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n        var _node2 = Node.get(editor, _path2);\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n        var _parent = Node.parent(editor, _path2);\n        var _index = _path2[_path2.length - 1];\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          prev.children.push(..._node2.children);\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n        _parent.children.splice(_index, 1);\n        if (selection) {\n          for (var [_point2, _key2] of Range.points(selection)) {\n            selection[_key2] = Point.transform(_point2, op);\n          }\n        }\n        break;\n      }\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n        var _node3 = Node.get(editor, _path3);\n        var _parent2 = Node.parent(editor, _path3);\n        var _index2 = _path3[_path3.length - 1];\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        _parent2.children.splice(_index2, 1);\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n        if (selection) {\n          for (var [_point3, _key3] of Range.points(selection)) {\n            selection[_key3] = Point.transform(_point3, op);\n          }\n        }\n        break;\n      }\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _index3 = _path4[_path4.length - 1];\n        var _parent3 = Node.parent(editor, _path4);\n        _parent3.children.splice(_index3, 1);\n        // Transform all the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (var [_point4, _key4] of Range.points(selection)) {\n            var result = Point.transform(_point4, op);\n            if (selection != null && result != null) {\n              selection[_key4] = result;\n            } else {\n              var _prev = void 0;\n              var next = void 0;\n              for (var [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, _path4) === -1) {\n                  _prev = [n, p];\n                } else {\n                  next = [n, p];\n                  break;\n                }\n              }\n              var preferNext = false;\n              if (_prev && next) {\n                if (Path.equals(next[1], _path4)) {\n                  preferNext = !Path.hasPrevious(next[1]);\n                } else {\n                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                }\n              }\n              if (_prev && !preferNext) {\n                _point4.path = _prev[1];\n                _point4.offset = _prev[0].text.length;\n              } else if (next) {\n                _point4.path = next[1];\n                _point4.offset = 0;\n              } else {\n                selection = null;\n              }\n            }\n          }\n        }\n        break;\n      }\n    case 'remove_text':\n      {\n        var {\n          path: _path5,\n          offset: _offset,\n          text: _text\n        } = op;\n        if (_text.length === 0) break;\n        var _node4 = Node.leaf(editor, _path5);\n        var _before = _node4.text.slice(0, _offset);\n        var _after = _node4.text.slice(_offset + _text.length);\n        _node4.text = _before + _after;\n        if (selection) {\n          for (var [_point5, _key5] of Range.points(selection)) {\n            selection[_key5] = Point.transform(_point5, op);\n          }\n        }\n        break;\n      }\n    case 'set_node':\n      {\n        var {\n          path: _path6,\n          properties,\n          newProperties\n        } = op;\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n        var _node5 = Node.get(editor, _path6);\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n          var value = newProperties[_key6];\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        }\n        // properties that were previously defined, but are now missing, must be deleted\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n        break;\n      }\n    case 'set_selection':\n      {\n        var {\n          newProperties: _newProperties\n        } = op;\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n            selection = _objectSpread$e({}, _newProperties);\n          }\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n        break;\n      }\n    case 'split_node':\n      {\n        var {\n          path: _path7,\n          position,\n          properties: _properties\n        } = op;\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n        var _node6 = Node.get(editor, _path7);\n        var _parent4 = Node.parent(editor, _path7);\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n          var _after2 = _node6.text.slice(position);\n          _node6.text = _before2;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n          var _after3 = _node6.children.slice(position);\n          _node6.children = _before3;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            children: _after3\n          });\n        }\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n        if (selection) {\n          for (var [_point6, _key9] of Range.points(selection)) {\n            selection[_key9] = Point.transform(_point6, op);\n          }\n        }\n        break;\n      }\n  }\n  return selection;\n};\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n  transform(editor, op) {\n    editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n    var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n      if (selection) {\n        editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n  insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options);\n  },\n  liftNodes(editor, options) {\n    editor.liftNodes(options);\n  },\n  mergeNodes(editor, options) {\n    editor.mergeNodes(options);\n  },\n  moveNodes(editor, options) {\n    editor.moveNodes(options);\n  },\n  removeNodes(editor, options) {\n    editor.removeNodes(options);\n  },\n  setNodes(editor, props, options) {\n    editor.setNodes(props, options);\n  },\n  splitNodes(editor, options) {\n    editor.splitNodes(options);\n  },\n  unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options);\n  },\n  unwrapNodes(editor, options) {\n    editor.unwrapNodes(options);\n  },\n  wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n  collapse(editor, options) {\n    editor.collapse(options);\n  },\n  deselect(editor) {\n    editor.deselect();\n  },\n  move(editor, options) {\n    editor.move(options);\n  },\n  select(editor, target) {\n    editor.select(target);\n  },\n  setPoint(editor, props, options) {\n    editor.setPoint(props, options);\n  },\n  setSelection(editor, props) {\n    editor.setSelection(props);\n  }\n};\n\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded$4 = [\"anchor\", \"focus\"];\nfunction ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Range = {\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n  surrounds(range, target) {\n    var intersectionRange = Range.intersection(range, target);\n    if (!intersectionRange) {\n      return false;\n    }\n    return Range.equals(intersectionRange, target);\n  },\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n    return isAfterStart && isBeforeEnd;\n  },\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$4);\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$d({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n  isRange(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, r => {\n      if (r === null) {\n        return null;\n      }\n      var {\n        affinity = 'inward'\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n      if (!anchor || !focus) {\n        return null;\n      }\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\n\n/**\n * Shared the function with isElementType utility\n */\nvar isElement = value => {\n  return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n  isAncestor(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n  },\n  isElement,\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n  _excluded2$3 = [\"text\"];\nvar IS_NODE_LIST_CACHE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Node = {\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      for (var p of Path.ancestors(path, options)) {\n        var n = Node.ancestor(root, p);\n        var entry = [n, p];\n        yield entry;\n      }\n    }();\n  },\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n    var c = root.children[index];\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n    return c;\n  },\n  children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var {\n        reverse = false\n      } = options;\n      var ancestor = Node.ancestor(root, path);\n      var {\n        children\n      } = ancestor;\n      var index = reverse ? children.length - 1 : 0;\n      while (reverse ? index >= 0 : index < children.length) {\n        var child = Node.child(ancestor, index);\n        var childPath = path.concat(index);\n        yield [child, childPath];\n        index = reverse ? index - 1 : index + 1;\n      }\n    }();\n  },\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n  descendant(root, path) {\n    var node = Node.get(root, path);\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (path.length !== 0) {\n          // NOTE: we have to coerce here because checking the path's length does\n          // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n          yield [node, path];\n        }\n      }\n    }();\n  },\n  elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (Element.isElement(node)) {\n          yield [node, path];\n        }\n      }\n    }();\n  },\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$3);\n      return properties;\n    }\n  },\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n    return [n, p];\n  },\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n    var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n  get(root, path) {\n    var node = Node.getIf(root, path);\n    if (node === undefined) {\n      throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n    }\n    return node;\n  },\n  getIf(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return;\n      }\n      node = node.children[p];\n    }\n    return node;\n  },\n  has(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n      node = node.children[p];\n    }\n    return true;\n  },\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n    return [n, p];\n  },\n  leaf(root, path) {\n    var node = Node.get(root, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      for (var p of Path.levels(path, options)) {\n        var n = Node.get(root, p);\n        yield [n, p];\n      }\n    }();\n  },\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n  nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var {\n        pass,\n        reverse = false\n      } = options;\n      var {\n        from = [],\n        to\n      } = options;\n      var visited = new Set();\n      var p = [];\n      var n = root;\n      while (true) {\n        if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n          break;\n        }\n        if (!visited.has(n)) {\n          yield [n, p];\n        }\n        // If we're allowed to go downward and we haven't descended yet, do.\n        if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n          visited.add(n);\n          var nextIndex = reverse ? n.children.length - 1 : 0;\n          if (Path.isAncestor(p, from)) {\n            nextIndex = from[p.length];\n          }\n          p = p.concat(nextIndex);\n          n = Node.get(root, p);\n          continue;\n        }\n        // If we're at the root and we can't go down, we're done.\n        if (p.length === 0) {\n          break;\n        }\n        // If we're going forward...\n        if (!reverse) {\n          var newPath = Path.next(p);\n          if (Node.has(root, newPath)) {\n            p = newPath;\n            n = Node.get(root, p);\n            continue;\n          }\n        }\n        // If we're going backward...\n        if (reverse && p[p.length - 1] !== 0) {\n          var _newPath = Path.previous(p);\n          p = _newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n        // Otherwise we're going upward...\n        p = Path.parent(p);\n        n = Node.get(root, p);\n        visited.add(n);\n      }\n    }();\n  },\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n    return p;\n  },\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n  texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (Text.isText(node)) {\n          yield [node, path];\n        }\n      }\n    }();\n  }\n};\n\nfunction ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n  isOperation(value) {\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n      return false;\n    }\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'set_node':\n        return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n      default:\n        return false;\n    }\n  },\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n      case 'insert_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n      case 'merge_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op;\n          // PERF: in this case the move operation is a no-op anyways.\n          if (Path.equals(newPath, path)) {\n            return op;\n          }\n          // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          }\n          // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n      case 'remove_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n      case 'remove_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n          if (_properties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n      case 'split_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = value => {\n  var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n  if (cachedIsEditor !== undefined) {\n    return cachedIsEditor;\n  }\n  if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n    return false;\n  }\n  var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  IS_EDITOR_CACHE.set(value, isEditor);\n  return isEditor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n  above(editor, options) {\n    return editor.above(options);\n  },\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n  after(editor, at, options) {\n    return editor.after(at, options);\n  },\n  before(editor, at, options) {\n    return editor.before(at, options);\n  },\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n  deleteFragment(editor, options) {\n    editor.deleteFragment(options);\n  },\n  edges(editor, at) {\n    return editor.edges(at);\n  },\n  elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return editor.elementReadOnly(options);\n  },\n  end(editor, at) {\n    return editor.end(at);\n  },\n  first(editor, at) {\n    return editor.first(at);\n  },\n  fragment(editor, at) {\n    return editor.fragment(at);\n  },\n  hasBlocks(editor, element) {\n    return editor.hasBlocks(element);\n  },\n  hasInlines(editor, element) {\n    return editor.hasInlines(element);\n  },\n  hasPath(editor, path) {\n    return editor.hasPath(path);\n  },\n  hasTexts(editor, element) {\n    return editor.hasTexts(element);\n  },\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n  isBlock(editor, value) {\n    return editor.isBlock(value);\n  },\n  isEdge(editor, point, at) {\n    return editor.isEdge(point, at);\n  },\n  isEditor(value) {\n    return isEditor(value);\n  },\n  isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element);\n  },\n  isEmpty(editor, element) {\n    return editor.isEmpty(element);\n  },\n  isEnd(editor, point, at) {\n    return editor.isEnd(point, at);\n  },\n  isInline(editor, value) {\n    return editor.isInline(value);\n  },\n  isNormalizing(editor) {\n    return editor.isNormalizing();\n  },\n  isSelectable(editor, value) {\n    return editor.isSelectable(value);\n  },\n  isStart(editor, point, at) {\n    return editor.isStart(point, at);\n  },\n  isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n  last(editor, at) {\n    return editor.last(at);\n  },\n  leaf(editor, at, options) {\n    return editor.leaf(at, options);\n  },\n  levels(editor, options) {\n    return editor.levels(options);\n  },\n  marks(editor) {\n    return editor.getMarks();\n  },\n  next(editor, options) {\n    return editor.next(options);\n  },\n  node(editor, at, options) {\n    return editor.node(at, options);\n  },\n  nodes(editor, options) {\n    return editor.nodes(options);\n  },\n  normalize(editor, options) {\n    editor.normalize(options);\n  },\n  parent(editor, at, options) {\n    return editor.parent(at, options);\n  },\n  path(editor, at, options) {\n    return editor.path(at, options);\n  },\n  pathRef(editor, path, options) {\n    return editor.pathRef(path, options);\n  },\n  pathRefs(editor) {\n    return editor.pathRefs();\n  },\n  point(editor, at, options) {\n    return editor.point(at, options);\n  },\n  pointRef(editor, point, options) {\n    return editor.pointRef(point, options);\n  },\n  pointRefs(editor) {\n    return editor.pointRefs();\n  },\n  positions(editor, options) {\n    return editor.positions(options);\n  },\n  previous(editor, options) {\n    return editor.previous(options);\n  },\n  range(editor, at, to) {\n    return editor.range(at, to);\n  },\n  rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options);\n  },\n  rangeRefs(editor) {\n    return editor.rangeRefs();\n  },\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n  setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing);\n  },\n  start(editor, at) {\n    return editor.start(at);\n  },\n  string(editor, at, options) {\n    return editor.string(at, options);\n  },\n  unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options);\n  },\n  void(editor, options) {\n    return editor.void(options);\n  },\n  withoutNormalizing(editor, fn) {\n    editor.withoutNormalizing(fn);\n  },\n  shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode) => {\n    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Location = {\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nfunction ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Point = {\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n    return result;\n  },\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n  isPoint(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, p => {\n      if (p === null) {\n        return null;\n      }\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n            break;\n          }\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n            break;\n          }\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n            break;\n          }\n      }\n    });\n  }\n};\n\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */\n// eslint-disable-next-line no-redeclare\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\nvar _excluded$2 = [\"text\"],\n  _excluded2$2 = [\"anchor\", \"focus\"];\nfunction ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Text = {\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$2);\n      return rest;\n    }\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n  isText(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === 'string';\n  },\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$a({}, node)];\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$2);\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length;\n        // If the range encompasses the entire leaf, add the range.\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        }\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        }\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n          before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n        Object.assign(middle, rest);\n        if (before) {\n          next.push(before);\n        }\n        next.push(middle);\n        if (after) {\n          next.push(after);\n        }\n      }\n      leaves = next;\n    }\n    return leaves;\n  }\n};\n\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */\nvar getDefaultInsertLocation = editor => {\n  if (editor.selection) {\n    return editor.selection;\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, []);\n  } else {\n    return [0];\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0;\n  // Evaluation of these conditions are deferred.\n  var gb11 = null; // Is GB11 applicable?\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n      if (!gb11) break;\n    }\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n      if (!gb12Or13) break;\n    }\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n    distance += char.length;\n  }\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n    text = remaining;\n  }\n  return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (SPACE.test(char)) {\n    return false;\n  }\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n  return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n    yield char1;\n  }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n  return type;\n};\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],\n// GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n// GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T],\n// GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n// GB9a\n[CodepointType.Any, CodepointType.SpacingMark],\n// GB9b\n[CodepointType.Prepend, CodepointType.Any],\n// GB11\n[CodepointType.ZWJ, CodepointType.ExtPict],\n// GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n  delete(editor, options) {\n    editor.delete(options);\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = getDefaultInsertLocation(editor)\n      } = options;\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n      if (!voids && Editor.void(editor, {\n        at\n      }) || Editor.elementReadOnly(editor, {\n        at\n      })) {\n        return;\n      }\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n};\n\nfunction ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n// perf\nvar BATCHING_DIRTY_PATHS = new WeakMap();\nvar isBatchingDirtyPaths = editor => {\n  return BATCHING_DIRTY_PATHS.get(editor) || false;\n};\nvar batchDirtyPaths = (editor, fn, update) => {\n  var value = BATCHING_DIRTY_PATHS.get(editor) || false;\n  BATCHING_DIRTY_PATHS.set(editor, true);\n  try {\n    fn();\n    update();\n  } finally {\n    BATCHING_DIRTY_PATHS.set(editor, value);\n  }\n};\n\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */\nfunction updateDirtyPaths(editor, newDirtyPaths, transform) {\n  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n  var dirtyPaths;\n  var dirtyPathKeys;\n  var add = path => {\n    if (path) {\n      var key = path.join(',');\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key);\n        dirtyPaths.push(path);\n      }\n    }\n  };\n  if (transform) {\n    dirtyPaths = [];\n    dirtyPathKeys = new Set();\n    for (var path of oldDirtyPaths) {\n      var newPath = transform(path);\n      add(newPath);\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths;\n    dirtyPathKeys = oldDirtyPathKeys;\n  }\n  for (var _path of newDirtyPaths) {\n    add(_path);\n  }\n  DIRTY_PATHS.set(editor, dirtyPaths);\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n}\n\nvar apply = (editor, op) => {\n  for (var ref of Editor.pathRefs(editor)) {\n    PathRef.transform(ref, op);\n  }\n  for (var _ref of Editor.pointRefs(editor)) {\n    PointRef.transform(_ref, op);\n  }\n  for (var _ref2 of Editor.rangeRefs(editor)) {\n    RangeRef.transform(_ref2, op);\n  }\n  // update dirty paths\n  if (!isBatchingDirtyPaths(editor)) {\n    var transform = Path.operationCanTransformPath(op) ? p => Path.transform(p, op) : undefined;\n    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);\n  }\n  Transforms.transform(editor, op);\n  editor.operations.push(op);\n  Editor.normalize(editor, {\n    operation: op\n  });\n  // Clear any formats applied to the cursor if the selection changes.\n  if (op.type === 'set_selection') {\n    editor.marks = null;\n  }\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true);\n    Promise.resolve().then(() => {\n      FLUSHING.set(editor, false);\n      editor.onChange({\n        operation: op\n      });\n      editor.operations = [];\n    });\n  }\n};\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\nvar getDirtyPaths = (editor, op) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path\n        } = op;\n        var levels = Path.levels(_path);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref => {\n          var [, p] = _ref;\n          return _path.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n        var ancestors = Path.ancestors(_path2);\n        var previousPath = Path.previous(_path2);\n        return [...ancestors, previousPath];\n      }\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n        if (Path.equals(_path3, newPath)) {\n          return [];\n        }\n        var oldAncestors = [];\n        var newAncestors = [];\n        for (var ancestor of Path.ancestors(_path3)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n          newAncestors.push(_p);\n        }\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _ancestors = Path.ancestors(_path4);\n        return [..._ancestors];\n      }\n    case 'split_node':\n      {\n        var {\n          path: _path5\n        } = op;\n        var _levels = Path.levels(_path5);\n        var nextPath = Path.next(_path5);\n        return [..._levels, nextPath];\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar getFragment = editor => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    return Node.fragment(editor, selection);\n  }\n  return [];\n};\n\nvar normalizeNode = (editor, entry) => {\n  var [node, path] = entry;\n  // There are no core normalizations for text nodes.\n  if (Text.isText(node)) {\n    return;\n  }\n  // Ensure that block and inline nodes have at least one text child.\n  if (Element.isElement(node) && node.children.length === 0) {\n    var child = {\n      text: ''\n    };\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true\n    });\n    return;\n  }\n  // Determine whether the node should have block or inline children.\n  var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n  // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n  var n = 0;\n  for (var i = 0; i < node.children.length; i++, n++) {\n    var currentNode = Node.get(editor, path);\n    if (Text.isText(currentNode)) continue;\n    var _child = currentNode.children[n];\n    var prev = currentNode.children[n - 1];\n    var isLast = i === node.children.length - 1;\n    var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n    // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n    if (isInlineOrText !== shouldHaveInlines) {\n      Transforms.removeNodes(editor, {\n        at: path.concat(n),\n        voids: true\n      });\n      n--;\n    } else if (Element.isElement(_child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(_child)) {\n        if (prev == null || !Text.isText(prev)) {\n          var newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true\n          });\n          n++;\n        } else if (isLast) {\n          var _newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, _newChild, {\n            at: path.concat(n + 1),\n            voids: true\n          });\n          n++;\n        }\n      }\n    } else {\n      // If the child is not a text node, and doesn't have a `children` field,\n      // then we have an invalid node that will upset slate.\n      //\n      // eg: `{ type: 'some_node' }`.\n      //\n      // To prevent slate from breaking, we can add the `children` field,\n      // and now that it is valid, we can to many more operations easily,\n      // such as extend normalizers to fix erronous structure.\n      if (!Text.isText(_child) && !('children' in _child)) {\n        var elementChild = _child;\n        elementChild.children = [];\n      }\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(_child, prev, {\n          loose: true\n        })) {\n          Transforms.mergeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true\n          });\n          n--;\n        } else if (_child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        }\n      }\n    }\n  }\n};\n\nvar shouldNormalize = (editor, _ref) => {\n  var {\n    iteration,\n    initialDirtyPathsLength\n  } = _ref;\n  var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n  if (iteration > maxIterations) {\n    throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n  }\n  return true;\n};\n\nvar above = function above(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    voids = false,\n    mode = 'lowest',\n    at = editor.selection,\n    match\n  } = options;\n  if (!at) {\n    return;\n  }\n  var path = Editor.path(editor, at);\n  var reverse = mode === 'lowest';\n  for (var [n, p] of Editor.levels(editor, {\n    at: path,\n    voids,\n    match,\n    reverse\n  })) {\n    if (Text.isText(n)) continue;\n    if (Range.isRange(at)) {\n      if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n        return [n, p];\n      }\n    } else {\n      if (!Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  }\n};\n\nfunction ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar addMark = (editor, key, value) => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor, {\n        [key]: value\n      }, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n        [key]: value\n      });\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar after = function after(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var focus = Editor.end(editor, []);\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n  for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n    at: range\n  }))) {\n    if (d > distance) {\n      break;\n    }\n    if (d !== 0) {\n      target = p;\n    }\n    d++;\n  }\n  return target;\n};\n\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar before = function before(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.start(editor, []);\n  var focus = Editor.point(editor, at, {\n    edge: 'start'\n  });\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n  for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n    at: range,\n    reverse: true\n  }))) {\n    if (d > distance) {\n      break;\n    }\n    if (d !== 0) {\n      target = p;\n    }\n    d++;\n  }\n  return target;\n};\n\nvar deleteBackward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit,\n      reverse: true\n    });\n  }\n};\n\nvar deleteForward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit\n    });\n  }\n};\n\nvar deleteFragment = function deleteFragment(editor) {\n  var {\n    direction = 'forward'\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isExpanded(selection)) {\n    Transforms.delete(editor, {\n      reverse: direction === 'backward'\n    });\n  }\n};\n\nvar edges = (editor, at) => {\n  return [Editor.start(editor, at), Editor.end(editor, at)];\n};\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar elementReadOnly = function elementReadOnly(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n  }));\n};\n\nvar end = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'end'\n  });\n};\n\nvar first = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'start'\n  });\n  return Editor.node(editor, path);\n};\n\nvar fragment = (editor, at) => {\n  var range = Editor.range(editor, at);\n  return Node.fragment(editor, range);\n};\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar getVoid = function getVoid(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isVoid(editor, n)\n  }));\n};\n\nvar hasBlocks = (editor, element) => {\n  return element.children.some(n => Element.isElement(n) && Editor.isBlock(editor, n));\n};\n\nvar hasInlines = (editor, element) => {\n  return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n};\n\nvar hasPath = (editor, path) => {\n  return Node.has(editor, path);\n};\n\nvar hasTexts = (editor, element) => {\n  return element.children.every(n => Text.isText(n));\n};\n\nvar insertBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nvar insertNode = (editor, node, options) => {\n  Transforms.insertNodes(editor, node, options);\n};\n\nvar insertSoftBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar insertText = function insertText(editor, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection,\n    marks\n  } = editor;\n  if (selection) {\n    if (marks) {\n      var node = _objectSpread$3({\n        text\n      }, marks);\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids\n      });\n    } else {\n      Transforms.insertText(editor, text, options);\n    }\n    editor.marks = null;\n  }\n};\n\nvar isBlock = (editor, value) => {\n  return !editor.isInline(value);\n};\n\nvar isEdge = (editor, point, at) => {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\n\nvar isEmpty = (editor, element) => {\n  var {\n    children\n  } = element;\n  var [first] = children;\n  return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n};\n\nvar isEnd = (editor, point, at) => {\n  var end = Editor.end(editor, at);\n  return Point.equals(point, end);\n};\n\nvar isNormalizing = editor => {\n  var isNormalizing = NORMALIZING.get(editor);\n  return isNormalizing === undefined ? true : isNormalizing;\n};\n\nvar isStart = (editor, point, at) => {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false;\n  }\n  var start = Editor.start(editor, at);\n  return Point.equals(point, start);\n};\n\nvar last = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'end'\n  });\n  return Editor.node(editor, path);\n};\n\nvar leaf = function leaf(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.leaf(editor, path);\n  return [node, path];\n};\n\nfunction levels(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (match == null) {\n      match = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n      levels.push([n, p]);\n      if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n    if (reverse) {\n      levels.reverse();\n    }\n    yield* levels;\n  }();\n}\n\nvar _excluded$1 = [\"text\"],\n  _excluded2$1 = [\"text\"];\nvar marks = function marks(editor) {\n  var {\n    marks,\n    selection\n  } = editor;\n  if (!selection) {\n    return null;\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  if (marks) {\n    return marks;\n  }\n  if (Range.isExpanded(selection)) {\n    var isBackward = Range.isBackward(selection);\n    if (isBackward) {\n      [focus, anchor] = [anchor, focus];\n    }\n    /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */\n    var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n    if (isEnd) {\n      var after = Editor.after(editor, anchor);\n      if (after) {\n        anchor = after;\n      }\n    }\n    var [match] = Editor.nodes(editor, {\n      match: Text.isText,\n      at: {\n        anchor,\n        focus\n      }\n    });\n    if (match) {\n      var [_node] = match;\n      var _rest = _objectWithoutProperties(_node, _excluded$1);\n      return _rest;\n    } else {\n      return {};\n    }\n  }\n  var {\n    path\n  } = anchor;\n  var [node] = Editor.leaf(editor, path);\n  if (anchor.offset === 0) {\n    var prev = Editor.previous(editor, {\n      at: path,\n      match: Text.isText\n    });\n    var markedVoid = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n    });\n    if (!markedVoid) {\n      var block = Editor.above(editor, {\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n      });\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n  }\n  var rest = _objectWithoutProperties(node, _excluded2$1);\n  return rest;\n};\n\nvar next = function next(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n  if (!at) {\n    return;\n  }\n  var pointAfterLocation = Editor.after(editor, at, {\n    voids\n  });\n  if (!pointAfterLocation) return;\n  var [, to] = Editor.last(editor, []);\n  var span = [pointAfterLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the next node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n  var [next] = Editor.nodes(editor, {\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return next;\n};\n\nvar node = function node(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.get(editor, path);\n  return [node, path];\n};\n\nfunction nodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n      ignoreNonSelectable = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (!match) {\n      match = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [node] = _ref;\n        if (!Element.isElement(node)) return false;\n        if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n        if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n        return false;\n      }\n    });\n    var matches = [];\n    var hit;\n    for (var [node, path] of nodeEntries) {\n      if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n        continue;\n      }\n      var isLower = hit && Path.compare(path, hit[1]) === 0;\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      }\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      }\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      var emit = mode === 'lowest' ? hit : [node, path];\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n      hit = [node, path];\n    }\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    }\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches;\n    }\n  }();\n}\n\nvar normalize = function normalize(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    force = false,\n    operation\n  } = options;\n  var getDirtyPaths = editor => {\n    return DIRTY_PATHS.get(editor) || [];\n  };\n  var getDirtyPathKeys = editor => {\n    return DIRTY_PATH_KEYS.get(editor) || new Set();\n  };\n  var popDirtyPath = editor => {\n    var path = getDirtyPaths(editor).pop();\n    var key = path.join(',');\n    getDirtyPathKeys(editor).delete(key);\n    return path;\n  };\n  if (!Editor.isNormalizing(editor)) {\n    return;\n  }\n  if (force) {\n    var allPaths = Array.from(Node.nodes(editor), _ref => {\n      var [, p] = _ref;\n      return p;\n    });\n    var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n    DIRTY_PATHS.set(editor, allPaths);\n    DIRTY_PATH_KEYS.set(editor, allPathKeys);\n  }\n  if (getDirtyPaths(editor).length === 0) {\n    return;\n  }\n  Editor.withoutNormalizing(editor, () => {\n    /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */\n    for (var dirtyPath of getDirtyPaths(editor)) {\n      if (Node.has(editor, dirtyPath)) {\n        var entry = Editor.node(editor, dirtyPath);\n        var [node, _] = entry;\n        /*\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\n          So there is some risk here.\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n          by definition adding children to an empty node can't cause other paths to change.\n        */\n        if (Element.isElement(node) && node.children.length === 0) {\n          editor.normalizeNode(entry, {\n            operation\n          });\n        }\n      }\n    }\n    var dirtyPaths = getDirtyPaths(editor);\n    var initialDirtyPathsLength = dirtyPaths.length;\n    var iteration = 0;\n    while (dirtyPaths.length !== 0) {\n      if (!editor.shouldNormalize({\n        dirtyPaths,\n        iteration,\n        initialDirtyPathsLength,\n        operation\n      })) {\n        return;\n      }\n      var _dirtyPath = popDirtyPath(editor);\n      // If the node doesn't exist in the tree, it does not need to be normalized.\n      if (Node.has(editor, _dirtyPath)) {\n        var _entry = Editor.node(editor, _dirtyPath);\n        editor.normalizeNode(_entry, {\n          operation\n        });\n      }\n      iteration++;\n      dirtyPaths = getDirtyPaths(editor);\n    }\n  });\n};\n\nvar parent = function parent(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var parentPath = Path.parent(path);\n  var entry = Editor.node(editor, parentPath);\n  return entry;\n};\n\nvar pathRef = function pathRef(editor, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: path,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var pathRefs = Editor.pathRefs(editor);\n      pathRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pathRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pathRefs = editor => {\n  var refs = PATH_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    PATH_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar path = function path(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    depth,\n    edge\n  } = options;\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      var [, firstPath] = Node.first(editor, at);\n      at = firstPath;\n    } else if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      at = lastPath;\n    }\n  }\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at);\n    } else if (edge === 'end') {\n      at = Range.end(at);\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path);\n    }\n  }\n  if (Point.isPoint(at)) {\n    at = at.path;\n  }\n  if (depth != null) {\n    at = at.slice(0, depth);\n  }\n  return at;\n};\n\nvar pointRef = function pointRef(editor, point) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: point,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var pointRefs = Editor.pointRefs(editor);\n      pointRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pointRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pointRefs = editor => {\n  var refs = POINT_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    POINT_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar point = function point(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    edge = 'start'\n  } = options;\n  if (Path.isPath(at)) {\n    var path;\n    if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      path = lastPath;\n    } else {\n      var [, firstPath] = Node.first(editor, at);\n      path = firstPath;\n    }\n    var node = Node.get(editor, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n    }\n    return {\n      path,\n      offset: edge === 'end' ? node.text.length : 0\n    };\n  }\n  if (Range.isRange(at)) {\n    var [start, end] = Range.edges(at);\n    return edge === 'start' ? start : end;\n  }\n  return at;\n};\n\nfunction positions(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false,\n      ignoreNonSelectable = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0;\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids,\n      ignoreNonSelectable\n    })) {\n      /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n          yield Editor.start(editor, path);\n          continue;\n        }\n        // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n        if (editor.isInline(node)) continue;\n        // Block element node - set `blockText` to its text content.\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          blockText = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          }, {\n            voids\n          });\n          isNewBlock = true;\n        }\n      }\n      /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path);\n        // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n        // Reset `leafText` counters for new text node.\n        if (isFirst) {\n          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n          leafTextOffset = first.offset; // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length;\n          leafTextOffset = reverse ? leafTextRemaining : 0;\n        }\n        // Yield position at the start of node (potentially).\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n          isNewBlock = false;\n        }\n        // Yield positions every (dynamically calculated) `distance` offset.\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break;\n            distance = calcDistance(blockText, unit, reverse);\n            // Split the string at the previously found distance and use the\n            // remaining string for the next iteration.\n            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n          }\n          // Advance `leafText` by the current `distance`.\n          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n          leafTextRemaining = leafTextRemaining - distance;\n          // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining;\n            break;\n          }\n          // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n          distance = 0;\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n        }\n      }\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n      return 1;\n    }\n  }();\n}\n\nvar previous = function previous(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n  if (!at) {\n    return;\n  }\n  var pointBeforeLocation = Editor.before(editor, at, {\n    voids\n  });\n  if (!pointBeforeLocation) {\n    return;\n  }\n  var [, to] = Editor.first(editor, []);\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  var span = [pointBeforeLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the previous node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n  var [previous] = Editor.nodes(editor, {\n    reverse: true,\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return previous;\n};\n\nvar rangeRef = function rangeRef(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: range,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var rangeRefs = Editor.rangeRefs(editor);\n      rangeRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.rangeRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar rangeRefs = editor => {\n  var refs = RANGE_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    RANGE_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar range = (editor, at, to) => {\n  if (Range.isRange(at) && !to) {\n    return at;\n  }\n  var start = Editor.start(editor, at);\n  var end = Editor.end(editor, to || at);\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar removeMark = (editor, key) => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n      delete marks[key];\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nvar setNormalizing = (editor, isNormalizing) => {\n  NORMALIZING.set(editor, isNormalizing);\n};\n\nvar start = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'start'\n  });\n};\n\nvar string = function string(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var range = Editor.range(editor, at);\n  var [start, end] = Range.edges(range);\n  var text = '';\n  for (var [node, path] of Editor.nodes(editor, {\n    at: range,\n    match: Text.isText,\n    voids\n  })) {\n    var t = node.text;\n    if (Path.equals(path, end.path)) {\n      t = t.slice(0, end.offset);\n    }\n    if (Path.equals(path, start.path)) {\n      t = t.slice(start.offset);\n    }\n    text += t;\n  }\n  return text;\n};\n\nvar unhangRange = function unhangRange(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var [start, end] = Range.edges(range);\n  // PERF: exit early if we can guarantee that the range isn't hanging.\n  if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n    return range;\n  }\n  var endBlock = Editor.above(editor, {\n    at: end,\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    voids\n  });\n  var blockPath = endBlock ? endBlock[1] : [];\n  var first = Editor.start(editor, start);\n  var before = {\n    anchor: first,\n    focus: end\n  };\n  var skip = true;\n  for (var [node, path] of Editor.nodes(editor, {\n    at: before,\n    match: Text.isText,\n    reverse: true,\n    voids\n  })) {\n    if (skip) {\n      skip = false;\n      continue;\n    }\n    if (node.text !== '' || Path.isBefore(path, blockPath)) {\n      end = {\n        path,\n        offset: node.text.length\n      };\n      break;\n    }\n  }\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nvar withoutNormalizing = (editor, fn) => {\n  var value = Editor.isNormalizing(editor);\n  Editor.setNormalizing(editor, false);\n  try {\n    fn();\n  } finally {\n    Editor.setNormalizing(editor, value);\n  }\n  Editor.normalize(editor);\n};\n\nvar shouldMergeNodesRemovePrevNode = (editor, _ref, _ref2) => {\n  var [prevNode, prevPath] = _ref;\n  // If the target node that we're merging with is empty, remove it instead\n  // of merging the two. This is a common rich text editor behavior to\n  // prevent losing formatting when deleting entire nodes when you have a\n  // hanging selection.\n  // if prevNode is first child in parent,don't remove it.\n  return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0;\n};\n\nvar deleteText = function deleteText(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var _Editor$void, _Editor$void2;\n    var {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      hanging = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    var isCollapsed = false;\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      if (!voids && furthestVoid) {\n        var [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        var opts = {\n          unit,\n          distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at,\n        voids\n      });\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      var [, _end] = Range.edges(at);\n      var endOfDoc = Editor.end(editor, []);\n      if (!Point.equals(_end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n    }\n    var [start, end] = Range.edges(at);\n    var startBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: start,\n      voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: end,\n      voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n      at: start,\n      mode: 'highest'\n    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n      at: end,\n      mode: 'highest'\n    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n      at: end,\n      mode: 'highest'\n    });\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      var before = Editor.before(editor, start);\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endNonEditable) {\n      var after = Editor.after(editor, end);\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    var matches = [];\n    var lastPath;\n    for (var entry of Editor.nodes(editor, {\n      at,\n      voids\n    })) {\n      var [node, path] = entry;\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n    var removedText = '';\n    if (!isSingleText && !startNonEditable) {\n      var _point = startRef.current;\n      var [_node] = Editor.leaf(editor, _point);\n      var {\n        path: _path\n      } = _point;\n      var {\n        offset\n      } = start;\n      var text = _node.text.slice(offset);\n      if (text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset,\n          text\n        });\n        removedText = text;\n      }\n    }\n    pathRefs.reverse().map(r => r.unref()).filter(r => r !== null).forEach(p => Transforms.removeNodes(editor, {\n      at: p,\n      voids\n    }));\n    if (!endNonEditable) {\n      var _point2 = endRef.current;\n      var [_node2] = Editor.leaf(editor, _point2);\n      var {\n        path: _path2\n      } = _point2;\n      var _offset = isSingleText ? start.offset : 0;\n      var _text = _node2.text.slice(_offset, end.offset);\n      if (_text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path2,\n          offset: _offset,\n          text: _text\n        });\n        removedText = _text;\n      }\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids\n      });\n    }\n    // For Thai script, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n    }\n    var startUnref = startRef.unref();\n    var endUnref = endRef.unref();\n    var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(editor, fragment) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false\n    } = options;\n    var {\n      at = getDefaultInsertLocation(editor),\n      batchDirty = true\n    } = options;\n    if (!fragment.length) {\n      return;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        if (!voids && Editor.void(editor, {\n          at: end\n        })) {\n          return;\n        }\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at);\n    }\n    if (!voids && Editor.void(editor, {\n      at\n    })) {\n      return;\n    }\n    // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n    var inlineElementMatch = Editor.above(editor, {\n      at,\n      match: n => Element.isElement(n) && Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    if (inlineElementMatch) {\n      var [, _inlinePath] = inlineElementMatch;\n      if (Editor.isEnd(editor, at, _inlinePath)) {\n        var after = Editor.after(editor, _inlinePath);\n        at = after;\n      } else if (Editor.isStart(editor, at, _inlinePath)) {\n        var before = Editor.before(editor, _inlinePath);\n        at = before;\n      }\n    }\n    var blockMatch = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at,\n      voids\n    });\n    var [, blockPath] = blockMatch;\n    var isBlockStart = Editor.isStart(editor, at, blockPath);\n    var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n    var isBlockEmpty = isBlockStart && isBlockEnd;\n    var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n    var mergeEnd = !isBlockEnd;\n    var [, firstPath] = Node.first({\n      children: fragment\n    }, []);\n    var [, lastPath] = Node.last({\n      children: fragment\n    }, []);\n    var matches = [];\n    var matcher = _ref => {\n      var [n, p] = _ref;\n      var isRoot = p.length === 0;\n      if (isRoot) {\n        return false;\n      }\n      if (isBlockEmpty) {\n        return true;\n      }\n      if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      return true;\n    };\n    for (var entry of Node.nodes({\n      children: fragment\n    }, {\n      pass: matcher\n    })) {\n      if (matcher(entry)) {\n        matches.push(entry);\n      }\n    }\n    var starts = [];\n    var middles = [];\n    var ends = [];\n    var starting = true;\n    var hasBlocks = false;\n    for (var [node] of matches) {\n      if (Element.isElement(node) && !editor.isInline(node)) {\n        starting = false;\n        hasBlocks = true;\n        middles.push(node);\n      } else if (starting) {\n        starts.push(node);\n      } else {\n        ends.push(node);\n      }\n    }\n    var [inlineMatch] = Editor.nodes(editor, {\n      at,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    var [, inlinePath] = inlineMatch;\n    var isInlineStart = Editor.isStart(editor, at, inlinePath);\n    var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.splitNodes(editor, {\n      at,\n      match: n => hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n      mode: hasBlocks ? 'lowest' : 'highest',\n      always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n      voids\n    });\n    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty\n    });\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms.delete(editor, {\n        at: blockPath,\n        voids\n      });\n    }\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      mode: 'lowest',\n      voids,\n      batchDirty\n    });\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty\n    });\n    if (!options.at) {\n      var path;\n      if (ends.length > 0 && endRef.current) {\n        path = Path.previous(endRef.current);\n      } else if (middles.length > 0 && middleRef.current) {\n        path = Path.previous(middleRef.current);\n      } else if (startRef.current) {\n        path = Path.previous(startRef.current);\n      }\n      if (path) {\n        var _end = Editor.end(editor, path);\n        Transforms.select(editor, _end);\n      }\n    }\n    startRef.unref();\n    middleRef.unref();\n    endRef.unref();\n  });\n};\n\nvar collapse = function collapse(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    edge = 'anchor'\n  } = options;\n  var {\n    selection\n  } = editor;\n  if (!selection) {\n    return;\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor);\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus);\n  } else if (edge === 'start') {\n    var [start] = Range.edges(selection);\n    Transforms.select(editor, start);\n  } else if (edge === 'end') {\n    var [, end] = Range.edges(selection);\n    Transforms.select(editor, end);\n  }\n};\n\nvar deselect = editor => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null\n    });\n  }\n};\n\nvar move = function move(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    distance = 1,\n    unit = 'character',\n    reverse = false\n  } = options;\n  var {\n    edge = null\n  } = options;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  var opts = {\n    distance,\n    unit,\n    ignoreNonSelectable: true\n  };\n  var props = {};\n  if (edge == null || edge === 'anchor') {\n    var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n    if (point) {\n      props.anchor = point;\n    }\n  }\n  if (edge == null || edge === 'focus') {\n    var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n    if (_point) {\n      props.focus = _point;\n    }\n  }\n  Transforms.setSelection(editor, props);\n};\n\nvar select = (editor, target) => {\n  var {\n    selection\n  } = editor;\n  target = Editor.range(editor, target);\n  if (selection) {\n    Transforms.setSelection(editor, target);\n    return;\n  }\n  if (!Range.isRange(target)) {\n    throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n  }\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target\n  });\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar setPoint = function setPoint(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    edge = 'both'\n  } = options;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  var point = edge === 'anchor' ? anchor : focus;\n  Transforms.setSelection(editor, {\n    [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n  });\n};\n\nvar setSelection = (editor, props) => {\n  var {\n    selection\n  } = editor;\n  var oldProps = {};\n  var newProps = {};\n  if (!selection) {\n    return;\n  }\n  for (var k in props) {\n    if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n      oldProps[k] = selection[k];\n      newProps[k] = props[k];\n    }\n  }\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps\n    });\n  }\n};\n\nvar insertNodes = function insertNodes(editor, nodes) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n      batchDirty = true\n    } = options;\n    var {\n      at,\n      match,\n      select\n    } = options;\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    if (nodes.length === 0) {\n      return;\n    }\n    var [node] = nodes;\n    if (!at) {\n      at = getDefaultInsertLocation(editor);\n      if (select !== false) {\n        select = true;\n      }\n    }\n    if (select == null) {\n      select = false;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    }\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = n => Text.isText(n);\n        } else if (editor.isInline(node)) {\n          match = n => Text.isText(n) || Editor.isInline(editor, n);\n        } else {\n          match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      }\n      var [entry] = Editor.nodes(editor, {\n        at: at.path,\n        match,\n        mode,\n        voids\n      });\n      if (entry) {\n        var [, matchPath] = entry;\n        var pathRef = Editor.pathRef(editor, matchPath);\n        var isAtEnd = Editor.isEnd(editor, at, matchPath);\n        Transforms.splitNodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n        var path = pathRef.unref();\n        at = isAtEnd ? Path.next(path) : path;\n      } else {\n        return;\n      }\n    }\n    var parentPath = Path.parent(at);\n    var index = at[at.length - 1];\n    if (!voids && Editor.void(editor, {\n      at: parentPath\n    })) {\n      return;\n    }\n    if (batchDirty) {\n      // PERF: batch update dirty paths\n      // batched ops used to transform existing dirty paths\n      var batchedOps = [];\n      var newDirtyPaths = Path.levels(parentPath);\n      batchDirtyPaths(editor, () => {\n        var _loop = function _loop() {\n          var path = parentPath.concat(index);\n          index++;\n          var op = {\n            type: 'insert_node',\n            path,\n            node: _node\n          };\n          editor.apply(op);\n          at = Path.next(at);\n          batchedOps.push(op);\n          if (!Text.isText) {\n            newDirtyPaths.push(path);\n          } else {\n            newDirtyPaths.push(...Array.from(Node.nodes(_node), _ref => {\n              var [, p] = _ref;\n              return path.concat(p);\n            }));\n          }\n        };\n        for (var _node of nodes) {\n          _loop();\n        }\n      }, () => {\n        updateDirtyPaths(editor, newDirtyPaths, p => {\n          var newPath = p;\n          for (var op of batchedOps) {\n            if (Path.operationCanTransformPath(op)) {\n              newPath = Path.transform(newPath, op);\n              if (!newPath) {\n                return null;\n              }\n            }\n          }\n          return newPath;\n        });\n      });\n    } else {\n      for (var _node2 of nodes) {\n        var _path = parentPath.concat(index);\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node2\n        });\n        at = Path.next(at);\n      }\n    }\n    at = Path.previous(at);\n    if (select) {\n      var point = Editor.end(editor, at);\n      if (point) {\n        Transforms.select(editor, point);\n      }\n    }\n  });\n};\n\nvar liftNodes = function liftNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!at) {\n      return;\n    }\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      if (path.length < 2) {\n        throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n      }\n      var parentNodeEntry = Editor.node(editor, Path.parent(path));\n      var [parent, parentPath] = parentNodeEntry;\n      var index = path[path.length - 1];\n      var {\n        length\n      } = parent.children;\n      if (length === 1) {\n        var toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: toPath,\n          voids\n        });\n        Transforms.removeNodes(editor, {\n          at: parentPath,\n          voids\n        });\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: parentPath,\n          voids\n        });\n      } else if (index === length - 1) {\n        var _toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath,\n          voids\n        });\n      } else {\n        var splitPath = Path.next(path);\n        var _toPath2 = Path.next(parentPath);\n        Transforms.splitNodes(editor, {\n          at: splitPath,\n          voids\n        });\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath2,\n          voids\n        });\n      }\n    }\n  });\n};\n\nvar _excluded = [\"text\"],\n  _excluded2 = [\"children\"];\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar mergeNodes = function mergeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n        match = n => parent.children.includes(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n    var [current] = Editor.nodes(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    var prev = Editor.previous(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    if (!current || !prev) {\n      return;\n    }\n    var [node, path] = current;\n    var [prevNode, prevPath] = prev;\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n    var newPath = Path.next(prevPath);\n    var commonPath = Path.common(path, prevPath);\n    var isPreviousSibling = Path.isSibling(path, prevPath);\n    var levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), _ref => {\n      var [n] = _ref;\n      return n;\n    }).slice(commonPath.length).slice(0, -1);\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    var emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n    });\n    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    var properties;\n    var position;\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded);\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded2);\n      position = prevNode.children.length;\n      properties = rest;\n    } else {\n      throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids\n      });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids\n      });\n    }\n    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n\nvar moveNodes = (editor, options) => {\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      to,\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    var toRef = Editor.pathRef(editor, to);\n    var targets = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(targets, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      var newPath = toRef.current;\n      if (path.length !== 0) {\n        editor.apply({\n          type: 'move_node',\n          path,\n          newPath\n        });\n      }\n      if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current);\n      }\n    }\n    toRef.unref();\n  });\n};\n\nvar removeNodes = function removeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    var depths = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(depths, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      if (path) {\n        var [node] = Editor.node(editor, path);\n        editor.apply({\n          type: 'remove_node',\n          path,\n          node\n        });\n      }\n    }\n  });\n};\n\nvar setNodes = function setNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection,\n      compare,\n      merge\n    } = options;\n    var {\n      hanging = false,\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    if (split && Range.isRange(at)) {\n      if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return;\n      }\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      var [start, end] = Range.edges(at);\n      var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n      var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        mode: splitMode,\n        voids,\n        always: !endAtEndOfNode\n      });\n      var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        mode: splitMode,\n        voids,\n        always: !startAtStartOfNode\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    if (!compare) {\n      compare = (prop, nodeProp) => prop !== nodeProp;\n    }\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    })) {\n      var properties = {};\n      // FIXME: is this correct?\n      var newProperties = {};\n      // You can't set properties on the editor node.\n      if (path.length === 0) {\n        continue;\n      }\n      var hasChanges = false;\n      for (var k in props) {\n        if (k === 'children' || k === 'text') {\n          continue;\n        }\n        if (compare(props[k], node[k])) {\n          hasChanges = true;\n          // Omit new properties from the old properties list\n          if (node.hasOwnProperty(k)) properties[k] = node[k];\n          // Omit properties that have been removed from the new properties list\n          if (merge) {\n            if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n          } else {\n            if (props[k] != null) newProperties[k] = props[k];\n          }\n        }\n      }\n      if (hasChanges) {\n        editor.apply({\n          type: 'set_node',\n          path,\n          properties,\n          newProperties\n        });\n      }\n    }\n  });\n};\n\n/**\n * Convert a range into a point by deleting it's content.\n */\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\nvar splitNodes = function splitNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection,\n      height = 0,\n      always = false\n    } = options;\n    if (match == null) {\n      match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at);\n    }\n    // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n    if (Path.isPath(at)) {\n      var path = at;\n      var point = Editor.point(editor, path);\n      var [parent] = Editor.parent(editor, path);\n      match = n => n === parent;\n      height = point.path.length - path.length + 1;\n      at = point;\n      always = true;\n    }\n    if (!at) {\n      return;\n    }\n    var beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward'\n    });\n    var afterRef;\n    try {\n      var [highest] = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      if (!highest) {\n        return;\n      }\n      var voidMatch = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n      if (!voids && voidMatch) {\n        var [voidNode, voidPath] = voidMatch;\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n          at = after;\n          always = true;\n        }\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n      afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var [, highestPath] = highest;\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      for (var [node, _path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids\n      })) {\n        var split = false;\n        if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n          break;\n        }\n        var _point = beforeRef.current;\n        var isEnd = Editor.isEnd(editor, _point, _path);\n        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n          split = true;\n          var properties = Node.extractProps(node);\n          editor.apply({\n            type: 'split_node',\n            path: _path,\n            position,\n            properties\n          });\n        }\n        position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n      }\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n        Transforms.select(editor, _point2);\n      }\n    } finally {\n      var _afterRef;\n      beforeRef.unref();\n      (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n    }\n  });\n};\n\nvar unsetNodes = function unsetNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!Array.isArray(props)) {\n    props = [props];\n  }\n  var obj = {};\n  for (var key of props) {\n    obj[key] = null;\n  }\n  Transforms.setNodes(editor, obj, options);\n};\n\nvar unwrapNodes = function unwrapNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at);\n    }\n    var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    }\n    // unwrapNode will call liftNode which does not support splitting the node when nested.\n    // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n    // that wrap target node. So we reverse the order.\n    ).reverse();\n    var _loop = function _loop() {\n      var path = pathRef.unref();\n      var [node] = Editor.node(editor, path);\n      var range = Editor.range(editor, path);\n      if (split && rangeRef) {\n        range = Range.intersection(rangeRef.current, range);\n      }\n      Transforms.liftNodes(editor, {\n        at: range,\n        match: n => Element.isAncestor(node) && node.children.includes(n),\n        voids\n      });\n    };\n    for (var pathRef of pathRefs) {\n      _loop();\n    }\n    if (rangeRef) {\n      rangeRef.unref();\n    }\n  });\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar wrapNodes = function wrapNodes(editor, element) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at);\n      } else if (editor.isInline(element)) {\n        match = n => Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n    if (split && Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        voids\n      });\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        voids\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    var roots = Array.from(Editor.nodes(editor, {\n      at,\n      match: editor.isInline(element) ? n => Element.isElement(n) && Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n      mode: 'lowest',\n      voids\n    }));\n    var _loop = function _loop() {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n        if (!a) {\n          return 0; // continue\n        }\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n        if (matches.length > 0) {\n          var [first] = matches;\n          var last = matches[matches.length - 1];\n          var [, firstPath] = first;\n          var [, lastPath] = last;\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            return 0; // continue\n          }\n          var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n          var range = Editor.range(editor, firstPath, lastPath);\n          var commonNodeEntry = Editor.node(editor, commonPath);\n          var [commonNode] = commonNodeEntry;\n          var depth = commonPath.length + 1;\n          var wrapperPath = Path.next(lastPath.slice(0, depth));\n          var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n            children: []\n          });\n          Transforms.insertNodes(editor, wrapper, {\n            at: wrapperPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids\n          });\n        }\n      },\n      _ret;\n    for (var [, rootPath] of roots) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n    }\n  });\n};\n\n/**\n * Create a new Slate `Editor` object.\n */\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: () => false,\n    isInline: () => false,\n    isSelectable: () => true,\n    isVoid: () => false,\n    markableVoid: () => false,\n    onChange: () => {},\n    // Core\n    apply: function apply$1() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return apply(editor, ...args);\n    },\n    // Editor\n    addMark: function addMark$1() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return addMark(editor, ...args);\n    },\n    deleteBackward: function deleteBackward$1() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return deleteBackward(editor, ...args);\n    },\n    deleteForward: function deleteForward$1() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return deleteForward(editor, ...args);\n    },\n    deleteFragment: function deleteFragment$1() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return deleteFragment(editor, ...args);\n    },\n    getFragment: function getFragment$1() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return getFragment(editor, ...args);\n    },\n    insertBreak: function insertBreak$1() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return insertBreak(editor, ...args);\n    },\n    insertSoftBreak: function insertSoftBreak$1() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return insertSoftBreak(editor, ...args);\n    },\n    insertFragment: function insertFragment$1() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return insertFragment(editor, ...args);\n    },\n    insertNode: function insertNode$1() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return insertNode(editor, ...args);\n    },\n    insertText: function insertText$1() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return insertText(editor, ...args);\n    },\n    normalizeNode: function normalizeNode$1() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return normalizeNode(editor, ...args);\n    },\n    removeMark: function removeMark$1() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return removeMark(editor, ...args);\n    },\n    getDirtyPaths: function getDirtyPaths$1() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return getDirtyPaths(editor, ...args);\n    },\n    shouldNormalize: function shouldNormalize$1() {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return shouldNormalize(editor, ...args);\n    },\n    // Editor interface\n    above: function above$1() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return above(editor, ...args);\n    },\n    after: function after$1() {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return after(editor, ...args);\n    },\n    before: function before$1() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return before(editor, ...args);\n    },\n    collapse: function collapse$1() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return collapse(editor, ...args);\n    },\n    delete: function _delete() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return deleteText(editor, ...args);\n    },\n    deselect: function deselect$1() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return deselect(editor, ...args);\n    },\n    edges: function edges$1() {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return edges(editor, ...args);\n    },\n    elementReadOnly: function elementReadOnly$1() {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return elementReadOnly(editor, ...args);\n    },\n    end: function end$1() {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return end(editor, ...args);\n    },\n    first: function first$1() {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return first(editor, ...args);\n    },\n    fragment: function fragment$1() {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return fragment(editor, ...args);\n    },\n    getMarks: function getMarks() {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return marks(editor, ...args);\n    },\n    hasBlocks: function hasBlocks$1() {\n      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n        args[_key28] = arguments[_key28];\n      }\n      return hasBlocks(editor, ...args);\n    },\n    hasInlines: function hasInlines$1() {\n      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n        args[_key29] = arguments[_key29];\n      }\n      return hasInlines(editor, ...args);\n    },\n    hasPath: function hasPath$1() {\n      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n        args[_key30] = arguments[_key30];\n      }\n      return hasPath(editor, ...args);\n    },\n    hasTexts: function hasTexts$1() {\n      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n        args[_key31] = arguments[_key31];\n      }\n      return hasTexts(editor, ...args);\n    },\n    insertNodes: function insertNodes$1() {\n      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n        args[_key32] = arguments[_key32];\n      }\n      return insertNodes(editor, ...args);\n    },\n    isBlock: function isBlock$1() {\n      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n        args[_key33] = arguments[_key33];\n      }\n      return isBlock(editor, ...args);\n    },\n    isEdge: function isEdge$1() {\n      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        args[_key34] = arguments[_key34];\n      }\n      return isEdge(editor, ...args);\n    },\n    isEmpty: function isEmpty$1() {\n      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n        args[_key35] = arguments[_key35];\n      }\n      return isEmpty(editor, ...args);\n    },\n    isEnd: function isEnd$1() {\n      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n        args[_key36] = arguments[_key36];\n      }\n      return isEnd(editor, ...args);\n    },\n    isNormalizing: function isNormalizing$1() {\n      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n        args[_key37] = arguments[_key37];\n      }\n      return isNormalizing(editor, ...args);\n    },\n    isStart: function isStart$1() {\n      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n        args[_key38] = arguments[_key38];\n      }\n      return isStart(editor, ...args);\n    },\n    last: function last$1() {\n      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n        args[_key39] = arguments[_key39];\n      }\n      return last(editor, ...args);\n    },\n    leaf: function leaf$1() {\n      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n        args[_key40] = arguments[_key40];\n      }\n      return leaf(editor, ...args);\n    },\n    levels: function levels$1() {\n      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n        args[_key41] = arguments[_key41];\n      }\n      return levels(editor, ...args);\n    },\n    liftNodes: function liftNodes$1() {\n      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n        args[_key42] = arguments[_key42];\n      }\n      return liftNodes(editor, ...args);\n    },\n    mergeNodes: function mergeNodes$1() {\n      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n        args[_key43] = arguments[_key43];\n      }\n      return mergeNodes(editor, ...args);\n    },\n    move: function move$1() {\n      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n        args[_key44] = arguments[_key44];\n      }\n      return move(editor, ...args);\n    },\n    moveNodes: function moveNodes$1() {\n      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n        args[_key45] = arguments[_key45];\n      }\n      return moveNodes(editor, ...args);\n    },\n    next: function next$1() {\n      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n        args[_key46] = arguments[_key46];\n      }\n      return next(editor, ...args);\n    },\n    node: function node$1() {\n      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n        args[_key47] = arguments[_key47];\n      }\n      return node(editor, ...args);\n    },\n    nodes: function nodes$1() {\n      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n        args[_key48] = arguments[_key48];\n      }\n      return nodes(editor, ...args);\n    },\n    normalize: function normalize$1() {\n      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n        args[_key49] = arguments[_key49];\n      }\n      return normalize(editor, ...args);\n    },\n    parent: function parent$1() {\n      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n        args[_key50] = arguments[_key50];\n      }\n      return parent(editor, ...args);\n    },\n    path: function path$1() {\n      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n        args[_key51] = arguments[_key51];\n      }\n      return path(editor, ...args);\n    },\n    pathRef: function pathRef$1() {\n      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n        args[_key52] = arguments[_key52];\n      }\n      return pathRef(editor, ...args);\n    },\n    pathRefs: function pathRefs$1() {\n      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n        args[_key53] = arguments[_key53];\n      }\n      return pathRefs(editor, ...args);\n    },\n    point: function point$1() {\n      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n        args[_key54] = arguments[_key54];\n      }\n      return point(editor, ...args);\n    },\n    pointRef: function pointRef$1() {\n      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n        args[_key55] = arguments[_key55];\n      }\n      return pointRef(editor, ...args);\n    },\n    pointRefs: function pointRefs$1() {\n      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n        args[_key56] = arguments[_key56];\n      }\n      return pointRefs(editor, ...args);\n    },\n    positions: function positions$1() {\n      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n        args[_key57] = arguments[_key57];\n      }\n      return positions(editor, ...args);\n    },\n    previous: function previous$1() {\n      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n        args[_key58] = arguments[_key58];\n      }\n      return previous(editor, ...args);\n    },\n    range: function range$1() {\n      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n        args[_key59] = arguments[_key59];\n      }\n      return range(editor, ...args);\n    },\n    rangeRef: function rangeRef$1() {\n      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n        args[_key60] = arguments[_key60];\n      }\n      return rangeRef(editor, ...args);\n    },\n    rangeRefs: function rangeRefs$1() {\n      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n        args[_key61] = arguments[_key61];\n      }\n      return rangeRefs(editor, ...args);\n    },\n    removeNodes: function removeNodes$1() {\n      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n        args[_key62] = arguments[_key62];\n      }\n      return removeNodes(editor, ...args);\n    },\n    select: function select$1() {\n      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n        args[_key63] = arguments[_key63];\n      }\n      return select(editor, ...args);\n    },\n    setNodes: function setNodes$1() {\n      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n        args[_key64] = arguments[_key64];\n      }\n      return setNodes(editor, ...args);\n    },\n    setNormalizing: function setNormalizing$1() {\n      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n        args[_key65] = arguments[_key65];\n      }\n      return setNormalizing(editor, ...args);\n    },\n    setPoint: function setPoint$1() {\n      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n        args[_key66] = arguments[_key66];\n      }\n      return setPoint(editor, ...args);\n    },\n    setSelection: function setSelection$1() {\n      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n        args[_key67] = arguments[_key67];\n      }\n      return setSelection(editor, ...args);\n    },\n    splitNodes: function splitNodes$1() {\n      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n        args[_key68] = arguments[_key68];\n      }\n      return splitNodes(editor, ...args);\n    },\n    start: function start$1() {\n      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n        args[_key69] = arguments[_key69];\n      }\n      return start(editor, ...args);\n    },\n    string: function string$1() {\n      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n        args[_key70] = arguments[_key70];\n      }\n      return string(editor, ...args);\n    },\n    unhangRange: function unhangRange$1() {\n      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n        args[_key71] = arguments[_key71];\n      }\n      return unhangRange(editor, ...args);\n    },\n    unsetNodes: function unsetNodes$1() {\n      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n        args[_key72] = arguments[_key72];\n      }\n      return unsetNodes(editor, ...args);\n    },\n    unwrapNodes: function unwrapNodes$1() {\n      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n        args[_key73] = arguments[_key73];\n      }\n      return unwrapNodes(editor, ...args);\n    },\n    void: function _void() {\n      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n        args[_key74] = arguments[_key74];\n      }\n      return getVoid(editor, ...args);\n    },\n    withoutNormalizing: function withoutNormalizing$1() {\n      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n        args[_key75] = arguments[_key75];\n      }\n      return withoutNormalizing(editor, ...args);\n    },\n    wrapNodes: function wrapNodes$1() {\n      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n        args[_key76] = arguments[_key76];\n      }\n      return wrapNodes(editor, ...args);\n    },\n    shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {\n      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {\n        args[_key77] = arguments[_key77];\n      }\n      return shouldMergeNodesRemovePrevNode(editor, ...args);\n    }\n  };\n  return editor;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDbUI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDdFAsOEJBQThCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDbGI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLDhEQUFhO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLDhDQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFhO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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QUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4REFBYTtBQUNwQjtBQUNBO0FBQ0EsdXRCQUF1dEIsOERBQWE7QUFDcHVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Es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QTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBLFdBQVc7QUFDWCxxREFBcUQsYUFBYTtBQUNsRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBLFdBQVc7QUFDWCxxREFBcUQsYUFBYTtBQUNsRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYixtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEYsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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NkUsZUFBZTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaStCO0FBQ2orQiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuaW1wb3J0IHsgY3JlYXRlRHJhZnQsIGZpbmlzaERyYWZ0LCBpc0RyYWZ0LCBwcm9kdWNlIH0gZnJvbSAnaW1tZXInO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aFJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50UmVmID0ge1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFJhbmdlUmVmID0ge1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBESVJUWV9QQVRIX0tFWVMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGggPSB7XG4gIGFuY2VzdG9ycyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcGF0aHMgPSBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbiAgfSxcbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAmJiBpIDwgYW5vdGhlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgICBpZiAoYXYgIT09IGJ2KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uO1xuICB9LFxuICBjb21wYXJlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSA8IGFub3RoZXJbaV0pIHJldHVybiAtMTtcbiAgICAgIGlmIChwYXRoW2ldID4gYW5vdGhlcltpXSkgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcbiAgZW5kc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA8IGJ2O1xuICB9LFxuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG4gIGhhc1ByZXZpb3VzKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID4gMDtcbiAgfSxcbiAgaXNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMTtcbiAgfSxcbiAgaXNBbmNlc3RvcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGlzQ2hpbGQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggKyAxICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNDb21tb24ocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzRGVzY2VuZGFudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc1BhcmVudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoICsgMSA9PT0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc1BhdGgodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKTtcbiAgfSxcbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBhbCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmwgPSBhbm90aGVyW2Fub3RoZXIubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGFsICE9PSBibCAmJiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuICBsZXZlbHMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsaXN0LnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0sXG4gIG5leHQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBuZXh0IGluZGV4LlwiKSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCArIDEpO1xuICB9LFxuICBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wZXJhdGlvbikge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgcGF0aCBvZiB0aGUgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcbiAgcHJldmlvdXMocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gcHJldmlvdXMgaW5kZXguXCIpKTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgLSAxKTtcbiAgfSxcbiAgcmVsYXRpdmUocGF0aCwgYW5jZXN0b3IpIHtcbiAgICBpZiAoIVBhdGguaXNBbmNlc3RvcihhbmNlc3RvciwgcGF0aCkgJiYgIVBhdGguZXF1YWxzKHBhdGgsIGFuY2VzdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcmVsYXRpdmUgcGF0aCBvZiBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbnNpZGUgYW5jZXN0b3IgW1wiKS5jb25jYXQoYW5jZXN0b3IsIFwiXSwgYmVjYXVzZSBpdCBpcyBub3QgYWJvdmUgb3IgZXF1YWwgdG8gdGhlIHBhdGguXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuICAgIC8vIFBFUkY6IHVzZSBkZXN0cnVjdGluZyBpbnN0ZWFkIG9mIGltbWVyXG4gICAgdmFyIHAgPSBbLi4ucGF0aF07XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgLy8gUEVSRjogRXhpdCBlYXJseSBpZiB0aGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBvcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUob3AsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvcCwgcCkpIHtcbiAgICAgICAgICAgIHBbb3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3BcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AsIHApIHx8IFBhdGguaXNBbmNlc3Rvcihfb3AsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AsIHApKSB7XG4gICAgICAgICAgICBwW19vcC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMixcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMiwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKF9vcDIsIHApKSB7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoXSArPSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDMsXG4gICAgICAgICAgICBwb3NpdGlvbjogX3Bvc2l0aW9uXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMywgcCkpIHtcbiAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgIHBbcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ2JhY2t3YXJkJykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wMywgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDMsIHApICYmIHBhdGhbX29wMy5sZW5ndGhdID49IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDQsXG4gICAgICAgICAgICBuZXdQYXRoOiBvbnBcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgICAgIC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3A0LCBwKSB8fCBQYXRoLmVxdWFscyhfb3A0LCBwKSkge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvbnAuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29weS5jb25jYXQocC5zbGljZShfb3A0Lmxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1NpYmxpbmcoX29wNCwgb25wKSAmJiAoUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob25wLCBwKSkge1xuICAgICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyRlKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGUoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGUoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBhcHBseVRvRHJhZnQgPSAoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKSA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIFxcXCJpbnNlcnRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBub2RlLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbcG9pbnQsIGtleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIHZhciBfbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoKTtcbiAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuICAgICAgICBfbm9kZS50ZXh0ID0gYmVmb3JlICsgdGV4dCArIGFmdGVyO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludCwgX2tleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIF9ub2RlMiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuICAgICAgICB2YXIgX3BhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgyKTtcbiAgICAgICAgdmFyIF9pbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTIpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYuY2hpbGRyZW4ucHVzaCguLi5fbm9kZTIuY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbm9kZTIpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MiwgX2tleTJdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcbiAgICAgICAgdmFyIF9wYXJlbnQyID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDMpO1xuICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cbiAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIF9ub2RlMyk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MywgX2tleTNdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBfaW5kZXgzID0gX3BhdGg0W19wYXRoNC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBhbGwgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ0LCBfa2V5NF0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX3ByZXYgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHByZWZlck5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV4dFsxXSwgX3BhdGg0KSkge1xuICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9ICFQYXRoLmhhc1ByZXZpb3VzKG5leHRbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gUGF0aC5jb21tb24oX3ByZXZbMV0sIF9wYXRoNCkubGVuZ3RoIDwgUGF0aC5jb21tb24obmV4dFsxXSwgX3BhdGg0KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNSxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG4gICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU0LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG4gICAgICAgIHZhciBfYWZ0ZXIgPSBfbm9kZTQudGV4dC5zbGljZShfb2Zmc2V0ICsgX3RleHQubGVuZ3RoKTtcbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDUsIF9rZXk1XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDYsXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF9wYXRoNi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9ub2RlNSA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg2KTtcbiAgICAgICAgZm9yICh2YXIgX2tleTYgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTZdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbm9kZTVbX2tleTZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgZGVmaW5lZCwgYnV0IGFyZSBub3cgbWlzc2luZywgbXVzdCBiZSBkZWxldGVkXG4gICAgICAgIGZvciAodmFyIF9rZXk3IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX2tleTcpKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkZSh7fSwgX25ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfa2V5OCBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF9uZXdQcm9wZXJ0aWVzW19rZXk4XTtcbiAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTggPT09ICdhbmNob3InIHx8IF9rZXk4ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5OCwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGlvbltfa2V5OF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleThdID0gX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG4gICAgICAgIHZhciBfaW5kZXg0ID0gX3BhdGg3W19wYXRoNy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld05vZGU7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTYpKSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAgIHZhciBfYWZ0ZXIyID0gX25vZGU2LnRleHQuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgIF9ub2RlNi50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgICBfbm9kZTYuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDYsIF9rZXk5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBzZWxlY3Rpb247XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEdlbmVyYWxUcmFuc2Zvcm1zID0ge1xuICB0cmFuc2Zvcm0oZWRpdG9yLCBvcCkge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGNyZWF0ZURyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgY3JlYXRlRHJhZnQoZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGVjdGlvbiA9IGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlZGl0b3IuY2hpbGRyZW4gPSBmaW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gaXNEcmFmdChzZWxlY3Rpb24pID8gZmluaXNoRHJhZnQoc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGVzKG5vZGVzLCBvcHRpb25zKTtcbiAgfSxcbiAgbGlmdE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5saWZ0Tm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIG1lcmdlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1lcmdlTm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIG1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICByZW1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IucmVtb3ZlTm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIHNldE5vZGVzKGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc2V0Tm9kZXMocHJvcHMsIG9wdGlvbnMpO1xuICB9LFxuICBzcGxpdE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5zcGxpdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW5zZXROb2Rlcyhwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG4gIHVud3JhcE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci51bndyYXBOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci53cmFwTm9kZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBTZWxlY3Rpb25UcmFuc2Zvcm1zID0ge1xuICBjb2xsYXBzZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuY29sbGFwc2Uob3B0aW9ucyk7XG4gIH0sXG4gIGRlc2VsZWN0KGVkaXRvcikge1xuICAgIGVkaXRvci5kZXNlbGVjdCgpO1xuICB9LFxuICBtb3ZlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tb3ZlKG9wdGlvbnMpO1xuICB9LFxuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICBlZGl0b3Iuc2VsZWN0KHRhcmdldCk7XG4gIH0sXG4gIHNldFBvaW50KGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc2V0UG9pbnQocHJvcHMsIG9wdGlvbnMpO1xuICB9LFxuICBzZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcykge1xuICAgIGVkaXRvci5zZXRTZWxlY3Rpb24ocHJvcHMpO1xuICB9XG59O1xuXG4vKlxuICBDdXN0b20gZGVlcCBlcXVhbCBjb21wYXJpc29uIGZvciBTbGF0ZSBub2Rlcy5cblxuICBXZSBkb24ndCBuZWVkIGdlbmVyYWwgcHVycG9zZSBkZWVwIGVxdWFsaXR5O1xuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXG4gIENvbXBsZXggdmFsdWVzIG5lc3RlZCBpbnNpZGUgQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG4gIFNsYXRlIG9iamVjdHMgYXJlIGRlc2lnbmVkIHRvIGJlIHNlcmlhbGlzZWQsIHNvXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxuICovXG52YXIgaXNEZWVwRXF1YWwgPSAobm9kZSwgYW5vdGhlcikgPT4ge1xuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIHZhciBhID0gbm9kZVtrZXldO1xuICAgIHZhciBiID0gYW5vdGhlcltrZXldO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXG4gICAgRGVlcCBvYmplY3QgZXF1YWxpdHkgaXMgb25seSBuZWNlc3NhcnkgaW4gb25lIGRpcmVjdGlvbjsgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxuICAqL1xuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRkKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZSA9IHtcbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG4gIGVuZChyYW5nZSkge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBlbmQ7XG4gIH0sXG4gIGVxdWFscyhyYW5nZSwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocmFuZ2UuYW5jaG9yLCBhbm90aGVyLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKHJhbmdlLmZvY3VzLCBhbm90aGVyLmZvY3VzKTtcbiAgfSxcbiAgc3Vycm91bmRzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIHRhcmdldCk7XG4gICAgaWYgKCFpbnRlcnNlY3Rpb25SYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUmFuZ2UuZXF1YWxzKGludGVyc2VjdGlvblJhbmdlLCB0YXJnZXQpO1xuICB9LFxuICBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkNCk7XG4gICAgdmFyIFtzMSwgZTFdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBbczIsIGUyXSA9IFJhbmdlLmVkZ2VzKGFub3RoZXIpO1xuICAgIHZhciBzdGFydCA9IFBvaW50LmlzQmVmb3JlKHMxLCBzMikgPyBzMiA6IHMxO1xuICAgIHZhciBlbmQgPSBQb2ludC5pc0JlZm9yZShlMSwgZTIpID8gZTEgOiBlMjtcbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRkKHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0NvbGxhcHNlZChyYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG4gIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5hbmNob3IpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuZm9jdXMpO1xuICB9LFxuICAqcG9pbnRzKHJhbmdlKSB7XG4gICAgeWllbGQgW3JhbmdlLmFuY2hvciwgJ2FuY2hvciddO1xuICAgIHlpZWxkIFtyYW5nZS5mb2N1cywgJ2ZvY3VzJ107XG4gIH0sXG4gIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuICB0cmFuc2Zvcm0ocmFuZ2UsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHJhbmdlLCByID0+IHtcbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYWZmaW5pdHlBbmNob3I7XG4gICAgICB2YXIgYWZmaW5pdHlGb2N1cztcbiAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2lud2FyZCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWFrZSBzdXJlIHRvIHVzZSB0aGUgc2FtZSBhZmZpbml0eSB0b1xuICAgICAgICAvLyBhdm9pZCB0aGUgdHdvIHBvaW50cyBwYXNzaW5nIGVhY2ggb3RoZXIgYW5kIGV4cGFuZGluZyBpbiB0aGUgb3Bwb3NpdGVcbiAgICAgICAgLy8gZGlyZWN0aW9uXG4gICAgICAgIHZhciBpc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHIpO1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnYmFja3dhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdmb3J3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ291dHdhcmQnKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdmb3J3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2JhY2t3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSBhZmZpbml0eTtcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGFmZmluaXR5O1xuICAgICAgfVxuICAgICAgdmFyIGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyLmFuY2hvciwgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgICB9KTtcbiAgICAgIHZhciBmb2N1cyA9IFBvaW50LnRyYW5zZm9ybShyLmZvY3VzLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlGb2N1c1xuICAgICAgfSk7XG4gICAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHIuZm9jdXMgPSBmb2N1cztcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaGFyZWQgdGhlIGZ1bmN0aW9uIHdpdGggaXNFbGVtZW50VHlwZSB1dGlsaXR5XG4gKi9cbnZhciBpc0VsZW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pICYmICFFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBFbGVtZW50ID0ge1xuICBpc0FuY2VzdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbik7XG4gIH0sXG4gIGlzRWxlbWVudCxcbiAgaXNFbGVtZW50TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gRWxlbWVudC5pc0VsZW1lbnQodmFsKSk7XG4gIH0sXG4gIGlzRWxlbWVudFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuICBtYXRjaGVzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDMgPSBbXCJjaGlsZHJlblwiXSxcbiAgX2V4Y2x1ZGVkMiQzID0gW1widGV4dFwiXTtcbnZhciBJU19OT0RFX0xJU1RfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE5vZGUgPSB7XG4gIGFuY2VzdG9yKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBhbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgdmFyIG4gPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHApO1xuICAgICAgICB2YXIgZW50cnkgPSBbbiwgcF07XG4gICAgICAgIHlpZWxkIGVudHJ5O1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgY2hpbGQocm9vdCwgaW5kZXgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGNoaWxkIG9mIGEgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuICAgIHZhciBjID0gcm9vdC5jaGlsZHJlbltpbmRleF07XG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sXG4gIGNoaWxkcmVuKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIge1xuICAgICAgICByZXZlcnNlID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIGFuY2VzdG9yID0gTm9kZS5hbmNlc3Rvcihyb290LCBwYXRoKTtcbiAgICAgIHZhciB7XG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gYW5jZXN0b3I7XG4gICAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hpbGQgPSBOb2RlLmNoaWxkKGFuY2VzdG9yLCBpbmRleCk7XG4gICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgICAgaW5kZXggPSByZXZlcnNlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcbiAgZGVzY2VuZGFudChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcbiAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byB0aGUgcm9vdCBlZGl0b3Igbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgZGVzY2VuZGFudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY29lcmNlIGhlcmUgYmVjYXVzZSBjaGVja2luZyB0aGUgcGF0aCdzIGxlbmd0aCBkb2VzXG4gICAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYG5vZGVgIGlzIG5vdCBhIGBFZGl0b3JgLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cuXG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBlbGVtZW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBleHRyYWN0UHJvcHMobm9kZSkge1xuICAgIGlmIChFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCQzKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDMpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICB9LFxuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5bMF07XG4gICAgICAgIHAucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcbiAgZnJhZ21lbnQocm9vdCwgcmFuZ2UpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgYSBmcmFnbWVudCBzdGFydGluZyBmcm9tIGEgcm9vdCB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgWywgcGF0aF0gb2Ygbm9kZUVudHJpZXMpIHtcbiAgICAgICAgaWYgKCFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCkpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQociwgcGF0aCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICBsZWFmLnRleHQgPSBsZWFmLnRleHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuICAgICAgICAgIF9sZWFmLnRleHQgPSBfbGVhZi50ZXh0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChFZGl0b3IuaXNFZGl0b3IocikpIHtcbiAgICAgICAgci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdSb290LmNoaWxkcmVuO1xuICB9LFxuICBnZXQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXRJZihyb290LCBwYXRoKTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRlc2NlbmRhbnQgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgZ2V0SWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNhY2hlZFJlc3VsdCA9IElTX05PREVfTElTVF9DQUNIRS5nZXQodmFsdWUpO1xuICAgIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gbi5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBuID0gbi5jaGlsZHJlbltpXTtcbiAgICAgICAgcC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBsZWFmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgcCBvZiBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB5aWVsZCBbbiwgcF07XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcbiAgbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhc3MsXG4gICAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBmcm9tID0gW10sXG4gICAgICAgIHRvXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgdmFyIHAgPSBbXTtcbiAgICAgIHZhciBuID0gcm9vdDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGFsbG93ZWQgdG8gZ28gZG93bndhcmQgYW5kIHdlIGhhdmVuJ3QgZGVzY2VuZGVkIHlldCwgZG8uXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHAgPSBwLmNvbmNhdChuZXh0SW5kZXgpO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgcm9vdCBhbmQgd2UgY2FuJ3QgZ28gZG93biwgd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuICAgICAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcbiAgICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIGJhY2t3YXJkLi4uXG4gICAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICAgIHZhciBfbmV3UGF0aCA9IFBhdGgucHJldmlvdXMocCk7XG4gICAgICAgICAgcCA9IF9uZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UncmUgZ29pbmcgdXB3YXJkLi4uXG4gICAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIHBhcmVudChyb290LCBwYXRoKSB7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgcCA9IE5vZGUuZ2V0KHJvb3QsIHBhcmVudFBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgc3RyaW5nKG5vZGUpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChOb2RlLnN0cmluZykuam9pbignJyk7XG4gICAgfVxuICB9LFxuICB0ZXh0cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRjKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE9wZXJhdGlvbiA9IHtcbiAgaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcbiAgaXNPcGVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5uZXdQYXRoKTtcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG4gIGlzU2VsZWN0aW9uT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3NlbGVjdGlvbicpO1xuICB9LFxuICBpc1RleHRPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfdGV4dCcpO1xuICB9LFxuICBpbnZlcnNlKG9wKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnByZXZpb3VzKG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgLy8gUEVSRjogaW4gdGhpcyBjYXNlIHRoZSBtb3ZlIG9wZXJhdGlvbiBpcyBhIG5vLW9wIGFueXdheXMuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBtb3ZlIGhhcHBlbnMgY29tcGxldGVseSB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IHRoZSBwYXRoIGFuZFxuICAgICAgICAgIC8vIG5ld1BhdGggYXJlIHN0YWJsZSB3aXRoIHJlc3BlY3QgdG8gZWFjaCBvdGhlci5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgbW92ZSBkb2VzIG5vdCBoYXBwZW4gd2l0aGluIGEgc2luZ2xlIHBhcmVudCBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIGZvciB0aGUgbW92ZSB0byBpbXBhY3QgdGhlIHRydWUgcGF0aCB0byB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB3aGVyZSBpdCB3YXMgaW5zZXJ0ZWQuIFdlIGhhdmUgdG8gYWRqdXN0IGZvciB0aGlzXG4gICAgICAgICAgLy8gYW5kIGZpbmQgdGhlIG9yaWdpbmFsIHBhdGguIFdlIGNhbiBhY2NvbXBsaXNoIHRoaXMgKG9ubHkgaW4gbm9uLXNpYmxpbmcpXG4gICAgICAgICAgLy8gbW92ZXMgYnkgbG9va2luZyBhdCB0aGUgaW1wYWN0IG9mIHRoZSBtb3ZlIG9wZXJhdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgICAgIC8vIGFmdGVyIHRoZSBvcmlnaW5hbCBtb3ZlIHBhdGguXG4gICAgICAgICAgdmFyIGludmVyc2VQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgIHZhciBpbnZlcnNlTmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKFBhdGgubmV4dChwYXRoKSwgb3ApO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwYXRoOiBpbnZlcnNlUGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IGludmVyc2VOZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5uZXh0KG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBJU19FRElUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xudmFyIGlzRWRpdG9yID0gdmFsdWUgPT4ge1xuICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcbiAgaWYgKGNhY2hlZElzRWRpdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0U29mdEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNFbGVtZW50UmVhZE9ubHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1NlbGVjdGFibGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldERpcnR5UGF0aHMgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gIHJldHVybiBpc0VkaXRvcjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBFZGl0b3IgPSB7XG4gIGFib3ZlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWJvdmUob3B0aW9ucyk7XG4gIH0sXG4gIGFkZE1hcmsoZWRpdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgZWRpdG9yLmFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH0sXG4gIGFmdGVyKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmFmdGVyKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgYmVmb3JlKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmJlZm9yZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuICBkZWxldGVGb3J3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUZvcndhcmQodW5pdCk7XG4gIH0sXG4gIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChvcHRpb25zKTtcbiAgfSxcbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZWRnZXMoYXQpO1xuICB9LFxuICBlbGVtZW50UmVhZE9ubHkoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBlZGl0b3IuZWxlbWVudFJlYWRPbmx5KG9wdGlvbnMpO1xuICB9LFxuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZW5kKGF0KTtcbiAgfSxcbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZmlyc3QoYXQpO1xuICB9LFxuICBmcmFnbWVudChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5mcmFnbWVudChhdCk7XG4gIH0sXG4gIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0Jsb2NrcyhlbGVtZW50KTtcbiAgfSxcbiAgaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0lubGluZXMoZWxlbWVudCk7XG4gIH0sXG4gIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNQYXRoKHBhdGgpO1xuICB9LFxuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc1RleHRzKGVsZW1lbnQpO1xuICB9LFxuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNCbG9jayh2YWx1ZSk7XG4gIH0sXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFZGdlKHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcbiAgaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlbGVtZW50KTtcbiAgfSxcbiAgaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoZWxlbWVudCk7XG4gIH0sXG4gIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VuZChwb2ludCwgYXQpO1xuICB9LFxuICBpc0lubGluZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc05vcm1hbGl6aW5nKCk7XG4gIH0sXG4gIGlzU2VsZWN0YWJsZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1NlbGVjdGFibGUodmFsdWUpO1xuICB9LFxuICBpc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1N0YXJ0KHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhc3QoYXQpO1xuICB9LFxuICBsZWFmKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxlYWYoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBsZXZlbHMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sZXZlbHMob3B0aW9ucyk7XG4gIH0sXG4gIG1hcmtzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuZ2V0TWFya3MoKTtcbiAgfSxcbiAgbmV4dChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5leHQob3B0aW9ucyk7XG4gIH0sXG4gIG5vZGUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIG5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIG5vcm1hbGl6ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iubm9ybWFsaXplKG9wdGlvbnMpO1xuICB9LFxuICBwYXJlbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGFyZW50KGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aFJlZihlZGl0b3IsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGhSZWYocGF0aCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZnMoKTtcbiAgfSxcbiAgcG9pbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwb2ludFJlZihlZGl0b3IsIHBvaW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludFJlZihwb2ludCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmcygpO1xuICB9LFxuICBwb3NpdGlvbnMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb3NpdGlvbnMob3B0aW9ucyk7XG4gIH0sXG4gIHByZXZpb3VzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucHJldmlvdXMob3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZShhdCwgdG8pO1xuICB9LFxuICByYW5nZVJlZihlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZVJlZihyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlUmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmcygpO1xuICB9LFxuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcbiAgc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSB7XG4gICAgZWRpdG9yLnNldE5vcm1hbGl6aW5nKGlzTm9ybWFsaXppbmcpO1xuICB9LFxuICBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdGFydChhdCk7XG4gIH0sXG4gIHN0cmluZyhlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdHJpbmcoYXQsIG9wdGlvbnMpO1xuICB9LFxuICB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci51bmhhbmdSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHZvaWQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci52b2lkKG9wdGlvbnMpO1xuICB9LFxuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIGVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZm4pO1xuICB9LFxuICBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGU6IChlZGl0b3IsIHByZXZOb2RlLCBjdXJOb2RlKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5zaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUocHJldk5vZGUsIGN1ck5vZGUpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTG9jYXRpb24gPSB7XG4gIGlzTG9jYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUpIHx8IFBvaW50LmlzUG9pbnQodmFsdWUpIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUpO1xuICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNwYW4gPSB7XG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRiKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50ID0ge1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuICBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGVxdWFscyhwb2ludCwgYW5vdGhlcikge1xuICAgIC8vIFBFUkY6IGVuc3VyZSB0aGUgb2Zmc2V0cyBhcmUgZXF1YWwgZmlyc3Qgc2luY2UgdGhleSBhcmUgY2hlYXBlciB0byBjaGVjay5cbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBhbm90aGVyLm9mZnNldCAmJiBQYXRoLmVxdWFscyhwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICB9LFxuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuICB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHBvaW50LCBwID0+IHtcbiAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gcDtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIChvcC5vZmZzZXQgPCBvZmZzZXQgfHwgb3Aub2Zmc2V0ID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxuICogaW50ZXJuYWxseSB3aGVuIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBjb250YWluaW5nIGVuZCB1c2VyIGRhdGEuIERldmVsb3BlcnNcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcbiAqXG4gKiAgICBpbXBvcnQgeyBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXG4gKiAgICAgIHJldHVybiB2YWxcbiAqICAgIH0pO1xuICpcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcihzY3J1YmJlcikge1xuICAgIF9zY3J1YmJlciA9IHNjcnViYmVyO1xuICB9LFxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRhKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBUZXh0ID0ge1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIG9taXRUZXh0KG9iaikge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMik7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IFRleHQuaXNUZXh0KHZhbCkpO1xuICB9LFxuICBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IHRleHRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWNvcmF0aW9ucyhub2RlLCBkZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCRhKHt9LCBub2RlKV07XG4gICAgZm9yICh2YXIgZGVjIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhkZWMsIF9leGNsdWRlZDIkMik7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuICAgICAgZm9yICh2YXIgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IGxlYWYudGV4dDtcbiAgICAgICAgdmFyIGxlYWZTdGFydCA9IGxlYWZFbmQ7XG4gICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoO1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGxlYWYsIHJlc3QpO1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgZXhwYW5kZWQgYW5kIG1hdGNoIHRoZSBsZWFmLCBvciBzdGFydHMgYWZ0ZXIsIG9yIGVuZHMgYmVmb3JlIGl0LCBjb250aW51ZS5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCAhPT0gZGVjb3JhdGlvbkVuZCAmJiAoZGVjb3JhdGlvblN0YXJ0ID09PSBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCkgfHwgZGVjb3JhdGlvblN0YXJ0ID4gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kIDwgbGVhZlN0YXJ0IHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCAmJiBsZWFmU3RhcnQgIT09IDApIHtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByYW5nZSB0byB0aGUgbWlkZGxlIGludGVyc2VjdGluZyBzZWN0aW9uLiBEbyB0aGUgZW5kXG4gICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG4gICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgIHZhciBvZmYgPSBkZWNvcmF0aW9uRW5kIC0gbGVhZlN0YXJ0O1xuICAgICAgICAgIGFmdGVyID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPiBsZWFmU3RhcnQpIHtcbiAgICAgICAgICB2YXIgX29mZiA9IGRlY29yYXRpb25TdGFydCAtIGxlYWZTdGFydDtcbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG1pZGRsZSwgcmVzdCk7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcbiAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgbG9jYXRpb24gdG8gaW5zZXJ0IGNvbnRlbnQgaW50byB0aGUgZWRpdG9yLlxuICogQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gKiBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICogY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG4gKi9cbnZhciBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24gPSBlZGl0b3IgPT4ge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIHJldHVybiBlZGl0b3Iuc2VsZWN0aW9uO1xuICB9IGVsc2UgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFswXTtcbiAgfVxufTtcblxudmFyIG1hdGNoUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBuID0+IG4gPT09IG5vZGU7XG59O1xuXG4vLyBDaGFyYWN0ZXIgKGdyYXBoZW1lIGNsdXN0ZXIpIGJvdW5kYXJpZXMgYXJlIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgZGVmYXVsdCBncmFwaGVtZSBjbHVzdGVyIGJvdW5kYXJ5IHNwZWNpZmljYXRpb24sIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzIHZhcmlhbnRbMV0uXG4vL1xuLy8gUmVmZXJlbmNlczpcbi8vXG4vLyBbMV0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNEZWZhdWx0X0dyYXBoZW1lX0NsdXN0ZXJfVGFibGVcbi8vIFsyXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHRcbi8vIFszXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0Lmh0bWxcbi8vIFs0XSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LnR4dFxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxuICovXG52YXIgZ2V0Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJEaXN0YW5jZShzdHIpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGlzTFRSID0gIWlzUlRMO1xuICB2YXIgY29kZXBvaW50cyA9IGlzUlRMID8gY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikgOiBzdHI7XG4gIHZhciBsZWZ0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgcmlnaHQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciBkaXN0YW5jZSA9IDA7XG4gIC8vIEV2YWx1YXRpb24gb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgZGVmZXJyZWQuXG4gIHZhciBnYjExID0gbnVsbDsgLy8gSXMgR0IxMSBhcHBsaWNhYmxlP1xuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cbiAgZm9yICh2YXIgY2hhciBvZiBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIGNvZGUgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgIGlmICghY29kZSkgYnJlYWs7XG4gICAgdmFyIHR5cGUgPSBnZXRDb2RlcG9pbnRUeXBlKGNoYXIsIGNvZGUpO1xuICAgIFtsZWZ0LCByaWdodF0gPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5aV0opICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuRXh0UGljdCkpIHtcbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuICAgICAgaWYgKCFnYjExKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5SSSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5SSSkpIHtcbiAgICAgIGlmIChnYjEyT3IxMyAhPT0gbnVsbCkge1xuICAgICAgICBnYjEyT3IxMyA9ICFnYjEyT3IxMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgIGdiMTJPcjEzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFnYjEyT3IxMykgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkaXN0YW5jZSArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gZGlzdGFuY2UgfHwgMTtcbn07XG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyQlxcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IHdvcmQgaW4gYSBzdHJpbmcgb2YgdGV4dC5cbiAqL1xudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgd2hpbGUgKHRleHQubGVuZ3RoID4gMCkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIGlzUlRMKTtcbiAgICB2YXIgW2NoYXIsIHJlbWFpbmluZ10gPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgY2hhckRpc3QsIGlzUlRMKTtcbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKGNoYXIsIHJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRleHQgPSByZW1haW5pbmc7XG4gIH1cbiAgcmV0dXJuIGRpc3Q7XG59O1xuLyoqXG4gKiBTcGxpdCBhIHN0cmluZyBpbiB0d28gcGFydHMgYXQgYSBnaXZlbiBkaXN0YW5jZSBzdGFydGluZyBmcm9tIHRoZSBlbmQgd2hlblxuICogYGlzUlRMYCBpcyBzZXQgdG8gYHRydWVgLlxuICovXG52YXIgc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlID0gKHN0ciwgZGlzdCwgaXNSVEwpID0+IHtcbiAgaWYgKGlzUlRMKSB7XG4gICAgdmFyIGF0ID0gc3RyLmxlbmd0aCAtIGRpc3Q7XG4gICAgcmV0dXJuIFtzdHIuc2xpY2UoYXQsIHN0ci5sZW5ndGgpLCBzdHIuc2xpY2UoMCwgYXQpXTtcbiAgfVxuICByZXR1cm4gW3N0ci5zbGljZSgwLCBkaXN0KSwgc3RyLnNsaWNlKGRpc3QpXTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIuIFRoZSBgcmVtYWluaW5nYCBhcmd1bWVudCBpcyB1c2VkXG4gKiBiZWNhdXNlIHNvbWV0aW1lcyB5b3UgbXVzdCByZWFkIHN1YnNlcXVlbnQgY2hhcmFjdGVycyB0byB0cnVseSBkZXRlcm1pbmUgaXQuXG4gKi9cbnZhciBpc1dvcmRDaGFyYWN0ZXIgPSBmdW5jdGlvbiBpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGlmIChTUEFDRS50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoYW1lbGVvbnMgY291bnQgYXMgd29yZCBjaGFyYWN0ZXJzIGFzIGxvbmcgYXMgdGhleSdyZSBpbiBhIHdvcmQsIHNvXG4gIC8vIHJlY3Vyc2UgdG8gc2VlIGlmIHRoZSBuZXh0IG9uZSBpcyBhIHdvcmQgY2hhcmFjdGVyIG9yIG5vdC5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KGNoYXIpKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBpc1JUTCk7XG4gICAgdmFyIFtuZXh0Q2hhciwgbmV4dFJlbWFpbmluZ10gPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBjaGFyRGlzdCwgaXNSVEwpO1xuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIobmV4dENoYXIsIG5leHRSZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogSXRlcmF0ZSBvbiBjb2RlcG9pbnRzIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqL1xudmFyIGNvZGVwb2ludHNJdGVyYXRvclJUTCA9IGZ1bmN0aW9uKiBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSB7XG4gIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyMS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdmFyIGNoYXIyID0gc3RyLmNoYXJBdChlbmQgLSBpIC0gMSk7XG4gICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXIyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHlpZWxkIGNoYXIyICsgY2hhcjE7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXG4gKiBJcyBgY2hhckNvZGVgIGEgaGlnaCBzdXJyb2dhdGUuXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG4gKi9cbnZhciBpc0hpZ2hTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGQ4MDAgJiYgY2hhckNvZGUgPD0gMHhkYmZmO1xufTtcbi8qKlxuICogSXMgYGNoYXJDb2RlYCBhIGxvdyBzdXJyb2dhdGUuXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG4gKi9cbnZhciBpc0xvd1N1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZGMwMCAmJiBjaGFyQ29kZSA8PSAweGRmZmY7XG59O1xudmFyIENvZGVwb2ludFR5cGU7XG4oZnVuY3Rpb24gKENvZGVwb2ludFR5cGUpIHtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dGVuZFwiXSA9IDFdID0gXCJFeHRlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiWldKXCJdID0gMl0gPSBcIlpXSlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJSSVwiXSA9IDRdID0gXCJSSVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJQcmVwZW5kXCJdID0gOF0gPSBcIlByZXBlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiU3BhY2luZ01hcmtcIl0gPSAxNl0gPSBcIlNwYWNpbmdNYXJrXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxcIl0gPSAzMl0gPSBcIkxcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVlwiXSA9IDY0XSA9IFwiVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJUXCJdID0gMTI4XSA9IFwiVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlwiXSA9IDI1Nl0gPSBcIkxWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWVFwiXSA9IDUxMl0gPSBcIkxWVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRQaWN0XCJdID0gMTAyNF0gPSBcIkV4dFBpY3RcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiQW55XCJdID0gMjA0OF0gPSBcIkFueVwiO1xufSkoQ29kZXBvaW50VHlwZSB8fCAoQ29kZXBvaW50VHlwZSA9IHt9KSk7XG52YXIgcmVFeHRlbmQgPSAvXig/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4OTgtXFx1MDg5RlxcdTA4Q0EtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNDXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRVxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyXFx1MTczM1xcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTgwRlxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQ0VcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURFRkQtXFx1REVGRlxcdURGNDYtXFx1REY1MFxcdURGODItXFx1REY4NV18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3MFxcdURDNzNcXHVEQzc0XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVEQ0MyXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERTQxXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNFxcdURGMDBcXHVERjAxXFx1REYzNi1cXHVERjNBXFx1REY0MFxcdURGNDJdfFxcdUQ4MERbXFx1REM0MFxcdURDNDctXFx1REM1NV18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzNbXFx1REYwMC1cXHVERjJEXFx1REYzMC1cXHVERjQ2XXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVEQzhGXFx1REQzMC1cXHVERDM2XFx1REVBRVxcdURFRUMtXFx1REVFRl18XFx1RDgzOVtcXHVEQ0VDLVxcdURDRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcbnZhciBnZXRDb2RlcG9pbnRUeXBlID0gKGNoYXIsIGNvZGUpID0+IHtcbiAgdmFyIHR5cGUgPSBDb2RlcG9pbnRUeXBlLkFueTtcbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0ZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0ZW5kO1xuICB9XG4gIGlmIChjb2RlID09PSAweDIwMGQpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuWldKO1xuICB9XG4gIGlmIChjb2RlID49IDB4MWYxZTYgJiYgY29kZSA8PSAweDFmMWZmKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlJJO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZVByZXBlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5QcmVwZW5kO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkw7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlY7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVjtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVMVlQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVlQ7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuZnVuY3Rpb24gaW50ZXJzZWN0cyh4LCB5KSB7XG4gIHJldHVybiAoeCAmIHkpICE9PSAwO1xufVxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbXG4vLyBHQjZcbltDb2RlcG9pbnRUeXBlLkwsIENvZGVwb2ludFR5cGUuTCB8IENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLkxWVF0sXG4vLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLFxuLy8gR0I4XG5bQ29kZXBvaW50VHlwZS5MVlQgfCBDb2RlcG9pbnRUeXBlLlQsIENvZGVwb2ludFR5cGUuVF0sXG4vLyBHQjlcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5FeHRlbmQgfCBDb2RlcG9pbnRUeXBlLlpXSl0sXG4vLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLFxuLy8gR0I5YlxuW0NvZGVwb2ludFR5cGUuUHJlcGVuZCwgQ29kZXBvaW50VHlwZS5BbnldLFxuLy8gR0IxMVxuW0NvZGVwb2ludFR5cGUuWldKLCBDb2RlcG9pbnRUeXBlLkV4dFBpY3RdLFxuLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcbmZ1bmN0aW9uIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBOb25Cb3VuZGFyeVBhaXJzLmZpbmRJbmRleChyID0+IGludGVyc2VjdHMobGVmdCwgclswXSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgclsxXSkpID09PSAtMTtcbn1cbnZhciBlbmRpbmdFbW9qaVpXSiA9IC8oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDg5OC1cXHUwODlGXFx1MDhDQS1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0NcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNFXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzJcXHUxNzMzXFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODBGXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDRVxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REVGRC1cXHVERUZGXFx1REY0Ni1cXHVERjUwXFx1REY4Mi1cXHVERjg1XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzcwXFx1REM3M1xcdURDNzRcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdURDQzJcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFNDFcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XFx1REYwMFxcdURGMDFcXHVERjM2LVxcdURGM0FcXHVERjQwXFx1REY0Ml18XFx1RDgwRFtcXHVEQzQwXFx1REM0Ny1cXHVEQzU1XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzM1tcXHVERjAwLVxcdURGMkRcXHVERjMwLVxcdURGNDZdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdURDOEZcXHVERDMwLVxcdUREMzZcXHVERUFFXFx1REVFQy1cXHVERUVGXXxcXHVEODM5W1xcdURDRUMtXFx1RENFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pKlxcdTIwMEQkLztcbnZhciBlbmRzV2l0aEVtb2ppWldKID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5zZWFyY2goZW5kaW5nRW1vamlaV0opICE9PSAtMTtcbn07XG52YXIgZW5kaW5nUklzID0gLyg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREZGXSkrJC9nO1xudmFyIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMgPSBzdHIgPT4ge1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZW5kaW5nUklzKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEEgUkkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdXJyb2dhdGUgcGFpci5cbiAgICB2YXIgbnVtUklzID0gbWF0Y2hbMF0ubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gbnVtUklzICUgMiA9PT0gMTtcbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFRleHRUcmFuc2Zvcm1zID0ge1xuICBkZWxldGUoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmRlbGV0ZShvcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcilcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgICAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXQsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IHN0YXJ0UG9pbnQgfHwgZW5kUG9pbnQ7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KSB8fCBFZGl0b3IuZWxlbWVudFJlYWRPbmx5KGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gYXQ7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHRleHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDkoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIEdlbmVyYWxUcmFuc2Zvcm1zKSwgTm9kZVRyYW5zZm9ybXMpLCBTZWxlY3Rpb25UcmFuc2Zvcm1zKSwgVGV4dFRyYW5zZm9ybXMpO1xuXG4vLyBwZXJmXG52YXIgQkFUQ0hJTkdfRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIGlzQmF0Y2hpbmdEaXJ0eVBhdGhzID0gZWRpdG9yID0+IHtcbiAgcmV0dXJuIEJBVENISU5HX0RJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IGZhbHNlO1xufTtcbnZhciBiYXRjaERpcnR5UGF0aHMgPSAoZWRpdG9yLCBmbiwgdXBkYXRlKSA9PiB7XG4gIHZhciB2YWx1ZSA9IEJBVENISU5HX0RJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IGZhbHNlO1xuICBCQVRDSElOR19ESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgdHJ5IHtcbiAgICBmbigpO1xuICAgIHVwZGF0ZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIEJBVENISU5HX0RJUlRZX1BBVEhTLnNldChlZGl0b3IsIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiB1cGRhdGUgZWRpdG9yIGRpcnR5IHBhdGhzXG4gKlxuICogQHBhcmFtIG5ld0RpcnR5UGF0aHM6IFBhdGhbXTsgbmV3IGRpcnR5IHBhdGhzXG4gKiBAcGFyYW0gdHJhbnNmb3JtOiAocDogUGF0aCkgPT4gUGF0aCB8IG51bGw7IGhvdyB0byB0cmFuc2Zvcm0gZXhpc3RpbmcgZGlydHkgcGF0aHNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGlydHlQYXRocyhlZGl0b3IsIG5ld0RpcnR5UGF0aHMsIHRyYW5zZm9ybSkge1xuICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB2YXIgb2xkRGlydHlQYXRoS2V5cyA9IERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gIHZhciBkaXJ0eVBhdGhzO1xuICB2YXIgZGlydHlQYXRoS2V5cztcbiAgdmFyIGFkZCA9IHBhdGggPT4ge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGlydHlQYXRoS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgZGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIGRpcnR5UGF0aHMgPSBbXTtcbiAgICBkaXJ0eVBhdGhLZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAodmFyIHBhdGggb2Ygb2xkRGlydHlQYXRocykge1xuICAgICAgdmFyIG5ld1BhdGggPSB0cmFuc2Zvcm0ocGF0aCk7XG4gICAgICBhZGQobmV3UGF0aCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpcnR5UGF0aHMgPSBvbGREaXJ0eVBhdGhzO1xuICAgIGRpcnR5UGF0aEtleXMgPSBvbGREaXJ0eVBhdGhLZXlzO1xuICB9XG4gIGZvciAodmFyIF9wYXRoIG9mIG5ld0RpcnR5UGF0aHMpIHtcbiAgICBhZGQoX3BhdGgpO1xuICB9XG4gIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgZGlydHlQYXRoS2V5cyk7XG59XG5cbnZhciBhcHBseSA9IChlZGl0b3IsIG9wKSA9PiB7XG4gIGZvciAodmFyIHJlZiBvZiBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSkge1xuICAgIFBhdGhSZWYudHJhbnNmb3JtKHJlZiwgb3ApO1xuICB9XG4gIGZvciAodmFyIF9yZWYgb2YgRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSB7XG4gICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgfVxuICBmb3IgKHZhciBfcmVmMiBvZiBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpIHtcbiAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgfVxuICAvLyB1cGRhdGUgZGlydHkgcGF0aHNcbiAgaWYgKCFpc0JhdGNoaW5nRGlydHlQYXRocyhlZGl0b3IpKSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9IFBhdGgub3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcCkgPyBwID0+IFBhdGgudHJhbnNmb3JtKHAsIG9wKSA6IHVuZGVmaW5lZDtcbiAgICB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgZWRpdG9yLmdldERpcnR5UGF0aHMob3ApLCB0cmFuc2Zvcm0pO1xuICB9XG4gIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IsIHtcbiAgICBvcGVyYXRpb246IG9wXG4gIH0pO1xuICAvLyBDbGVhciBhbnkgZm9ybWF0cyBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgfVxuICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICBlZGl0b3Iub25DaGFuZ2Uoe1xuICAgICAgICBvcGVyYXRpb246IG9wXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxuICovXG52YXIgZ2V0RGlydHlQYXRocyA9IChlZGl0b3IsIG9wKSA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICB9XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcGF0aDogX3BhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgpO1xuICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSBUZXh0LmlzVGV4dChub2RlKSA/IFtdIDogQXJyYXkuZnJvbShOb2RlLm5vZGVzKG5vZGUpLCBfcmVmID0+IHtcbiAgICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBfcGF0aC5jb25jYXQocCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLmxldmVscywgLi4uZGVzY2VuZGFudHNdO1xuICAgICAgfVxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICByZXR1cm4gWy4uLmFuY2VzdG9ycywgcHJldmlvdXNQYXRoXTtcbiAgICAgIH1cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICBuZXdQYXRoXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgbmV3QW5jZXN0b3JzID0gW107XG4gICAgICAgIGZvciAodmFyIGFuY2VzdG9yIG9mIFBhdGguYW5jZXN0b3JzKF9wYXRoMykpIHtcbiAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgb2xkQW5jZXN0b3JzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2FuY2VzdG9yIG9mIFBhdGguYW5jZXN0b3JzKG5ld1BhdGgpKSB7XG4gICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXdBbmNlc3RvcnNbbmV3QW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSBuZXdQYXRoW25ld1BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZXN1bHRQYXRoID0gbmV3UGFyZW50LmNvbmNhdChuZXdJbmRleCk7XG4gICAgICAgIHJldHVybiBbLi4ub2xkQW5jZXN0b3JzLCAuLi5uZXdBbmNlc3RvcnMsIHJlc3VsdFBhdGhdO1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNCk7XG4gICAgICAgIHJldHVybiBbLi4uX2FuY2VzdG9yc107XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIF9sZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDUpO1xuICAgICAgICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQoX3BhdGg1KTtcbiAgICAgICAgcmV0dXJuIFsuLi5fbGV2ZWxzLCBuZXh0UGF0aF07XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgZ2V0RnJhZ21lbnQgPSBlZGl0b3IgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5cbnZhciBub3JtYWxpemVOb2RlID0gKGVkaXRvciwgZW50cnkpID0+IHtcbiAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAvLyBUaGVyZSBhcmUgbm8gY29yZSBub3JtYWxpemF0aW9ucyBmb3IgdGV4dCBub2Rlcy5cbiAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEVuc3VyZSB0aGF0IGJsb2NrIGFuZCBpbmxpbmUgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgdGV4dCBjaGlsZC5cbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGNoaWxkID0ge1xuICAgICAgdGV4dDogJydcbiAgICB9O1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgYXQ6IHBhdGguY29uY2F0KDApLFxuICAgICAgdm9pZHM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGhhdmUgYmxvY2sgb3IgaW5saW5lIGNoaWxkcmVuLlxuICB2YXIgc2hvdWxkSGF2ZUlubGluZXMgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBmYWxzZSA6IEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgfHwgZWRpdG9yLmlzSW5saW5lKG5vZGUuY2hpbGRyZW5bMF0pKTtcbiAgLy8gU2luY2Ugd2UnbGwgYmUgYXBwbHlpbmcgb3BlcmF0aW9ucyB3aGlsZSBpdGVyYXRpbmcsIGtlZXAgdHJhY2sgb2YgYW5cbiAgLy8gaW5kZXggdGhhdCBhY2NvdW50cyBmb3IgYW55IGFkZGVkL3JlbW92ZWQgbm9kZXMuXG4gIHZhciBuID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrLCBuKyspIHtcbiAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChjdXJyZW50Tm9kZSkpIGNvbnRpbnVlO1xuICAgIHZhciBfY2hpbGQgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuXTtcbiAgICB2YXIgcHJldiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW24gLSAxXTtcbiAgICB2YXIgaXNMYXN0ID0gaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIHZhciBpc0lubGluZU9yVGV4dCA9IFRleHQuaXNUZXh0KF9jaGlsZCkgfHwgRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSAmJiBlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKTtcbiAgICAvLyBPbmx5IGFsbG93IGJsb2NrIG5vZGVzIGluIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gYW5kIHBhcmVudCBibG9ja3NcbiAgICAvLyB0aGF0IG9ubHkgY29udGFpbiBibG9jayBub2Rlcy4gU2ltaWxhcmx5LCBvbmx5IGFsbG93IGlubGluZSBub2RlcyBpblxuICAgIC8vIG90aGVyIGlubGluZSBub2Rlcywgb3IgcGFyZW50IGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBpbmxpbmVzIGFuZFxuICAgIC8vIHRleHQuXG4gICAgaWYgKGlzSW5saW5lT3JUZXh0ICE9PSBzaG91bGRIYXZlSW5saW5lcykge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBuLS07XG4gICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBpbmxpbmUgbm9kZXMgYXJlIHN1cnJvdW5kZWQgYnkgdGV4dCBub2Rlcy5cbiAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKSkge1xuICAgICAgICBpZiAocHJldiA9PSBudWxsIHx8ICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHZhciBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgIHZhciBfbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIF9uZXdDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gKyAxKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUsIGFuZCBkb2Vzbid0IGhhdmUgYSBgY2hpbGRyZW5gIGZpZWxkLFxuICAgICAgLy8gdGhlbiB3ZSBoYXZlIGFuIGludmFsaWQgbm9kZSB0aGF0IHdpbGwgdXBzZXQgc2xhdGUuXG4gICAgICAvL1xuICAgICAgLy8gZWc6IGB7IHR5cGU6ICdzb21lX25vZGUnIH1gLlxuICAgICAgLy9cbiAgICAgIC8vIFRvIHByZXZlbnQgc2xhdGUgZnJvbSBicmVha2luZywgd2UgY2FuIGFkZCB0aGUgYGNoaWxkcmVuYCBmaWVsZCxcbiAgICAgIC8vIGFuZCBub3cgdGhhdCBpdCBpcyB2YWxpZCwgd2UgY2FuIHRvIG1hbnkgbW9yZSBvcGVyYXRpb25zIGVhc2lseSxcbiAgICAgIC8vIHN1Y2ggYXMgZXh0ZW5kIG5vcm1hbGl6ZXJzIHRvIGZpeCBlcnJvbm91cyBzdHJ1Y3R1cmUuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KF9jaGlsZCkgJiYgISgnY2hpbGRyZW4nIGluIF9jaGlsZCkpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRDaGlsZCA9IF9jaGlsZDtcbiAgICAgICAgZWxlbWVudENoaWxkLmNoaWxkcmVuID0gW107XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIHRoYXQgYXJlIGVtcHR5IG9yIG1hdGNoLlxuICAgICAgaWYgKHByZXYgIT0gbnVsbCAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICBpZiAoVGV4dC5lcXVhbHMoX2NoaWxkLCBwcmV2LCB7XG4gICAgICAgICAgbG9vc2U6IHRydWVcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2LnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuIC0gMSksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfSBlbHNlIGlmIChfY2hpbGQudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaG91bGROb3JtYWxpemUgPSAoZWRpdG9yLCBfcmVmKSA9PiB7XG4gIHZhciB7XG4gICAgaXRlcmF0aW9uLFxuICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoXG4gIH0gPSBfcmVmO1xuICB2YXIgbWF4SXRlcmF0aW9ucyA9IGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoICogNDI7IC8vIEhBQ0s6IGJldHRlciB3YXk/XG4gIGlmIChpdGVyYXRpb24gPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBsZXRlbHkgbm9ybWFsaXplIHRoZSBlZGl0b3IgYWZ0ZXIgXCIuY29uY2F0KG1heEl0ZXJhdGlvbnMsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXCIpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhYm92ZSA9IGZ1bmN0aW9uIGFib3ZlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZSxcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hdGNoXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gIHZhciByZXZlcnNlID0gbW9kZSA9PT0gJ2xvd2VzdCc7XG4gIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgIGF0OiBwYXRoLFxuICAgIHZvaWRzLFxuICAgIG1hdGNoLFxuICAgIHJldmVyc2VcbiAgfSkpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQobikpIGNvbnRpbnVlO1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBhdC5hbmNob3IucGF0aCkgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmZvY3VzLnBhdGgpKSB7XG4gICAgICAgIHJldHVybiBbbiwgcF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghUGF0aC5lcXVhbHMocGF0aCwgcCkpIHtcbiAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ4KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ4KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgYWRkTWFyayA9IChlZGl0b3IsIGtleSwgdmFsdWUpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHZhciBtYXRjaCA9IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICB9XG5cbiAgICAgIHZhciBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBbc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpO1xuICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDcoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xuICB2YXIgZm9jdXMgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICB2YXIgcmFuZ2UgPSB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG4gIHZhciB7XG4gICAgZGlzdGFuY2UgPSAxXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgZCA9IDA7XG4gIHZhciB0YXJnZXQ7XG4gIGZvciAodmFyIHAgb2YgRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIGF0OiByYW5nZVxuICB9KSkpIHtcbiAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIHRhcmdldCA9IHA7XG4gICAgfVxuICAgIGQrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ2KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDYoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDYoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBiZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gIHZhciBmb2N1cyA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuICBmb3IgKHZhciBwIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBhdDogcmFuZ2UsXG4gICAgcmV2ZXJzZTogdHJ1ZVxuICB9KSkpIHtcbiAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIHRhcmdldCA9IHA7XG4gICAgfVxuICAgIGQrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGRlbGV0ZUJhY2t3YXJkID0gKGVkaXRvciwgdW5pdCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHVuaXQsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBkZWxldGVGb3J3YXJkID0gKGVkaXRvciwgdW5pdCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHVuaXRcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGRlbGV0ZUZyYWdtZW50ID0gZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSB7XG4gIHZhciB7XG4gICAgZGlyZWN0aW9uID0gJ2ZvcndhcmQnXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBlZGdlcyA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZWxlbWVudFJlYWRPbmx5ID0gZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDUoX29iamVjdFNwcmVhZCQ1KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBuKVxuICB9KSk7XG59O1xuXG52YXIgZW5kID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG59O1xuXG52YXIgZmlyc3QgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xuICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbn07XG5cbnZhciBmcmFnbWVudCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCByYW5nZSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDQoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGdldFZvaWQgPSBmdW5jdGlvbiBnZXRWb2lkKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbilcbiAgfSkpO1xufTtcblxudmFyIGhhc0Jsb2NrcyA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xufTtcblxudmFyIGhhc0lubGluZXMgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG59O1xuXG52YXIgaGFzUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgcmV0dXJuIE5vZGUuaGFzKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgaGFzVGV4dHMgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KG4gPT4gVGV4dC5pc1RleHQobikpO1xufTtcblxudmFyIGluc2VydEJyZWFrID0gZWRpdG9yID0+IHtcbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogdHJ1ZVxuICB9KTtcbn07XG5cbnZhciBpbnNlcnROb2RlID0gKGVkaXRvciwgbm9kZSwgb3B0aW9ucykgPT4ge1xuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwgb3B0aW9ucyk7XG59O1xuXG52YXIgaW5zZXJ0U29mdEJyZWFrID0gZWRpdG9yID0+IHtcbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogdHJ1ZVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDMoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb24sXG4gICAgbWFya3NcbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGlmIChtYXJrcykge1xuICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDMoe1xuICAgICAgICB0ZXh0XG4gICAgICB9LCBtYXJrcyk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwge1xuICAgICAgICBhdDogb3B0aW9ucy5hdCxcbiAgICAgICAgdm9pZHM6IG9wdGlvbnMudm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgfVxufTtcblxudmFyIGlzQmxvY2sgPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICByZXR1cm4gIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG59O1xuXG52YXIgaXNFZGdlID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbn07XG5cbnZhciBpc0VtcHR5ID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBlbGVtZW50O1xuICB2YXIgW2ZpcnN0XSA9IGNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChmaXJzdCkgJiYgZmlyc3QudGV4dCA9PT0gJycgJiYgIWVkaXRvci5pc1ZvaWQoZWxlbWVudCk7XG59O1xuXG52YXIgaXNFbmQgPSAoZWRpdG9yLCBwb2ludCwgYXQpID0+IHtcbiAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG59O1xuXG52YXIgaXNOb3JtYWxpemluZyA9IGVkaXRvciA9PiB7XG4gIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gIHJldHVybiBpc05vcm1hbGl6aW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNOb3JtYWxpemluZztcbn07XG5cbnZhciBpc1N0YXJ0ID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xufTtcblxudmFyIGxhc3QgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgbGVhZiA9IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiBsZXZlbHMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV2ZWxzLnB1c2goW24sIHBdKTtcbiAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgeWllbGQqIGxldmVscztcbiAgfSgpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJ0ZXh0XCJdLFxuICBfZXhjbHVkZWQyJDEgPSBbXCJ0ZXh0XCJdO1xudmFyIG1hcmtzID0gZnVuY3Rpb24gbWFya3MoZWRpdG9yKSB7XG4gIHZhciB7XG4gICAgbWFya3MsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKG1hcmtzKSB7XG4gICAgcmV0dXJuIG1hcmtzO1xuICB9XG4gIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKTtcbiAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgW2ZvY3VzLCBhbmNob3JdID0gW2FuY2hvciwgZm9jdXNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDT01QQVQ6IE1ha2Ugc3VyZSBoYW5naW5nIHJhbmdlcyAoY2F1c2VkIGJ5IGRvdWJsZSBjbGlja2luZyBpbiBGaXJlZm94KVxuICAgICAqIGRvIG5vdCBhZHZlcnNlbHkgYWZmZWN0IHRoZSByZXR1cm5lZCBtYXJrcy5cbiAgICAgKi9cbiAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhbmNob3IsIGFuY2hvci5wYXRoKTtcbiAgICBpZiAoaXNFbmQpIHtcbiAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvcik7XG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgYW5jaG9yID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbbWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgYXQ6IHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1c1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIFtfbm9kZV0gPSBtYXRjaDtcbiAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZSwgX2V4Y2x1ZGVkJDEpO1xuICAgICAgcmV0dXJuIF9yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIHZhciB7XG4gICAgcGF0aFxuICB9ID0gYW5jaG9yO1xuICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgfSk7XG4gICAgdmFyIG1hcmtlZFZvaWQgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChuKVxuICAgIH0pO1xuICAgIGlmICghbWFya2VkVm9pZCkge1xuICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2ICYmIGJsb2NrKSB7XG4gICAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG4gICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQxKTtcbiAgcmV0dXJuIHJlc3Q7XG59O1xuXG52YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBtYXRjaCxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBvaW50QWZ0ZXJMb2NhdGlvbiA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgdm9pZHNcbiAgfSk7XG4gIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG4gIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgdmFyIHNwYW4gPSBbcG9pbnRBZnRlckxvY2F0aW9uLnBhdGgsIHRvXTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgfVxuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG4gICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICB9XG4gIHZhciBbbmV4dF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IHNwYW4sXG4gICAgbWF0Y2gsXG4gICAgbW9kZSxcbiAgICB2b2lkc1xuICB9KTtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG52YXIgbm9kZSA9IGZ1bmN0aW9uIG5vZGUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbn07XG5cbmZ1bmN0aW9uIG5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2FsbCcsXG4gICAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBpZ25vcmVOb25TZWxlY3RhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmIChTcGFuLmlzU3BhbihhdCkpIHtcbiAgICAgIGZyb20gPSBhdFswXTtcbiAgICAgIHRvID0gYXRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgZnJvbSA9IHJldmVyc2UgPyBsYXN0IDogZmlyc3Q7XG4gICAgICB0byA9IHJldmVyc2UgPyBmaXJzdCA6IGxhc3Q7XG4gICAgfVxuICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgcGFzczogX3JlZiA9PiB7XG4gICAgICAgIHZhciBbbm9kZV0gPSBfcmVmO1xuICAgICAgICBpZiAoIUVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdm9pZHMgJiYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSB8fCBFZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBub2RlKSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoaWdub3JlTm9uU2VsZWN0YWJsZSAmJiAhRWRpdG9yLmlzU2VsZWN0YWJsZShlZGl0b3IsIG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGhpdDtcbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2Ygbm9kZUVudHJpZXMpIHtcbiAgICAgIGlmIChpZ25vcmVOb25TZWxlY3RhYmxlICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFFZGl0b3IuaXNTZWxlY3RhYmxlKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDtcbiAgICAgIC8vIEluIGhpZ2hlc3QgbW9kZSBhbnkgbm9kZSBsb3dlciB0aGFuIHRoZSBsYXN0IGhpdCBpcyBub3QgYSBtYXRjaC5cbiAgICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGVyZSdzIGEgbWF0Y2ggYW5kIGl0J3MgbG93ZXIgdGhhbiB0aGUgbGFzdCwgdXBkYXRlIHRoZSBoaXQuXG4gICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gSW4gbG93ZXN0IG1vZGUgd2UgZW1pdCB0aGUgbGFzdCBoaXQsIG9uY2UgaXQncyBndWFyYW50ZWVkIGxvd2VzdC5cbiAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG4gICAgICBpZiAoZW1pdCkge1xuICAgICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVtaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGVtaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICB9XG4gICAgLy8gU2luY2UgbG93ZXN0IGlzIGFsd2F5cyBlbWl0dGluZyBvbmUgYmVoaW5kLCBjYXRjaCB1cCBhdCB0aGUgZW5kLlxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cbiAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICB5aWVsZCogbWF0Y2hlcztcbiAgICB9XG4gIH0oKTtcbn1cblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGZvcmNlID0gZmFsc2UsXG4gICAgb3BlcmF0aW9uXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgZ2V0RGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB9O1xuICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gIH07XG4gIHZhciBwb3BEaXJ0eVBhdGggPSBlZGl0b3IgPT4ge1xuICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICBnZXREaXJ0eVBhdGhLZXlzKGVkaXRvcikuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG4gIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZm9yY2UpIHtcbiAgICB2YXIgYWxsUGF0aHMgPSBBcnJheS5mcm9tKE5vZGUubm9kZXMoZWRpdG9yKSwgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAocCA9PiBwLmpvaW4oJywnKSkpO1xuICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGFsbFBhdGhzKTtcbiAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgYWxsUGF0aEtleXMpO1xuICB9XG4gIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgLypcbiAgICAgIEZpeCBkaXJ0eSBlbGVtZW50cyB3aXRoIG5vIGNoaWxkcmVuLlxuICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxuICAgICAgUnVubmluZyBhbiBpbml0aWFsIHBhc3MgYXZvaWRzIHRoZSBjYXRjaC0yMiByYWNlIGNvbmRpdGlvbi5cbiAgICAqL1xuICAgIGZvciAodmFyIGRpcnR5UGF0aCBvZiBnZXREaXJ0eVBhdGhzKGVkaXRvcikpIHtcbiAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIGRpcnR5UGF0aCkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICB2YXIgW25vZGUsIF9dID0gZW50cnk7XG4gICAgICAgIC8qXG4gICAgICAgICAgVGhlIGRlZmF1bHQgbm9ybWFsaXplciBpbnNlcnRzIGFuIGVtcHR5IHRleHQgbm9kZSBpbiB0aGlzIHNjZW5hcmlvLCBidXQgaXQgY2FuIGJlIGN1c3RvbWlzZWQuXG4gICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgQXMgbG9uZyBhcyB0aGUgbm9ybWFsaXplciBvbmx5IGluc2VydHMgY2hpbGQgbm9kZXMgZm9yIHRoaXMgY2FzZSBpdCBpcyBzYWZlIHRvIGRvIGluIGFueSBvcmRlcjtcbiAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoZW50cnksIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKCFlZGl0b3Iuc2hvdWxkTm9ybWFsaXplKHtcbiAgICAgICAgZGlydHlQYXRocyxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCxcbiAgICAgICAgb3BlcmF0aW9uXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgX2RpcnR5UGF0aCA9IHBvcERpcnR5UGF0aChlZGl0b3IpO1xuICAgICAgLy8gSWYgdGhlIG5vZGUgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkLlxuICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgX2RpcnR5UGF0aCkpIHtcbiAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKF9lbnRyeSwge1xuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHBhcmVudCA9IGZ1bmN0aW9uIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcblxudmFyIHBhdGhSZWYgPSBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcGF0aCxcbiAgICBhZmZpbml0eSxcbiAgICB1bnJlZigpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSByZWY7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICAgIHBhdGhSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHBhdGhSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUEFUSF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHBhdGggPSBmdW5jdGlvbiBwYXRoKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGRlcHRoLFxuICAgIGVkZ2VcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgfVxuICB9XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBhdCA9IFJhbmdlLmVuZChhdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgIH1cbiAgfVxuICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICBhdCA9IGF0LnBhdGg7XG4gIH1cbiAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgfVxuICByZXR1cm4gYXQ7XG59O1xuXG52YXIgcG9pbnRSZWYgPSBmdW5jdGlvbiBwb2ludFJlZihlZGl0b3IsIHBvaW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBwb2ludCxcbiAgICBhZmZpbml0eSxcbiAgICB1bnJlZigpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSByZWY7XG4gICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgcG9pbnRSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwb2ludFJlZnMgPSBlZGl0b3IgPT4ge1xuICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUE9JTlRfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciBwb2ludCA9IGZ1bmN0aW9uIHBvaW50KGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGVkZ2UgPSAnc3RhcnQnXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgdmFyIHBhdGg7XG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgIH07XG4gIH1cbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICByZXR1cm4gZWRnZSA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogZW5kO1xuICB9XG4gIHJldHVybiBhdDtcbn07XG5cbmZ1bmN0aW9uIHBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgdW5pdCA9ICdvZmZzZXQnLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIGlnbm9yZU5vblNlbGVjdGFibGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIG5vdGVzOlxuICAgICAqXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxuICAgICAqIGFuZCB0aGUgYHVuaXRgIHNwZWNpZmllZC4gIEVhY2ggc3RlcCwgZS5nLiwgYSBsaW5lIG9yIHdvcmQsIG1heVxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcbiAgICAgKlxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxuICAgICAqXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXG4gICAgICpcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG4gICAgdmFyIGxlYWZUZXh0UmVtYWluaW5nID0gMDtcbiAgICB2YXIgbGVhZlRleHRPZmZzZXQgPSAwO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHJldmVyc2UsXG4gICAgICB2b2lkcyxcbiAgICAgIGlnbm9yZU5vblNlbGVjdGFibGVcbiAgICB9KSkge1xuICAgICAgLypcbiAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xuICAgICAgICovXG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgLy8gVm9pZCBub2RlcyBhcmUgYSBzcGVjaWFsIGNhc2UsIHNvIGJ5IGRlZmF1bHQgd2Ugd2lsbCBhbHdheXNcbiAgICAgICAgLy8geWllbGQgdGhlaXIgZmlyc3QgcG9pbnQuIElmIHRoZSBgdm9pZHNgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciB0aGVpciBjb250ZW50LlxuICAgICAgICBpZiAoIXZvaWRzICYmIChlZGl0b3IuaXNWb2lkKG5vZGUpIHx8IGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShub2RlKSkpIHtcbiAgICAgICAgICB5aWVsZCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbmxpbmUgZWxlbWVudCBub2RlcyBhcmUgaWdub3JlZCBhcyB0aGV5IGRvbid0IHRoZW1zZWx2ZXNcbiAgICAgICAgLy8gY29udHJpYnV0ZSB0byBgYmxvY2tUZXh0YCBvciBgbGVhZlRleHRgIC0gdGhlaXIgcGFyZW50IGFuZFxuICAgICAgICAvLyBjaGlsZHJlbiBkby5cbiAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkgY29udGludWU7XG4gICAgICAgIC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuICAgICAgICBpZiAoRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIC8vIFdlIGFsd2F5cyBleGhhdXN0IGJsb2NrIG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJyxcbiAgICAgICAgICAvLyAgICAgYGJsb2NrVGV4dD0nJHtibG9ja1RleHR9JyAtIGArXG4gICAgICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgYmxvY2sgbm9kZWAsIHBhdGgpXG4gICAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvbnNpZGVyZWQgaXMgY2FwcGVkIHRvIGByYW5nZWAsIGluIHRoZVxuICAgICAgICAgIC8vIHN0YXJ0L2VuZCBlZGdlIGNhc2VzIHdoZXJlIGJsb2NrIGV4dGVuZHMgYmV5b25kIHJhbmdlLlxuICAgICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gdGhpcywgYnV0IHByZXN1bWFibHkgbW9yZSBwZXJmb3JtYW50OlxuICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIC4uLkVkaXRvci5lZGdlcyhlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgYmxvY2tSYW5nZSkgLy8gaW50ZXJzZWN0XG4gICAgICAgICAgLy8gICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgYmxvY2tSYW5nZSwgeyB2b2lkcyB9KVxuICAgICAgICAgIHZhciBlID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGVuZC5wYXRoKSA/IGVuZCA6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICB2YXIgcyA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBzdGFydC5wYXRoKSA/IHN0YXJ0IDogRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICAgIGZvY3VzOiBlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpc05ld0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIFRFWFQgTEVBRiBOT0RFIC0gSXRlcmF0ZSB0aHJvdWdoIHRleHQgY29udGVudCwgeWllbGRpbmdcbiAgICAgICAqIHBvc2l0aW9ucyBldmVyeSBgZGlzdGFuY2VgIG9mZnNldCBhY2NvcmRpbmcgdG8gYHVuaXRgLlxuICAgICAgICovXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdmFyIGlzRmlyc3QgPSBQYXRoLmVxdWFscyhwYXRoLCBmaXJzdC5wYXRoKTtcbiAgICAgICAgLy8gUHJvb2YgdGhhdCB3ZSBhbHdheXMgZXhoYXVzdCB0ZXh0IG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBsZWFmIHRleHQgbm9kZWAsIHBhdGgpXG4gICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSByZXZlcnNlID8gZmlyc3Qub2Zmc2V0IDogbm9kZS50ZXh0Lmxlbmd0aCAtIGZpcnN0Lm9mZnNldDtcbiAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IGZpcnN0Lm9mZnNldDsgLy8gV29ya3MgZm9yIHJldmVyc2UgdG9vLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dFJlbWFpbmluZyA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gWWllbGQgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIG5vZGUgKHBvdGVudGlhbGx5KS5cbiAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGhhcyBjYXVnaHQgdXAgd2l0aCBgYmxvY2tUZXh0YCAoZGlzdGFuY2U9MCksXG4gICAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGFkdmFuY2UgYmxvY2tUZXh0IGZvcndhcmQgYnkgdGhlIG5ldyBgZGlzdGFuY2VgLlxuICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoYmxvY2tUZXh0LCB1bml0LCByZXZlcnNlKTtcbiAgICAgICAgICAgIC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIGJsb2NrVGV4dCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShibG9ja1RleHQsIGRpc3RhbmNlLCByZXZlcnNlKVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRPZmZzZXQgLSBkaXN0YW5jZSA6IGxlYWZUZXh0T2Zmc2V0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBsZWFmVGV4dFJlbWFpbmluZyAtIGRpc3RhbmNlO1xuICAgICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYSBuZXcgbGVhZiBub2RlXG4gICAgICAgICAgLy8gYW5kIHNldCBkaXN0YW5jZSB0byB0aGUgb3ZlcmZsb3cgYW1vdW50LCBzbyB3ZSdsbCAobWF5YmUpXG4gICAgICAgICAgLy8gY2F0Y2ggdXAgdG8gYmxvY2tUZXh0IGluIHRoZSBuZXh0IGxlYWYgdGV4dCBub2RlLlxuICAgICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gLWxlYWZUZXh0UmVtYWluaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSB3YWxrZWQgYGRpc3RhbmNlYCBvZmZzZXRzIHRocm91Z2ggYGxlYWZUZXh0YFxuICAgICAgICAgIC8vIHRvIGNhdGNoIHVwIHdpdGggYGJsb2NrVGV4dGAsIHNvIHdlIGNhbiByZXNldCBgZGlzdGFuY2VgXG4gICAgICAgICAgLy8gYW5kIHlpZWxkIHRoaXMgcG9zaXRpb24gaW4gdGhpcyBub2RlLlxuICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJvb2YgdGhhdCB1cG9uIGNvbXBsZXRpb24sIHdlJ3ZlIGV4YWh1c3RlZCBib3RoIGxlYWYgYW5kIGJsb2NrIHRleHQ6XG4gICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLCBcImxlYWZUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsIFwiYmxvY2tUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAvLyBIZWxwZXI6XG4gICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBvZmZzZXRzIGZvciBhIHN0ZXAgb2Ygc2l6ZSBgdW5pdGAgb24gZ2l2ZW4gc3RyaW5nLlxuICAgIGZ1bmN0aW9uIGNhbGNEaXN0YW5jZSh0ZXh0LCB1bml0LCByZXZlcnNlKSB7XG4gICAgICBpZiAodW5pdCA9PT0gJ2NoYXJhY3RlcicpIHtcbiAgICAgICAgcmV0dXJuIGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnd29yZCcpIHtcbiAgICAgICAgcmV0dXJuIGdldFdvcmREaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ2xpbmUnIHx8IHVuaXQgPT09ICdibG9jaycpIHtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KCk7XG59XG5cbnZhciBwcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgIHZvaWRzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgbWF0Y2gsXG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwb2ludEJlZm9yZUxvY2F0aW9uID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCB7XG4gICAgdm9pZHNcbiAgfSk7XG4gIGlmICghcG9pbnRCZWZvcmVMb2NhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgWywgdG9dID0gRWRpdG9yLmZpcnN0KGVkaXRvciwgW10pO1xuICAvLyBUaGUgc2VhcmNoIGxvY2F0aW9uIGlzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB0byB0aGUgcGF0aCBvZlxuICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cbiAgdmFyIHNwYW4gPSBbcG9pbnRCZWZvcmVMb2NhdGlvbi5wYXRoLCB0b107XG4gIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICB9XG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcbiAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdmFyIFtwcmV2aW91c10gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICBhdDogc3BhbixcbiAgICBtYXRjaCxcbiAgICBtb2RlLFxuICAgIHZvaWRzXG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG52YXIgcmFuZ2VSZWYgPSBmdW5jdGlvbiByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiByYW5nZSxcbiAgICBhZmZpbml0eSxcbiAgICB1bnJlZigpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSByZWY7XG4gICAgICB2YXIgcmFuZ2VSZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICAgICAgcmFuZ2VSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciByYW5nZVJlZnMgPSBlZGl0b3IgPT4ge1xuICB2YXIgcmVmcyA9IFJBTkdFX1JFRlMuZ2V0KGVkaXRvcik7XG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciByYW5nZSA9IChlZGl0b3IsIGF0LCB0bykgPT4ge1xuICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgIXRvKSB7XG4gICAgcmV0dXJuIGF0O1xuICB9XG4gIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCB0byB8fCBhdCk7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBzdGFydCxcbiAgICBmb2N1czogZW5kXG4gIH07XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIHJlbW92ZU1hcmsgPSAoZWRpdG9yLCBrZXkpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHZhciBtYXRjaCA9IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICB9XG5cbiAgICAgIHZhciBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBbc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpO1xuICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDIoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KTtcbiAgICAgIGRlbGV0ZSBtYXJrc1trZXldO1xuICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNldE5vcm1hbGl6aW5nID0gKGVkaXRvciwgaXNOb3JtYWxpemluZykgPT4ge1xuICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbn07XG5cbnZhciBzdGFydCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG59O1xuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIHZvaWRzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgdmFyIHRleHQgPSAnJztcbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogcmFuZ2UsXG4gICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgIHZvaWRzXG4gIH0pKSB7XG4gICAgdmFyIHQgPSBub2RlLnRleHQ7XG4gICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgdCA9IHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgfVxuICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgdCA9IHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICB9XG4gICAgdGV4dCArPSB0O1xuICB9XG4gIHJldHVybiB0ZXh0O1xufTtcblxudmFyIHVuaGFuZ1JhbmdlID0gZnVuY3Rpb24gdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG4gIGlmIChzdGFydC5vZmZzZXQgIT09IDAgfHwgZW5kLm9mZnNldCAhPT0gMCB8fCBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgfHwgUGF0aC5oYXNQcmV2aW91cyhlbmQucGF0aCkpIHtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIGF0OiBlbmQsXG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICB2b2lkc1xuICB9KTtcbiAgdmFyIGJsb2NrUGF0aCA9IGVuZEJsb2NrID8gZW5kQmxvY2tbMV0gOiBbXTtcbiAgdmFyIGZpcnN0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgc3RhcnQpO1xuICB2YXIgYmVmb3JlID0ge1xuICAgIGFuY2hvcjogZmlyc3QsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xuICB2YXIgc2tpcCA9IHRydWU7XG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGJlZm9yZSxcbiAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICB2b2lkc1xuICB9KSkge1xuICAgIGlmIChza2lwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUudGV4dCAhPT0gJycgfHwgUGF0aC5pc0JlZm9yZShwYXRoLCBibG9ja1BhdGgpKSB7XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogbm9kZS50ZXh0Lmxlbmd0aFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcjogc3RhcnQsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xufTtcblxudmFyIHdpdGhvdXROb3JtYWxpemluZyA9IChlZGl0b3IsIGZuKSA9PiB7XG4gIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIGZhbHNlKTtcbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgfVxuICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG59O1xuXG52YXIgc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlID0gKGVkaXRvciwgX3JlZiwgX3JlZjIpID0+IHtcbiAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gX3JlZjtcbiAgLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAvLyBvZiBtZXJnaW5nIHRoZSB0d28uIFRoaXMgaXMgYSBjb21tb24gcmljaCB0ZXh0IGVkaXRvciBiZWhhdmlvciB0b1xuICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgLy8gaWYgcHJldk5vZGUgaXMgZmlyc3QgY2hpbGQgaW4gcGFyZW50LGRvbid0IHJlbW92ZSBpdC5cbiAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycgJiYgcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV0gIT09IDA7XG59O1xuXG52YXIgZGVsZXRlVGV4dCA9IGZ1bmN0aW9uIGRlbGV0ZVRleHQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIgX0VkaXRvciR2b2lkLCBfRWRpdG9yJHZvaWQyO1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlzQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgfVxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIGlmICghdm9pZHMgJiYgZnVydGhlc3RWb2lkKSB7XG4gICAgICAgIHZhciBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWQ7XG4gICAgICAgIGF0ID0gdm9pZFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICB1bml0LFxuICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXJnZXQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSkgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgYXQgPSB7XG4gICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICBmb2N1czogdGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaGFuZ2luZykge1xuICAgICAgdmFyIFssIF9lbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgIGlmICghUG9pbnQuZXF1YWxzKF9lbmQsIGVuZE9mRG9jKSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgdmFyIHN0YXJ0QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgYXQ6IGVuZCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIGlzQWNyb3NzQmxvY2tzID0gc3RhcnRCbG9jayAmJiBlbmRCbG9jayAmJiAhUGF0aC5lcXVhbHMoc3RhcnRCbG9ja1sxXSwgZW5kQmxvY2tbMV0pO1xuICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgdmFyIHN0YXJ0Tm9uRWRpdGFibGUgPSB2b2lkcyA/IG51bGwgOiAoX0VkaXRvciR2b2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogc3RhcnQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkgIT09IG51bGwgJiYgX0VkaXRvciR2b2lkICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQgOiBFZGl0b3IuZWxlbWVudFJlYWRPbmx5KGVkaXRvciwge1xuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSk7XG4gICAgdmFyIGVuZE5vbkVkaXRhYmxlID0gdm9pZHMgPyBudWxsIDogKF9FZGl0b3Ikdm9pZDIgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkgIT09IG51bGwgJiYgX0VkaXRvciR2b2lkMiAhPT0gdm9pZCAwID8gX0VkaXRvciR2b2lkMiA6IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICBhdDogZW5kLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSk7XG4gICAgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludHMgYXJlIGluc2lkZSBhbiBpbmxpbmUgdm9pZCwgbnVkZ2UgdGhlbSBvdXQuXG4gICAgaWYgKHN0YXJ0Tm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuICAgICAgaWYgKGJlZm9yZSAmJiBzdGFydEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihzdGFydEJsb2NrWzFdLCBiZWZvcmUucGF0aCkpIHtcbiAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcbiAgICAgIGlmIChhZnRlciAmJiBlbmRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3IoZW5kQmxvY2tbMV0sIGFmdGVyLnBhdGgpKSB7XG4gICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIGhpZ2hlc3Qgbm9kZXMgdGhhdCBhcmUgY29tcGxldGVseSBpbnNpZGUgdGhlIHJhbmdlLCBhcyB3ZWxsIGFzXG4gICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMuXG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgbGFzdFBhdGg7XG4gICAgZm9yICh2YXIgZW50cnkgb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgICBpZiAobGFzdFBhdGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGxhc3RQYXRoKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSB8fCBFZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBub2RlKSkgfHwgIVBhdGguaXNDb21tb24ocGF0aCwgc3RhcnQucGF0aCkgJiYgIVBhdGguaXNDb21tb24ocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgIGxhc3RQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgdmFyIHJlbW92ZWRUZXh0ID0gJyc7XG4gICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Tm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgdmFyIFtfbm9kZV0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludCk7XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgfSA9IF9wb2ludDtcbiAgICAgIHZhciB7XG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHN0YXJ0O1xuICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoUmVmcy5yZXZlcnNlKCkubWFwKHIgPT4gci51bnJlZigpKS5maWx0ZXIociA9PiByICE9PSBudWxsKS5mb3JFYWNoKHAgPT4gVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwLFxuICAgICAgdm9pZHNcbiAgICB9KSk7XG4gICAgaWYgKCFlbmROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIF9wb2ludDIgPSBlbmRSZWYuY3VycmVudDtcbiAgICAgIHZhciBbX25vZGUyXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50Mik7XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgIH0gPSBfcG9pbnQyO1xuICAgICAgdmFyIF9vZmZzZXQgPSBpc1NpbmdsZVRleHQgPyBzdGFydC5vZmZzZXQgOiAwO1xuICAgICAgdmFyIF90ZXh0ID0gX25vZGUyLnRleHQuc2xpY2UoX29mZnNldCwgZW5kLm9mZnNldCk7XG4gICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgcGF0aDogX3BhdGgyLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSBfdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgaXNBY3Jvc3NCbG9ja3MgJiYgZW5kUmVmLmN1cnJlbnQgJiYgc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIGhhbmdpbmc6IHRydWUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gRm9yIFRoYWkgc2NyaXB0LCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgLy8gTiBjb2RlIHBvaW50KHMpIGluc3RlYWQgb2YgYW4gZW50aXJlIGdyYXBoZW1lIGNsdXN0ZXIuXG4gICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgdmFyIGVuZFVucmVmID0gZW5kUmVmLnVucmVmKCk7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0RnJhZ21lbnQgPSBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpLFxuICAgICAgYmF0Y2hEaXJ0eSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYmVmb3JlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGJsb2NrUGF0aF0gPSBibG9ja01hdGNoO1xuICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgdmFyIGlzQmxvY2tFbXB0eSA9IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgIHZhciBtZXJnZVN0YXJ0ID0gIWlzQmxvY2tTdGFydCB8fCBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcbiAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3Qoe1xuICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgfSwgW10pO1xuICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3Qoe1xuICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgfSwgW10pO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIG1hdGNoZXIgPSBfcmVmID0+IHtcbiAgICAgIHZhciBbbiwgcF0gPSBfcmVmO1xuICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1lcmdlU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICB9LCB7XG4gICAgICBwYXNzOiBtYXRjaGVyXG4gICAgfSkpIHtcbiAgICAgIGlmIChtYXRjaGVyKGVudHJ5KSkge1xuICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RhcnRzID0gW107XG4gICAgdmFyIG1pZGRsZXMgPSBbXTtcbiAgICB2YXIgZW5kcyA9IFtdO1xuICAgIHZhciBzdGFydGluZyA9IHRydWU7XG4gICAgdmFyIGhhc0Jsb2NrcyA9IGZhbHNlO1xuICAgIGZvciAodmFyIFtub2RlXSBvZiBtYXRjaGVzKSB7XG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICBoYXNCbG9ja3MgPSB0cnVlO1xuICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgIHN0YXJ0cy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgW2lubGluZU1hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBbLCBpbmxpbmVQYXRoXSA9IGlubGluZU1hdGNoO1xuICAgIHZhciBpc0lubGluZVN0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgIHZhciBtaWRkbGVSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzQmxvY2tFbmQgJiYgIWVuZHMubGVuZ3RoID8gUGF0aC5uZXh0KGJsb2NrUGF0aCkgOiBibG9ja1BhdGgpO1xuICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBoYXNCbG9ja3MgPyBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgIGFsd2F5czogaGFzQmxvY2tzICYmICghaXNCbG9ja1N0YXJ0IHx8IHN0YXJ0cy5sZW5ndGggPiAwKSAmJiAoIWlzQmxvY2tFbmQgfHwgZW5kcy5sZW5ndGggPiAwKSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCAhaXNJbmxpbmVTdGFydCB8fCBpc0lubGluZVN0YXJ0ICYmIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHN0YXJ0cywge1xuICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzLFxuICAgICAgYmF0Y2hEaXJ0eVxuICAgIH0pO1xuICAgIGlmIChpc0Jsb2NrRW1wdHkgJiYgIXN0YXJ0cy5sZW5ndGggJiYgbWlkZGxlcy5sZW5ndGggJiYgIWVuZHMubGVuZ3RoKSB7XG4gICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgdm9pZHMsXG4gICAgICBiYXRjaERpcnR5XG4gICAgfSk7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHMsXG4gICAgICBiYXRjaERpcnR5XG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDAgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtaWRkbGVzLmxlbmd0aCA+IDAgJiYgbWlkZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMobWlkZGxlUmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKHN0YXJ0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIF9lbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgbWlkZGxlUmVmLnVucmVmKCk7XG4gICAgZW5kUmVmLnVucmVmKCk7XG4gIH0pO1xufTtcblxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBlZGdlID0gJ2FuY2hvcidcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzdGFydCk7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBlbmQpO1xuICB9XG59O1xuXG52YXIgZGVzZWxlY3QgPSBlZGl0b3IgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciB7XG4gICAgZGlzdGFuY2UgPSAxLFxuICAgIHVuaXQgPSAnY2hhcmFjdGVyJyxcbiAgICByZXZlcnNlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgZWRnZSA9IG51bGxcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICB9XG4gIHZhciB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIHZhciBvcHRzID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIHVuaXQsXG4gICAgaWdub3JlTm9uU2VsZWN0YWJsZTogdHJ1ZVxuICB9O1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYW5jaG9yLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvciwgb3B0cyk7XG4gICAgaWYgKHBvaW50KSB7XG4gICAgICBwcm9wcy5hbmNob3IgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuICAgIGlmIChfcG9pbnQpIHtcbiAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgIH1cbiAgfVxuICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKTtcbn07XG5cbnZhciBzZWxlY3QgPSAoZWRpdG9yLCB0YXJnZXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgdGFyZ2V0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgdGFyZ2V0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gIH1cbiAgZWRpdG9yLmFwcGx5KHtcbiAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQxKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQxKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiBzZXRQb2ludChlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBlZGdlID0gJ2JvdGgnXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgfVxuICB2YXIge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICBbZWRnZSA9PT0gJ2FuY2hvcicgPyAnYW5jaG9yJyA6ICdmb2N1cyddOiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb2ludCksIHByb3BzKVxuICB9KTtcbn07XG5cbnZhciBzZXRTZWxlY3Rpb24gPSAoZWRpdG9yLCBwcm9wcykgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgdmFyIG5ld1Byb3BzID0ge307XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICBpZiAoayA9PT0gJ2FuY2hvcicgJiYgcHJvcHMuYW5jaG9yICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5hbmNob3IsIHNlbGVjdGlvbi5hbmNob3IpIHx8IGsgPT09ICdmb2N1cycgJiYgcHJvcHMuZm9jdXMgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmZvY3VzLCBzZWxlY3Rpb24uZm9jdXMpIHx8IGsgIT09ICdhbmNob3InICYmIGsgIT09ICdmb2N1cycgJiYgcHJvcHNba10gIT09IHNlbGVjdGlvbltrXSkge1xuICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXMob2xkUHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgcHJvcGVydGllczogb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaW5zZXJ0Tm9kZXMgPSBmdW5jdGlvbiBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIGJhdGNoRGlydHkgPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBzZWxlY3RcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFtub2RlXSA9IG5vZGVzO1xuICAgIGlmICghYXQpIHtcbiAgICAgIGF0ID0gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcik7XG4gICAgICBpZiAoc2VsZWN0ICE9PSBmYWxzZSkge1xuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgIHNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIFtlbnRyeV0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdC5wYXRoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhciBbLCBtYXRjaFBhdGhdID0gZW50cnk7XG4gICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBtYXRjaFBhdGgpO1xuICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBtYXRjaFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIGF0ID0gaXNBdEVuZCA/IFBhdGgubmV4dChwYXRoKSA6IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQoYXQpO1xuICAgIHZhciBpbmRleCA9IGF0W2F0Lmxlbmd0aCAtIDFdO1xuICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcGFyZW50UGF0aFxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChiYXRjaERpcnR5KSB7XG4gICAgICAvLyBQRVJGOiBiYXRjaCB1cGRhdGUgZGlydHkgcGF0aHNcbiAgICAgIC8vIGJhdGNoZWQgb3BzIHVzZWQgdG8gdHJhbnNmb3JtIGV4aXN0aW5nIGRpcnR5IHBhdGhzXG4gICAgICB2YXIgYmF0Y2hlZE9wcyA9IFtdO1xuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBQYXRoLmxldmVscyhwYXJlbnRQYXRoKTtcbiAgICAgIGJhdGNoRGlydHlQYXRocyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICB2YXIgb3AgPSB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG5vZGU6IF9ub2RlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkob3ApO1xuICAgICAgICAgIGF0ID0gUGF0aC5uZXh0KGF0KTtcbiAgICAgICAgICBiYXRjaGVkT3BzLnB1c2gob3ApO1xuICAgICAgICAgIGlmICghVGV4dC5pc1RleHQpIHtcbiAgICAgICAgICAgIG5ld0RpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3RGlydHlQYXRocy5wdXNoKC4uLkFycmF5LmZyb20oTm9kZS5ub2Rlcyhfbm9kZSksIF9yZWYgPT4ge1xuICAgICAgICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICAgICAgICByZXR1cm4gcGF0aC5jb25jYXQocCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdXBkYXRlRGlydHlQYXRocyhlZGl0b3IsIG5ld0RpcnR5UGF0aHMsIHAgPT4ge1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gcDtcbiAgICAgICAgICBmb3IgKHZhciBvcCBvZiBiYXRjaGVkT3BzKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgICAgICAgICAgICBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0obmV3UGF0aCwgb3ApO1xuICAgICAgICAgICAgICBpZiAoIW5ld1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3UGF0aDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX25vZGUyIG9mIG5vZGVzKSB7XG4gICAgICAgIHZhciBfcGF0aCA9IHBhcmVudFBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG5vZGU6IF9ub2RlMlxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuICAgIGlmIChzZWxlY3QpIHtcbiAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBsaWZ0Tm9kZXMgPSBmdW5jdGlvbiBsaWZ0Tm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgIHZhciBbcGFyZW50LCBwYXJlbnRQYXRoXSA9IHBhcmVudE5vZGVFbnRyeTtcbiAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIHRvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IHRvUGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBfdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogX3RvUGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG4gICAgICAgIHZhciBfdG9QYXRoMiA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzcGxpdFBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBfdG9QYXRoMixcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcbnZhciBoYXNTaW5nbGVDaGlsZE5lc3QgPSAoZWRpdG9yLCBub2RlKSA9PiB7XG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgZWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIG1lcmdlTm9kZXMgPSBmdW5jdGlvbiBtZXJnZU5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgW2N1cnJlbnRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIHZvaWRzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIHZvaWRzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgW25vZGUsIHBhdGhdID0gY3VycmVudDtcbiAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocHJldlBhdGgpO1xuICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24ocGF0aCwgcHJldlBhdGgpO1xuICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICB2YXIgbGV2ZWxzID0gQXJyYXkuZnJvbShFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KSwgX3JlZiA9PiB7XG4gICAgICB2YXIgW25dID0gX3JlZjtcbiAgICAgIHJldHVybiBuO1xuICAgIH0pLnNsaWNlKGNvbW1vblBhdGgubGVuZ3RoKS5zbGljZSgwLCAtMSk7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAvLyByZXN1bHQsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byByZW1vdmUgaXQgYWZ0ZXIgbWVyZ2luZy5cbiAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgbWF0Y2g6IG4gPT4gbGV2ZWxzLmluY2x1ZGVzKG4pICYmIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIG4pXG4gICAgfSk7XG4gICAgdmFyIGVtcHR5UmVmID0gZW1wdHlBbmNlc3RvciAmJiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGVtcHR5QW5jZXN0b3JbMV0pO1xuICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgIHZhciBwb3NpdGlvbjtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgLy8gYW5kIGV4dHJhIHByb3BlcnRpZXMgb2YgdGhlIG1lcmdlIHdpbGwgYmUuXG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkKTtcbiAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGg7XG4gICAgICBwcm9wZXJ0aWVzID0gcmVzdDtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSkge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG4gICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2Tm9kZSkpKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgaXNuJ3QgYWxyZWFkeSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBwcmV2aW91cyBub2RlLCBtb3ZlXG4gICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cbiAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIHdhcyBnb2luZyB0byBiZSBhbiBlbXB0eSBhbmNlc3RvciBvZiB0aGUgbm9kZSB0aGF0IHdhcyBtZXJnZWQsXG4gICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG4gICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW1wdHlSZWYuY3VycmVudCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoRWRpdG9yLnNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZShlZGl0b3IsIHByZXYsIGN1cnJlbnQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcHJvcGVydGllc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIG1vdmVOb2RlcyA9IChlZGl0b3IsIG9wdGlvbnMpID0+IHtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgdG8sXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIHZhciB0b1JlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgdG8pO1xuICAgIHZhciB0YXJnZXRzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20odGFyZ2V0cywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgbmV3UGF0aCA9IHRvUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgIC8vIHRvIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGluc3RlYWQgb2YgYWZ0ZXIuIFRvIGVuc3VyZSBvdXIgZ3JvdXAgb2Ygbm9kZXMgYXJlIGluc2VydGVkXG4gICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRvUmVmLnVucmVmKCk7XG4gIH0pO1xufTtcblxudmFyIHJlbW92ZU5vZGVzID0gZnVuY3Rpb24gcmVtb3ZlTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZGVwdGhzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20oZGVwdGhzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgc2V0Tm9kZXMgPSBmdW5jdGlvbiBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBjb21wYXJlLFxuICAgICAgbWVyZ2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpICYmIEVkaXRvci5sZWFmKGVkaXRvciwgYXQuYW5jaG9yKVswXS50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAvLyBzZXQgdGhhdCB3b24ndCBnZXQgbm9ybWFsaXplZCBhd2F5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICB2YXIgZW5kQXRFbmRPZk5vZGUgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBlbmQsIGVuZC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIGFsd2F5czogIWVuZEF0RW5kT2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29tcGFyZSkge1xuICAgICAgY29tcGFyZSA9IChwcm9wLCBub2RlUHJvcCkgPT4gcHJvcCAhPT0gbm9kZVByb3A7XG4gICAgfVxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAvLyBGSVhNRTogaXMgdGhpcyBjb3JyZWN0P1xuICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgIC8vIFlvdSBjYW4ndCBzZXQgcHJvcGVydGllcyBvbiB0aGUgZWRpdG9yIG5vZGUuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICBpZiAoayA9PT0gJ2NoaWxkcmVuJyB8fCBrID09PSAndGV4dCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZShwcm9wc1trXSwgbm9kZVtrXSkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAvLyBPbWl0IG5ldyBwcm9wZXJ0aWVzIGZyb20gdGhlIG9sZCBwcm9wZXJ0aWVzIGxpc3RcbiAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrKSkgcHJvcGVydGllc1trXSA9IG5vZGVba107XG4gICAgICAgICAgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gcHJvcHNba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlcykge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHJhbmdlIGludG8gYSBwb2ludCBieSBkZWxldGluZyBpdCdzIGNvbnRlbnQuXG4gKi9cbnZhciBkZWxldGVSYW5nZSA9IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRSZWYudW5yZWYoKTtcbiAgfVxufTtcbnZhciBzcGxpdE5vZGVzID0gZnVuY3Rpb24gc3BsaXROb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gZGVsZXRlUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwYXRoLCB0aGUgZGVmYXVsdCBoZWlnaHQtc2tpcHBpbmcgYW5kIHBvc2l0aW9uXG4gICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgcGF0aCA9IGF0O1xuICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCk7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICBtYXRjaCA9IG4gPT4gbiA9PT0gcGFyZW50O1xuICAgICAgaGVpZ2h0ID0gcG9pbnQucGF0aC5sZW5ndGggLSBwYXRoLmxlbmd0aCArIDE7XG4gICAgICBhdCA9IHBvaW50O1xuICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYmVmb3JlUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgdmFyIGFmdGVyUmVmO1xuICAgIHRyeSB7XG4gICAgICB2YXIgW2hpZ2hlc3RdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIGlmICghaGlnaGVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIG51ZGdlID0gMDtcbiAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgIHZhciBbdm9pZE5vZGUsIHZvaWRQYXRoXSA9IHZvaWRNYXRjaDtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgdm9pZFBhdGgpO1xuICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZnRlclBhdGggPSBQYXRoLm5leHQodm9pZFBhdGgpO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHRleHQsIHtcbiAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpYmxpbmdIZWlnaHQgPSBhdC5wYXRoLmxlbmd0aCAtIHZvaWRQYXRoLmxlbmd0aDtcbiAgICAgICAgaGVpZ2h0ID0gc2libGluZ0hlaWdodCArIDE7XG4gICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgIHZhciBkZXB0aCA9IGF0LnBhdGgubGVuZ3RoIC0gaGVpZ2h0O1xuICAgICAgdmFyIFssIGhpZ2hlc3RQYXRoXSA9IGhpZ2hlc3Q7XG4gICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gaGVpZ2h0ID09PSAwID8gYXQub2Zmc2V0IDogYXQucGF0aFtkZXB0aF0gKyBudWRnZTtcbiAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aF0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKF9wYXRoLmxlbmd0aCA8IGhpZ2hlc3RQYXRoLmxlbmd0aCB8fCBfcGF0aC5sZW5ndGggPT09IDAgfHwgIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcG9pbnQgPSBiZWZvcmVSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aCk7XG4gICAgICAgIGlmIChhbHdheXMgfHwgIWJlZm9yZVJlZiB8fCAhRWRpdG9yLmlzRWRnZShlZGl0b3IsIF9wb2ludCwgX3BhdGgpKSB7XG4gICAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gTm9kZS5leHRyYWN0UHJvcHMobm9kZSk7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gPSBfcGF0aFtfcGF0aC5sZW5ndGggLSAxXSArIChzcGxpdCB8fCBpc0VuZCA/IDEgOiAwKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50Mik7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBfYWZ0ZXJSZWY7XG4gICAgICBiZWZvcmVSZWYudW5yZWYoKTtcbiAgICAgIChfYWZ0ZXJSZWYgPSBhZnRlclJlZikgPT09IG51bGwgfHwgX2FmdGVyUmVmID09PSB2b2lkIDAgfHwgX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciB1bnNldE5vZGVzID0gZnVuY3Rpb24gdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIHByb3BzID0gW3Byb3BzXTtcbiAgfVxuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgIG9ialtrZXldID0gbnVsbDtcbiAgfVxuICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgb2JqLCBvcHRpb25zKTtcbn07XG5cbnZhciB1bndyYXBOb2RlcyA9IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIH1cbiAgICB2YXIgcmFuZ2VSZWYgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0KSA6IG51bGw7XG4gICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9XG4gICAgLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgLy8gSWYgd2UgZG8gbm90IHJldmVyc2UgdGhlIG9yZGVyIGFuZCBjYWxsIGl0IGZyb20gdG9wIHRvIHRoZSBib3R0b20sIGl0IHdpbGwgcmVtb3ZlIGFsbCBibG9ja3NcbiAgICAvLyB0aGF0IHdyYXAgdGFyZ2V0IG5vZGUuIFNvIHdlIHJldmVyc2UgdGhlIG9yZGVyLlxuICAgICkucmV2ZXJzZSgpO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlUmVmLmN1cnJlbnQsIHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIHdyYXBOb2RlcyA9IGZ1bmN0aW9uIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikgfHwgVGV4dC5pc1RleHQobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBuID0+IEVkaXRvci5pc0VkaXRvcihuKSxcbiAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KSk7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBhID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBSYW5nZS5pbnRlcnNlY3Rpb24oYXQsIEVkaXRvci5yYW5nZShlZGl0b3IsIHJvb3RQYXRoKSkgOiBhdDtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBbZmlyc3RdID0gbWF0Y2hlcztcbiAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IGZpcnN0O1xuICAgICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBsYXN0O1xuICAgICAgICAgIGlmIChmaXJzdFBhdGgubGVuZ3RoID09PSAwICYmIGxhc3RQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtYXRjaGluZyBwYXJlbnQgLSB1c3VhbGx5IG1lYW5zIHRoZSBub2RlIGlzIGFuIGVkaXRvciAtIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmVxdWFscyhmaXJzdFBhdGgsIGxhc3RQYXRoKSA/IFBhdGgucGFyZW50KGZpcnN0UGF0aCkgOiBQYXRoLmNvbW1vbihmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICB2YXIgW2NvbW1vbk5vZGVdID0gY29tbW9uTm9kZUVudHJ5O1xuICAgICAgICAgIHZhciBkZXB0aCA9IGNvbW1vblBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcbiAgICAgICAgICB2YXIgd3JhcHBlciA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgd3JhcHBlciwge1xuICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihjb21tb25Ob2RlKSAmJiBjb21tb25Ob2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfcmV0O1xuICAgIGZvciAodmFyIFssIHJvb3RQYXRoXSBvZiByb290cykge1xuICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzRWxlbWVudFJlYWRPbmx5OiAoKSA9PiBmYWxzZSxcbiAgICBpc0lubGluZTogKCkgPT4gZmFsc2UsXG4gICAgaXNTZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxuICAgIGlzVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgbWFya2FibGVWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgLy8gQ29yZVxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBwbHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIC8vIEVkaXRvclxuICAgIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkTWFyayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUZvcndhcmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZUZyYWdtZW50OiBmdW5jdGlvbiBkZWxldGVGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVGcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uIGdldEZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0QnJlYWsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjgpLCBfa2V5OCA9IDA7IF9rZXk4IDwgX2xlbjg7IF9rZXk4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OF0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydFNvZnRCcmVhayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydEZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTBdID0gYXJndW1lbnRzW19rZXkxMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0Tm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjExID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydFRleHQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5vZGU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEyKSwgX2tleTEyID0gMDsgX2tleTEyIDwgX2xlbjEyOyBfa2V5MTIrKykge1xuICAgICAgICBhcmdzW19rZXkxMl0gPSBhcmd1bWVudHNbX2tleTEyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVOb2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMyksIF9rZXkxMyA9IDA7IF9rZXkxMyA8IF9sZW4xMzsgX2tleTEzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTNdID0gYXJndW1lbnRzW19rZXkxM107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlTWFyayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0RGlydHlQYXRoczogZnVuY3Rpb24gZ2V0RGlydHlQYXRocyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTQpLCBfa2V5MTQgPSAwOyBfa2V5MTQgPCBfbGVuMTQ7IF9rZXkxNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE0XSA9IGFyZ3VtZW50c1tfa2V5MTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldERpcnR5UGF0aHMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogZnVuY3Rpb24gc2hvdWxkTm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNSksIF9rZXkxNSA9IDA7IF9rZXkxNSA8IF9sZW4xNTsgX2tleTE1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTVdID0gYXJndW1lbnRzW19rZXkxNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTm9ybWFsaXplKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICAvLyBFZGl0b3IgaW50ZXJmYWNlXG4gICAgYWJvdmU6IGZ1bmN0aW9uIGFib3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNiksIF9rZXkxNiA9IDA7IF9rZXkxNiA8IF9sZW4xNjsgX2tleTE2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTZdID0gYXJndW1lbnRzW19rZXkxNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWJvdmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlciQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTcpLCBfa2V5MTcgPSAwOyBfa2V5MTcgPCBfbGVuMTc7IF9rZXkxNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE3XSA9IGFyZ3VtZW50c1tfa2V5MTddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFmdGVyKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTgpLCBfa2V5MTggPSAwOyBfa2V5MTggPCBfbGVuMTg7IF9rZXkxOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE4XSA9IGFyZ3VtZW50c1tfa2V5MThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJlZm9yZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOSksIF9rZXkxOSA9IDA7IF9rZXkxOSA8IF9sZW4xOTsgX2tleTE5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTldID0gYXJndW1lbnRzW19rZXkxOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGFwc2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIwKSwgX2tleTIwID0gMDsgX2tleTIwIDwgX2xlbjIwOyBfa2V5MjArKykge1xuICAgICAgICBhcmdzW19rZXkyMF0gPSBhcmd1bWVudHNbX2tleTIwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVUZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIxKSwgX2tleTIxID0gMDsgX2tleTIxIDwgX2xlbjIxOyBfa2V5MjErKykge1xuICAgICAgICBhcmdzW19rZXkyMV0gPSBhcmd1bWVudHNbX2tleTIxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNlbGVjdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMiksIF9rZXkyMiA9IDA7IF9rZXkyMiA8IF9sZW4yMjsgX2tleTIyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjJdID0gYXJndW1lbnRzW19rZXkyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRnZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVsZW1lbnRSZWFkT25seTogZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMyksIF9rZXkyMyA9IDA7IF9rZXkyMyA8IF9sZW4yMzsgX2tleTIzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjNdID0gYXJndW1lbnRzW19rZXkyM107XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFJlYWRPbmx5KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjQpLCBfa2V5MjQgPSAwOyBfa2V5MjQgPCBfbGVuMjQ7IF9rZXkyNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI0XSA9IGFyZ3VtZW50c1tfa2V5MjRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNSksIF9rZXkyNSA9IDA7IF9rZXkyNSA8IF9sZW4yNTsgX2tleTI1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjVdID0gYXJndW1lbnRzW19rZXkyNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjYpLCBfa2V5MjYgPSAwOyBfa2V5MjYgPCBfbGVuMjY7IF9rZXkyNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI2XSA9IGFyZ3VtZW50c1tfa2V5MjZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXRNYXJrczogZnVuY3Rpb24gZ2V0TWFya3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNyksIF9rZXkyNyA9IDA7IF9rZXkyNyA8IF9sZW4yNzsgX2tleTI3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjddID0gYXJndW1lbnRzW19rZXkyN107XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3MoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc0Jsb2NrczogZnVuY3Rpb24gaGFzQmxvY2tzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOCksIF9rZXkyOCA9IDA7IF9rZXkyOCA8IF9sZW4yODsgX2tleTI4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjhdID0gYXJndW1lbnRzW19rZXkyOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzQmxvY2tzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNJbmxpbmVzOiBmdW5jdGlvbiBoYXNJbmxpbmVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOSksIF9rZXkyOSA9IDA7IF9rZXkyOSA8IF9sZW4yOTsgX2tleTI5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjldID0gYXJndW1lbnRzW19rZXkyOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzSW5saW5lcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaGFzUGF0aDogZnVuY3Rpb24gaGFzUGF0aCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzApLCBfa2V5MzAgPSAwOyBfa2V5MzAgPCBfbGVuMzA7IF9rZXkzMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMwXSA9IGFyZ3VtZW50c1tfa2V5MzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1BhdGgoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc1RleHRzOiBmdW5jdGlvbiBoYXNUZXh0cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzEpLCBfa2V5MzEgPSAwOyBfa2V5MzEgPCBfbGVuMzE7IF9rZXkzMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMxXSA9IGFyZ3VtZW50c1tfa2V5MzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1RleHRzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlczogZnVuY3Rpb24gaW5zZXJ0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMyKSwgX2tleTMyID0gMDsgX2tleTMyIDwgX2xlbjMyOyBfa2V5MzIrKykge1xuICAgICAgICBhcmdzW19rZXkzMl0gPSBhcmd1bWVudHNbX2tleTMyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNCbG9jazogZnVuY3Rpb24gaXNCbG9jayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzMpLCBfa2V5MzMgPSAwOyBfa2V5MzMgPCBfbGVuMzM7IF9rZXkzMysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMzXSA9IGFyZ3VtZW50c1tfa2V5MzNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQmxvY2soZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNCksIF9rZXkzNCA9IDA7IF9rZXkzNCA8IF9sZW4zNDsgX2tleTM0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzRdID0gYXJndW1lbnRzW19rZXkzNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFZGdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNSksIF9rZXkzNSA9IDA7IF9rZXkzNSA8IF9sZW4zNTsgX2tleTM1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzVdID0gYXJndW1lbnRzW19rZXkzNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbXB0eShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNFbmQ6IGZ1bmN0aW9uIGlzRW5kJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNiksIF9rZXkzNiA9IDA7IF9rZXkzNiA8IF9sZW4zNjsgX2tleTM2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzZdID0gYXJndW1lbnRzW19rZXkzNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzTm9ybWFsaXppbmc6IGZ1bmN0aW9uIGlzTm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM3KSwgX2tleTM3ID0gMDsgX2tleTM3IDwgX2xlbjM3OyBfa2V5MzcrKykge1xuICAgICAgICBhcmdzW19rZXkzN10gPSBhcmd1bWVudHNbX2tleTM3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc05vcm1hbGl6aW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOCksIF9rZXkzOCA9IDA7IF9rZXkzOCA8IF9sZW4zODsgX2tleTM4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzhdID0gYXJndW1lbnRzW19rZXkzOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdGFydChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbGFzdDogZnVuY3Rpb24gbGFzdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzkpLCBfa2V5MzkgPSAwOyBfa2V5MzkgPCBfbGVuMzk7IF9rZXkzOSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM5XSA9IGFyZ3VtZW50c1tfa2V5MzldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxlYWY6IGZ1bmN0aW9uIGxlYWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQwKSwgX2tleTQwID0gMDsgX2tleTQwIDwgX2xlbjQwOyBfa2V5NDArKykge1xuICAgICAgICBhcmdzW19rZXk0MF0gPSBhcmd1bWVudHNbX2tleTQwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWFmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDEpLCBfa2V5NDEgPSAwOyBfa2V5NDEgPCBfbGVuNDE7IF9rZXk0MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQxXSA9IGFyZ3VtZW50c1tfa2V5NDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVscyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbGlmdE5vZGVzOiBmdW5jdGlvbiBsaWZ0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQyKSwgX2tleTQyID0gMDsgX2tleTQyIDwgX2xlbjQyOyBfa2V5NDIrKykge1xuICAgICAgICBhcmdzW19rZXk0Ml0gPSBhcmd1bWVudHNbX2tleTQyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaWZ0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1lcmdlTm9kZXM6IGZ1bmN0aW9uIG1lcmdlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQzKSwgX2tleTQzID0gMDsgX2tleTQzIDwgX2xlbjQzOyBfa2V5NDMrKykge1xuICAgICAgICBhcmdzW19rZXk0M10gPSBhcmd1bWVudHNbX2tleTQzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NCksIF9rZXk0NCA9IDA7IF9rZXk0NCA8IF9sZW40NDsgX2tleTQ0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDRdID0gYXJndW1lbnRzW19rZXk0NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbW92ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbW92ZU5vZGVzOiBmdW5jdGlvbiBtb3ZlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ1KSwgX2tleTQ1ID0gMDsgX2tleTQ1IDwgX2xlbjQ1OyBfa2V5NDUrKykge1xuICAgICAgICBhcmdzW19rZXk0NV0gPSBhcmd1bWVudHNbX2tleTQ1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3ZlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ2KSwgX2tleTQ2ID0gMDsgX2tleTQ2IDwgX2xlbjQ2OyBfa2V5NDYrKykge1xuICAgICAgICBhcmdzW19rZXk0Nl0gPSBhcmd1bWVudHNbX2tleTQ2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub2RlOiBmdW5jdGlvbiBub2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NyksIF9rZXk0NyA9IDA7IF9rZXk0NyA8IF9sZW40NzsgX2tleTQ3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDddID0gYXJndW1lbnRzW19rZXk0N107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40OCksIF9rZXk0OCA9IDA7IF9rZXk0OCA8IF9sZW40ODsgX2tleTQ4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDhdID0gYXJndW1lbnRzW19rZXk0OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40OSksIF9rZXk0OSA9IDA7IF9rZXk0OSA8IF9sZW40OTsgX2tleTQ5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDldID0gYXJndW1lbnRzW19rZXk0OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTApLCBfa2V5NTAgPSAwOyBfa2V5NTAgPCBfbGVuNTA7IF9rZXk1MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUwXSA9IGFyZ3VtZW50c1tfa2V5NTBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcGF0aDogZnVuY3Rpb24gcGF0aCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTEpLCBfa2V5NTEgPSAwOyBfa2V5NTEgPCBfbGVuNTE7IF9rZXk1MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUxXSA9IGFyZ3VtZW50c1tfa2V5NTFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGgoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGhSZWY6IGZ1bmN0aW9uIHBhdGhSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUyKSwgX2tleTUyID0gMDsgX2tleTUyIDwgX2xlbjUyOyBfa2V5NTIrKykge1xuICAgICAgICBhcmdzW19rZXk1Ml0gPSBhcmd1bWVudHNbX2tleTUyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoUmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoUmVmczogZnVuY3Rpb24gcGF0aFJlZnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUzKSwgX2tleTUzID0gMDsgX2tleTUzIDwgX2xlbjUzOyBfa2V5NTMrKykge1xuICAgICAgICBhcmdzW19rZXk1M10gPSBhcmd1bWVudHNbX2tleTUzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoUmVmcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NCksIF9rZXk1NCA9IDA7IF9rZXk1NCA8IF9sZW41NDsgX2tleTU0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTRdID0gYXJndW1lbnRzW19rZXk1NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50UmVmOiBmdW5jdGlvbiBwb2ludFJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTUpLCBfa2V5NTUgPSAwOyBfa2V5NTUgPCBfbGVuNTU7IF9rZXk1NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU1XSA9IGFyZ3VtZW50c1tfa2V5NTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50UmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludFJlZnM6IGZ1bmN0aW9uIHBvaW50UmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTYpLCBfa2V5NTYgPSAwOyBfa2V5NTYgPCBfbGVuNTY7IF9rZXk1NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU2XSA9IGFyZ3VtZW50c1tfa2V5NTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50UmVmcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU3KSwgX2tleTU3ID0gMDsgX2tleTU3IDwgX2xlbjU3OyBfa2V5NTcrKykge1xuICAgICAgICBhcmdzW19rZXk1N10gPSBhcmd1bWVudHNbX2tleTU3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3NpdGlvbnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTgpLCBfa2V5NTggPSAwOyBfa2V5NTggPCBfbGVuNTg7IF9rZXk1OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU4XSA9IGFyZ3VtZW50c1tfa2V5NThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZTogZnVuY3Rpb24gcmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU5KSwgX2tleTU5ID0gMDsgX2tleTU5IDwgX2xlbjU5OyBfa2V5NTkrKykge1xuICAgICAgICBhcmdzW19rZXk1OV0gPSBhcmd1bWVudHNbX2tleTU5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmFuZ2VSZWY6IGZ1bmN0aW9uIHJhbmdlUmVmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MCksIF9rZXk2MCA9IDA7IF9rZXk2MCA8IF9sZW42MDsgX2tleTYwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjBdID0gYXJndW1lbnRzW19rZXk2MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmczogZnVuY3Rpb24gcmFuZ2VSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MSksIF9rZXk2MSA9IDA7IF9rZXk2MSA8IF9sZW42MTsgX2tleTYxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjFdID0gYXJndW1lbnRzW19rZXk2MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlczogZnVuY3Rpb24gcmVtb3ZlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYyKSwgX2tleTYyID0gMDsgX2tleTYyIDwgX2xlbjYyOyBfa2V5NjIrKykge1xuICAgICAgICBhcmdzW19rZXk2Ml0gPSBhcmd1bWVudHNbX2tleTYyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYzKSwgX2tleTYzID0gMDsgX2tleTYzIDwgX2xlbjYzOyBfa2V5NjMrKykge1xuICAgICAgICBhcmdzW19rZXk2M10gPSBhcmd1bWVudHNbX2tleTYzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiBzZXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjQpLCBfa2V5NjQgPSAwOyBfa2V5NjQgPCBfbGVuNjQ7IF9rZXk2NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY0XSA9IGFyZ3VtZW50c1tfa2V5NjRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXROb3JtYWxpemluZzogZnVuY3Rpb24gc2V0Tm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY1KSwgX2tleTY1ID0gMDsgX2tleTY1IDwgX2xlbjY1OyBfa2V5NjUrKykge1xuICAgICAgICBhcmdzW19rZXk2NV0gPSBhcmd1bWVudHNbX2tleTY1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXROb3JtYWxpemluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uIHNldFBvaW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NiksIF9rZXk2NiA9IDA7IF9rZXk2NiA8IF9sZW42NjsgX2tleTY2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjZdID0gYXJndW1lbnRzW19rZXk2Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0UG9pbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NyksIF9rZXk2NyA9IDA7IF9rZXk2NyA8IF9sZW42NzsgX2tleTY3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjddID0gYXJndW1lbnRzW19rZXk2N107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0U2VsZWN0aW9uKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzcGxpdE5vZGVzOiBmdW5jdGlvbiBzcGxpdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42OCksIF9rZXk2OCA9IDA7IF9rZXk2OCA8IF9sZW42ODsgX2tleTY4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjhdID0gYXJndW1lbnRzW19rZXk2OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BsaXROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42OSksIF9rZXk2OSA9IDA7IF9rZXk2OSA8IF9sZW42OTsgX2tleTY5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjldID0gYXJndW1lbnRzW19rZXk2OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MCksIF9rZXk3MCA9IDA7IF9rZXk3MCA8IF9sZW43MDsgX2tleTcwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzBdID0gYXJndW1lbnRzW19rZXk3MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bmhhbmdSYW5nZTogZnVuY3Rpb24gdW5oYW5nUmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcxKSwgX2tleTcxID0gMDsgX2tleTcxIDwgX2xlbjcxOyBfa2V5NzErKykge1xuICAgICAgICBhcmdzW19rZXk3MV0gPSBhcmd1bWVudHNbX2tleTcxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmhhbmdSYW5nZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgdW5zZXROb2RlczogZnVuY3Rpb24gdW5zZXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzIpLCBfa2V5NzIgPSAwOyBfa2V5NzIgPCBfbGVuNzI7IF9rZXk3MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcyXSA9IGFyZ3VtZW50c1tfa2V5NzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuc2V0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVud3JhcE5vZGVzOiBmdW5jdGlvbiB1bndyYXBOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjczID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzMpLCBfa2V5NzMgPSAwOyBfa2V5NzMgPCBfbGVuNzM7IF9rZXk3MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTczXSA9IGFyZ3VtZW50c1tfa2V5NzNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVud3JhcE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB2b2lkOiBmdW5jdGlvbiBfdm9pZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc0KSwgX2tleTc0ID0gMDsgX2tleTc0IDwgX2xlbjc0OyBfa2V5NzQrKykge1xuICAgICAgICBhcmdzW19rZXk3NF0gPSBhcmd1bWVudHNbX2tleTc0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRWb2lkKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB3aXRob3V0Tm9ybWFsaXppbmc6IGZ1bmN0aW9uIHdpdGhvdXROb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzUpLCBfa2V5NzUgPSAwOyBfa2V5NzUgPCBfbGVuNzU7IF9rZXk3NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc1XSA9IGFyZ3VtZW50c1tfa2V5NzVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd3JhcE5vZGVzOiBmdW5jdGlvbiB3cmFwTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc2KSwgX2tleTc2ID0gMDsgX2tleTc2IDwgX2xlbjc2OyBfa2V5NzYrKykge1xuICAgICAgICBhcmdzW19rZXk3Nl0gPSBhcmd1bWVudHNbX2tleTc2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZTogZnVuY3Rpb24gc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NyksIF9rZXk3NyA9IDA7IF9rZXk3NyA8IF9sZW43NzsgX2tleTc3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzddID0gYXJndW1lbnRzW19rZXk3N107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufTtcblxuZXhwb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBMb2NhdGlvbiwgTm9kZSwgT3BlcmF0aW9uLCBQYXRoLCBQYXRoUmVmLCBQb2ludCwgUG9pbnRSZWYsIFJhbmdlLCBSYW5nZVJlZiwgU2NydWJiZXIsIFNwYW4sIFRleHQsIFRyYW5zZm9ybXMsIGFib3ZlLCBhZGRNYXJrLCBhZnRlciwgYXBwbHksIGJlZm9yZSwgY29sbGFwc2UsIGNyZWF0ZUVkaXRvciwgZGVsZXRlQmFja3dhcmQsIGRlbGV0ZUZvcndhcmQsIGRlbGV0ZUZyYWdtZW50LCBkZWxldGVUZXh0LCBkZXNlbGVjdCwgZWRnZXMsIGVsZW1lbnRSZWFkT25seSwgZW5kLCBmaXJzdCwgZnJhZ21lbnQsIGdldERpcnR5UGF0aHMsIGdldEZyYWdtZW50LCBnZXRWb2lkLCBoYXNCbG9ja3MsIGhhc0lubGluZXMsIGhhc1BhdGgsIGhhc1RleHRzLCBpbnNlcnRCcmVhaywgaW5zZXJ0RnJhZ21lbnQsIGluc2VydE5vZGUsIGluc2VydE5vZGVzLCBpbnNlcnRTb2Z0QnJlYWssIGluc2VydFRleHQsIGlzQmxvY2ssIGlzRWRnZSwgaXNFZGl0b3IsIGlzRW1wdHksIGlzRW5kLCBpc05vcm1hbGl6aW5nLCBpc1N0YXJ0LCBsYXN0LCBsZWFmLCBsZXZlbHMsIGxpZnROb2RlcywgbWFya3MsIG1lcmdlTm9kZXMsIG1vdmUsIG1vdmVOb2RlcywgbmV4dCwgbm9kZSwgbm9kZXMsIG5vcm1hbGl6ZSwgbm9ybWFsaXplTm9kZSwgcGFyZW50LCBwYXRoLCBwYXRoUmVmLCBwYXRoUmVmcywgcG9pbnQsIHBvaW50UmVmLCBwb2ludFJlZnMsIHBvc2l0aW9ucywgcHJldmlvdXMsIHJhbmdlLCByYW5nZVJlZiwgcmFuZ2VSZWZzLCByZW1vdmVNYXJrLCByZW1vdmVOb2Rlcywgc2VsZWN0LCBzZXROb2Rlcywgc2V0Tm9ybWFsaXppbmcsIHNldFBvaW50LCBzZXRTZWxlY3Rpb24sIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZSwgc2hvdWxkTm9ybWFsaXplLCBzcGxpdE5vZGVzLCBzdGFydCwgc3RyaW5nLCB1bmhhbmdSYW5nZSwgdW5zZXROb2RlcywgdW53cmFwTm9kZXMsIHdpdGhvdXROb3JtYWxpemluZywgd3JhcE5vZGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/slate/dist/index.es.js\n"));

/***/ }),

/***/ "./node_modules/compute-scroll-into-view/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/compute-scroll-into-view/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compute: () => (/* binding */ r)\n/* harmony export */ });\nconst t=t=>\"object\"==typeof t&&null!=t&&1===t.nodeType,e=(t,e)=>(!e||\"hidden\"!==t)&&(\"visible\"!==t&&\"clip\"!==t),n=(t,n)=>{if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){const o=getComputedStyle(t,null);return e(o.overflowY,n)||e(o.overflowX,n)||(t=>{const e=(t=>{if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}})(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)})(t)}return!1},o=(t,e,n,o,l,r,i,s)=>r<t&&i>e||r>t&&i<e?0:r<=t&&s<=n||i>=e&&s>=n?r-t-o:i>e&&s<n||r<t&&s>n?i-e+l:0,l=t=>{const e=t.parentElement;return null==e?t.getRootNode().host||null:e},r=(e,r)=>{var i,s,d,h;if(\"undefined\"==typeof document)return[];const{scrollMode:c,block:f,inline:u,boundary:a,skipOverflowHiddenElements:g}=r,p=\"function\"==typeof a?a:t=>t!==a;if(!t(e))throw new TypeError(\"Invalid target\");const m=document.scrollingElement||document.documentElement,w=[];let W=e;for(;t(W)&&p(W);){if(W=l(W),W===m){w.push(W);break}null!=W&&W===document.body&&n(W)&&!n(document.documentElement)||null!=W&&n(W,g)&&w.push(W)}const b=null!=(s=null==(i=window.visualViewport)?void 0:i.width)?s:innerWidth,H=null!=(h=null==(d=window.visualViewport)?void 0:d.height)?h:innerHeight,{scrollX:y,scrollY:M}=window,{height:v,width:E,top:x,right:C,bottom:I,left:R}=e.getBoundingClientRect(),{top:T,right:B,bottom:F,left:V}=(t=>{const e=window.getComputedStyle(t);return{top:parseFloat(e.scrollMarginTop)||0,right:parseFloat(e.scrollMarginRight)||0,bottom:parseFloat(e.scrollMarginBottom)||0,left:parseFloat(e.scrollMarginLeft)||0}})(e);let k=\"start\"===f||\"nearest\"===f?x-T:\"end\"===f?I+F:x+v/2-T+F,D=\"center\"===u?R+E/2-V+B:\"end\"===u?C+B:R-V;const L=[];for(let t=0;t<w.length;t++){const e=w[t],{height:n,width:l,top:r,right:i,bottom:s,left:d}=e.getBoundingClientRect();if(\"if-needed\"===c&&x>=0&&R>=0&&I<=H&&C<=b&&x>=r&&I<=s&&R>=d&&C<=i)return L;const h=getComputedStyle(e),a=parseInt(h.borderLeftWidth,10),g=parseInt(h.borderTopWidth,10),p=parseInt(h.borderRightWidth,10),W=parseInt(h.borderBottomWidth,10);let T=0,B=0;const F=\"offsetWidth\"in e?e.offsetWidth-e.clientWidth-a-p:0,V=\"offsetHeight\"in e?e.offsetHeight-e.clientHeight-g-W:0,S=\"offsetWidth\"in e?0===e.offsetWidth?0:l/e.offsetWidth:0,X=\"offsetHeight\"in e?0===e.offsetHeight?0:n/e.offsetHeight:0;if(m===e)T=\"start\"===f?k:\"end\"===f?k-H:\"nearest\"===f?o(M,M+H,H,g,W,M+k,M+k+v,v):k-H/2,B=\"start\"===u?D:\"center\"===u?D-b/2:\"end\"===u?D-b:o(y,y+b,b,a,p,y+D,y+D+E,E),T=Math.max(0,T+M),B=Math.max(0,B+y);else{T=\"start\"===f?k-r-g:\"end\"===f?k-s+W+V:\"nearest\"===f?o(r,s,n,g,W+V,k,k+v,v):k-(r+n/2)+V/2,B=\"start\"===u?D-d-a:\"center\"===u?D-(d+l/2)+F/2:\"end\"===u?D-i+p+F:o(d,i,l,a,p+F,D,D+E,E);const{scrollLeft:t,scrollTop:h}=e;T=0===X?0:Math.max(0,Math.min(h+T/X,e.scrollHeight-n/X+V)),B=0===S?0:Math.max(0,Math.min(t+B/S,e.scrollWidth-l/S+F)),k+=h-T,D+=t-B}L.push({el:e,top:T,left:B})}return L};//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1zY3JvbGwtaW50by12aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDBIQUEwSCwrREFBK0QsaUNBQWlDLGdEQUFnRCxhQUFhLDhEQUE4RCxJQUFJLGdEQUFnRCxTQUFTLGFBQWEsS0FBSyx3RUFBd0UsS0FBSyxTQUFTLHlHQUF5Ryx3QkFBd0IsNENBQTRDLFdBQVcsWUFBWSx5Q0FBeUMsTUFBTSxzRUFBc0UscUNBQXFDLCtDQUErQyxpRUFBaUUsUUFBUSxLQUFLLFdBQVcsRUFBRSxpQkFBaUIsVUFBVSxNQUFNLDJGQUEyRix5SkFBeUosb0JBQW9CLFNBQVMsK0NBQStDLDRCQUE0Qiw4QkFBOEIsTUFBTSxtQ0FBbUMsT0FBTyxpS0FBaUssS0FBSyx3R0FBd0csV0FBVyxZQUFZLFdBQVcsS0FBSyxjQUFjLCtDQUErQywyQkFBMkIsNEVBQTRFLGtLQUFrSyxZQUFZLDRPQUE0TyxzTUFBc00sS0FBSyxpTEFBaUwsTUFBTSx5QkFBeUIsR0FBRyxtSUFBbUksUUFBUSxrQkFBa0IsRUFBRSxVQUErQiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9jb21wdXRlLXNjcm9sbC1pbnRvLXZpZXcvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0PXQ9Plwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT10JiYxPT09dC5ub2RlVHlwZSxlPSh0LGUpPT4oIWV8fFwiaGlkZGVuXCIhPT10KSYmKFwidmlzaWJsZVwiIT09dCYmXCJjbGlwXCIhPT10KSxuPSh0LG4pPT57aWYodC5jbGllbnRIZWlnaHQ8dC5zY3JvbGxIZWlnaHR8fHQuY2xpZW50V2lkdGg8dC5zY3JvbGxXaWR0aCl7Y29uc3Qgbz1nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCk7cmV0dXJuIGUoby5vdmVyZmxvd1ksbil8fGUoby5vdmVyZmxvd1gsbil8fCh0PT57Y29uc3QgZT0odD0+e2lmKCF0Lm93bmVyRG9jdW1lbnR8fCF0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpcmV0dXJuIG51bGw7dHJ5e3JldHVybiB0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZnJhbWVFbGVtZW50fWNhdGNoKHQpe3JldHVybiBudWxsfX0pKHQpO3JldHVybiEhZSYmKGUuY2xpZW50SGVpZ2h0PHQuc2Nyb2xsSGVpZ2h0fHxlLmNsaWVudFdpZHRoPHQuc2Nyb2xsV2lkdGgpfSkodCl9cmV0dXJuITF9LG89KHQsZSxuLG8sbCxyLGkscyk9PnI8dCYmaT5lfHxyPnQmJmk8ZT8wOnI8PXQmJnM8PW58fGk+PWUmJnM+PW4/ci10LW86aT5lJiZzPG58fHI8dCYmcz5uP2ktZStsOjAsbD10PT57Y29uc3QgZT10LnBhcmVudEVsZW1lbnQ7cmV0dXJuIG51bGw9PWU/dC5nZXRSb290Tm9kZSgpLmhvc3R8fG51bGw6ZX0scj0oZSxyKT0+e3ZhciBpLHMsZCxoO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudClyZXR1cm5bXTtjb25zdHtzY3JvbGxNb2RlOmMsYmxvY2s6ZixpbmxpbmU6dSxib3VuZGFyeTphLHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzOmd9PXIscD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2E6dD0+dCE9PWE7aWYoIXQoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFyZ2V0XCIpO2NvbnN0IG09ZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHc9W107bGV0IFc9ZTtmb3IoO3QoVykmJnAoVyk7KXtpZihXPWwoVyksVz09PW0pe3cucHVzaChXKTticmVha31udWxsIT1XJiZXPT09ZG9jdW1lbnQuYm9keSYmbihXKSYmIW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXx8bnVsbCE9VyYmbihXLGcpJiZ3LnB1c2goVyl9Y29uc3QgYj1udWxsIT0ocz1udWxsPT0oaT13aW5kb3cudmlzdWFsVmlld3BvcnQpP3ZvaWQgMDppLndpZHRoKT9zOmlubmVyV2lkdGgsSD1udWxsIT0oaD1udWxsPT0oZD13aW5kb3cudmlzdWFsVmlld3BvcnQpP3ZvaWQgMDpkLmhlaWdodCk/aDppbm5lckhlaWdodCx7c2Nyb2xsWDp5LHNjcm9sbFk6TX09d2luZG93LHtoZWlnaHQ6dix3aWR0aDpFLHRvcDp4LHJpZ2h0OkMsYm90dG9tOkksbGVmdDpSfT1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHt0b3A6VCxyaWdodDpCLGJvdHRvbTpGLGxlZnQ6Vn09KHQ9Pntjb25zdCBlPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO3JldHVybnt0b3A6cGFyc2VGbG9hdChlLnNjcm9sbE1hcmdpblRvcCl8fDAscmlnaHQ6cGFyc2VGbG9hdChlLnNjcm9sbE1hcmdpblJpZ2h0KXx8MCxib3R0b206cGFyc2VGbG9hdChlLnNjcm9sbE1hcmdpbkJvdHRvbSl8fDAsbGVmdDpwYXJzZUZsb2F0KGUuc2Nyb2xsTWFyZ2luTGVmdCl8fDB9fSkoZSk7bGV0IGs9XCJzdGFydFwiPT09Znx8XCJuZWFyZXN0XCI9PT1mP3gtVDpcImVuZFwiPT09Zj9JK0Y6eCt2LzItVCtGLEQ9XCJjZW50ZXJcIj09PXU/UitFLzItVitCOlwiZW5kXCI9PT11P0MrQjpSLVY7Y29uc3QgTD1bXTtmb3IobGV0IHQ9MDt0PHcubGVuZ3RoO3QrKyl7Y29uc3QgZT13W3RdLHtoZWlnaHQ6bix3aWR0aDpsLHRvcDpyLHJpZ2h0OmksYm90dG9tOnMsbGVmdDpkfT1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKFwiaWYtbmVlZGVkXCI9PT1jJiZ4Pj0wJiZSPj0wJiZJPD1IJiZDPD1iJiZ4Pj1yJiZJPD1zJiZSPj1kJiZDPD1pKXJldHVybiBMO2NvbnN0IGg9Z2V0Q29tcHV0ZWRTdHlsZShlKSxhPXBhcnNlSW50KGguYm9yZGVyTGVmdFdpZHRoLDEwKSxnPXBhcnNlSW50KGguYm9yZGVyVG9wV2lkdGgsMTApLHA9cGFyc2VJbnQoaC5ib3JkZXJSaWdodFdpZHRoLDEwKSxXPXBhcnNlSW50KGguYm9yZGVyQm90dG9tV2lkdGgsMTApO2xldCBUPTAsQj0wO2NvbnN0IEY9XCJvZmZzZXRXaWR0aFwiaW4gZT9lLm9mZnNldFdpZHRoLWUuY2xpZW50V2lkdGgtYS1wOjAsVj1cIm9mZnNldEhlaWdodFwiaW4gZT9lLm9mZnNldEhlaWdodC1lLmNsaWVudEhlaWdodC1nLVc6MCxTPVwib2Zmc2V0V2lkdGhcImluIGU/MD09PWUub2Zmc2V0V2lkdGg/MDpsL2Uub2Zmc2V0V2lkdGg6MCxYPVwib2Zmc2V0SGVpZ2h0XCJpbiBlPzA9PT1lLm9mZnNldEhlaWdodD8wOm4vZS5vZmZzZXRIZWlnaHQ6MDtpZihtPT09ZSlUPVwic3RhcnRcIj09PWY/azpcImVuZFwiPT09Zj9rLUg6XCJuZWFyZXN0XCI9PT1mP28oTSxNK0gsSCxnLFcsTStrLE0rayt2LHYpOmstSC8yLEI9XCJzdGFydFwiPT09dT9EOlwiY2VudGVyXCI9PT11P0QtYi8yOlwiZW5kXCI9PT11P0QtYjpvKHkseStiLGIsYSxwLHkrRCx5K0QrRSxFKSxUPU1hdGgubWF4KDAsVCtNKSxCPU1hdGgubWF4KDAsQit5KTtlbHNle1Q9XCJzdGFydFwiPT09Zj9rLXItZzpcImVuZFwiPT09Zj9rLXMrVytWOlwibmVhcmVzdFwiPT09Zj9vKHIscyxuLGcsVytWLGssayt2LHYpOmstKHIrbi8yKStWLzIsQj1cInN0YXJ0XCI9PT11P0QtZC1hOlwiY2VudGVyXCI9PT11P0QtKGQrbC8yKStGLzI6XCJlbmRcIj09PXU/RC1pK3ArRjpvKGQsaSxsLGEscCtGLEQsRCtFLEUpO2NvbnN0e3Njcm9sbExlZnQ6dCxzY3JvbGxUb3A6aH09ZTtUPTA9PT1YPzA6TWF0aC5tYXgoMCxNYXRoLm1pbihoK1QvWCxlLnNjcm9sbEhlaWdodC1uL1grVikpLEI9MD09PVM/MDpNYXRoLm1heCgwLE1hdGgubWluKHQrQi9TLGUuc2Nyb2xsV2lkdGgtbC9TK0YpKSxrKz1oLVQsRCs9dC1CfUwucHVzaCh7ZWw6ZSx0b3A6VCxsZWZ0OkJ9KX1yZXR1cm4gTH07ZXhwb3J0e3IgYXMgY29tcHV0ZX07Ly8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/compute-scroll-into-view/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/immer/dist/immer.mjs":
/*!*******************************************!*\
  !*** ./node_modules/immer/dist/immer.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ Immer2),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   createDraft: () => (/* binding */ createDraft),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   enableMapSet: () => (/* binding */ enableMapSet),\n/* harmony export */   enablePatches: () => (/* binding */ enablePatches),\n/* harmony export */   finishDraft: () => (/* binding */ finishDraft),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   immerable: () => (/* binding */ DRAFTABLE),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   nothing: () => (/* binding */ NOTHING),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   produce: () => (/* binding */ produce),\n/* harmony export */   produceWithPatches: () => (/* binding */ produceWithPatches),\n/* harmony export */   setAutoFreeze: () => (/* binding */ setAutoFreeze),\n/* harmony export */   setUseStrictShallowCopy: () => (/* binding */ setUseStrictShallowCopy)\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors =  true ? [\n  // All error codes, starting by 0:\n  function(plugin) {\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n  },\n  function(thing) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(thing) {\n    return `'current' expects a draft, got: ${thing}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(thing) {\n    return `'original' expects a draft, got: ${thing}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : 0;\nfunction die(error, ...args) {\n  if (true) {\n    const e = errors[error];\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\n\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value)\n    return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\")\n    return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object)\n    return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value))\n    die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Reflect.ownKeys(obj).forEach((key) => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2 /* Map */)\n    thing.set(propOrOldValue, value);\n  else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else\n    thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base))\n    return Array.prototype.slice.call(base);\n  const isPlain = isPlainObject(base);\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n      if (desc.get || desc.set)\n        descriptors[key] = {\n          configurable: true,\n          writable: true,\n          // could live with !!desc.set as well here...\n          enumerable: desc.enumerable,\n          value: base[key]\n        };\n    }\n    return Object.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n    if (proto !== null && isPlain) {\n      return { ...base };\n    }\n    const obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\nfunction freeze(obj, deep = false) {\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\n    return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep)\n    Object.entries(obj).forEach(([key, value]) => freeze(value, true));\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey])\n    plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\n    state.revoke_();\n  else\n    state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_)\n        maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(\n        baseDraft[DRAFT_STATE].base_,\n        result,\n        scope.patches_,\n        scope.inversePatches_\n      );\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  if (!state) {\n    each(\n      value,\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)\n    );\n    return value;\n  }\n  if (state.scope_ !== rootScope)\n    return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(\n      resultEach,\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\n    );\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(\n        state,\n        path,\n        rootScope.patches_,\n        rootScope.inversePatches_\n      );\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if ( true && childValue === targetObject)\n    die(5);\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else\n      return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))\n      maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE)\n      return state;\n    const source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    const value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\n        return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\n      return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc)\n      return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty() {\n    die(11);\n  },\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n  setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function() {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function(state, prop) {\n  if ( true && isNaN(parseInt(prop)))\n    die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n  if ( true && prop !== \"length\" && isNaN(parseInt(prop)))\n    die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)\n  ) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source))\n    return void 0;\n  let proto = getPrototypeOf(source);\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc)\n      return desc;\n    proto = getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(\n      state.base_,\n      state.scope_.immer_.useStrictShallowCopy_\n    );\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = class {\n  constructor(config) {\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce(base2 = defaultBase, ...args) {\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\n        };\n      }\n      if (typeof recipe !== \"function\")\n        die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\n        die(7);\n      let result;\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError)\n            revokeScope(scope);\n          else\n            leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0)\n          result = base;\n        if (result === NOTHING)\n          result = void 0;\n        if (this.autoFreeze_)\n          freeze(result, true);\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else\n        die(1, base);\n    };\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\n      }\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof config?.autoFreeze === \"boolean\")\n      this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  createDraft(base) {\n    if (!isDraftable(base))\n      die(8);\n    if (isDraft(base))\n      base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_)\n      die(9);\n    const { scope_: scope } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  applyPatches(base, patches) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n    return this.produce(\n      base,\n      (draft) => applyPatchesImpl(draft, patches)\n    );\n  }\n};\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value))\n    die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  if (state) {\n    if (!state.modified_)\n      return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  const errorOffset = 16;\n  if (true) {\n    errors.push(\n      'Sets cannot have \"replace\" patches.',\n      function(op) {\n        return \"Unsupported patch operation: \" + op;\n      },\n      function(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n      },\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n    );\n  }\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let { base_, assigned_ } = state;\n    let copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const { base_, copy_ } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE)\n        return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\n      inversePatches.push(\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\n      );\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let { base_, copy_ } = state;\n    let i = 0;\n    base_.forEach((value) => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach((value) => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach((patch) => {\n      const { path, op } = patch;\n      let base = draft;\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\n          die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\")\n          die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\")\n          die(errorOffset + 2, path.join(\"/\"));\n      }\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj))\n      return obj;\n    if (Array.isArray(obj))\n      return obj.map(deepClonePatchValue);\n    if (isMap(obj))\n      return new Map(\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n      );\n    if (isSet(obj))\n      return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n    for (const key in obj)\n      cloned[key] = deepClonePatchValue(obj[key]);\n    if (has(obj, DRAFTABLE))\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else\n      return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n      return this;\n    }\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n      state.copy_.delete(key);\n      return true;\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */ new Map();\n        each(state.base_, (key) => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n  }\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */ new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */ new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n      if (state.copy_.has(value))\n        return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n        return true;\n      return false;\n    }\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n      return this;\n    }\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\n        /* istanbul ignore next */\n        false\n      ));\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n    keys() {\n      return this.values();\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n  }\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */ new Set();\n      state.base_.forEach((value) => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_)\n      die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(\n  immer\n);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\n\n//# sourceMappingURL=immer.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0EsOEJBQThCLE9BQU8sa0ZBQWtGLE9BQU87QUFDOUgsR0FBRztBQUNIO0FBQ0EsaUtBQWlLLE1BQU07QUFDdkssR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxDQUFFO0FBQ047QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLElBQUksaUJBQWlCO0FBQ3JFO0FBQ0EsdUJBQXVCLG1CQUFtQixvQkFBb0IsMkRBQTJELElBQUk7QUFDN0g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZW52LnRzXG52YXIgTk9USElORyA9IFN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpO1xudmFyIERSQUZUQUJMRSA9IFN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik7XG52YXIgRFJBRlRfU1RBVEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIik7XG5cbi8vIHNyYy91dGlscy9lcnJvcnMudHNcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBbXG4gIC8vIEFsbCBlcnJvciBjb2Rlcywgc3RhcnRpbmcgYnkgMDpcbiAgZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgcmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gO1xuICB9LFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0aGluZ30nYDtcbiAgfSxcbiAgXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuICBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArIGRhdGE7XG4gIH0sXG4gIFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcbiAgXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcbiAgXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG4gIFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XG4gIH0sXG4gIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfVxuICAvLyBOb3RlOiBpZiBtb3JlIGVycm9ycyBhcmUgYWRkZWQsIHRoZSBlcnJvck9mZnNldCBpbiBQYXRjaGVzLnRzIHNob3VsZCBiZSBpbmNyZWFzZWRcbiAgLy8gU2VlIFBhdGNoZXMudHMgZm9yIGFkZGl0aW9uYWwgZXJyb3JzXG5dIDogW107XG5mdW5jdGlvbiBkaWUoZXJyb3IsIC4uLmFyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGUgPSBlcnJvcnNbZXJyb3JdO1xuICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KG51bGwsIGFyZ3MpIDogZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtJbW1lcl0gJHttc2d9YCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfS4gRnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbW1vbi50c1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgISF2YWx1ZVtEUkFGVEFCTEVdIHx8ICEhdmFsdWUuY29uc3RydWN0b3I/LltEUkFGVEFCTEVdIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XG59XG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgQ3RvciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICBpZiAoQ3RvciA9PT0gT2JqZWN0KVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5mdW5jdGlvbiBvcmlnaW5hbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxNSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfO1xufVxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIpIHtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IDAgLyogT2JqZWN0ICovKSB7XG4gICAgUmVmbGVjdC5vd25LZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpdGVyKGtleSwgb2JqW2tleV0sIG9iaik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4gaXRlcihpbmRleCwgZW50cnksIG9iaikpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBcmNodHlwZSh0aGluZykge1xuICBjb25zdCBzdGF0ZSA9IHRoaW5nW0RSQUZUX1NUQVRFXTtcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUudHlwZV8gOiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IDEgLyogQXJyYXkgKi8gOiBpc01hcCh0aGluZykgPyAyIC8qIE1hcCAqLyA6IGlzU2V0KHRoaW5nKSA/IDMgLyogU2V0ICovIDogMCAvKiBPYmplY3QgKi87XG59XG5mdW5jdGlvbiBoYXModGhpbmcsIHByb3ApIHtcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5oYXMocHJvcCkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xufVxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDIgLyogTWFwICovID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XG59XG5mdW5jdGlvbiBzZXQodGhpbmcsIHByb3BPck9sZFZhbHVlLCB2YWx1ZSkge1xuICBjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpO1xuICBpZiAodCA9PT0gMiAvKiBNYXAgKi8pXG4gICAgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSk7XG4gIGVsc2UgaWYgKHQgPT09IDMgLyogU2V0ICovKSB7XG4gICAgdGhpbmcuYWRkKHZhbHVlKTtcbiAgfSBlbHNlXG4gICAgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWFwKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgTWFwO1xufVxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBTZXQ7XG59XG5mdW5jdGlvbiBsYXRlc3Qoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfO1xufVxuZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZSwgc3RyaWN0KSB7XG4gIGlmIChpc01hcChiYXNlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGJhc2UpO1xuICB9XG4gIGlmIChpc1NldChiYXNlKSkge1xuICAgIHJldHVybiBuZXcgU2V0KGJhc2UpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2UpKVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiYXNlKTtcbiAgY29uc3QgaXNQbGFpbiA9IGlzUGxhaW5PYmplY3QoYmFzZSk7XG4gIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImNsYXNzX29ubHlcIiAmJiAhaXNQbGFpbikge1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG4gICAgZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcbiAgICBsZXQga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhkZXNjcmlwdG9ycyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgY29uc3QgZGVzYyA9IGRlc2NyaXB0b3JzW2tleV07XG4gICAgICBpZiAoZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcbiAgICAgICAgZGVzY3JpcHRvcnNba2V5XSA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgLy8gY291bGQgbGl2ZSB3aXRoICEhZGVzYy5zZXQgYXMgd2VsbCBoZXJlLi4uXG4gICAgICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICAgIHZhbHVlOiBiYXNlW2tleV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvdHlwZU9mKGJhc2UpO1xuICAgIGlmIChwcm90byAhPT0gbnVsbCAmJiBpc1BsYWluKSB7XG4gICAgICByZXR1cm4geyAuLi5iYXNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgYmFzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoaXNGcm96ZW4ob2JqKSB8fCBpc0RyYWZ0KG9iaikgfHwgIWlzRHJhZnRhYmxlKG9iaikpXG4gICAgcmV0dXJuIG9iajtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPiAxKSB7XG4gICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xuICB9XG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSkpO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuICBkaWUoMik7XG59XG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbihvYmopO1xufVxuXG4vLyBzcmMvdXRpbHMvcGx1Z2lucy50c1xudmFyIHBsdWdpbnMgPSB7fTtcbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5LZXkpIHtcbiAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5LZXldO1xuICBpZiAoIXBsdWdpbikge1xuICAgIGRpZSgwLCBwbHVnaW5LZXkpO1xuICB9XG4gIHJldHVybiBwbHVnaW47XG59XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbi8vIHNyYy9jb3JlL3Njb3BlLnRzXG52YXIgY3VycmVudFNjb3BlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NvcGUocGFyZW50XywgaW1tZXJfKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZnRzXzogW10sXG4gICAgcGFyZW50XyxcbiAgICBpbW1lcl8sXG4gICAgLy8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuICAgIC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG4gICAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gICAgdW5maW5hbGl6ZWREcmFmdHNfOiAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7XG4gICAgc2NvcGUucGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XG4gIGxlYXZlU2NvcGUoc2NvcGUpO1xuICBzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpO1xuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcbiAgICBjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfO1xuICB9XG59XG5mdW5jdGlvbiBlbnRlclNjb3BlKGltbWVyMikge1xuICByZXR1cm4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcjIpO1xufVxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMCAvKiBPYmplY3QgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8pXG4gICAgc3RhdGUucmV2b2tlXygpO1xuICBlbHNlXG4gICAgc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG4vLyBzcmMvY29yZS9maW5hbGl6ZS50c1xuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKSB7XG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xuICBjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICBjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB2b2lkIDAgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XG4gIGlmIChpc1JlcGxhY2VkKSB7XG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG4gICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICBkaWUoNCk7XG4gICAgfVxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50XylcbiAgICAgICAgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG4gICAgICAgIGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc2NvcGUucGF0Y2hlc18sXG4gICAgICAgIHNjb3BlLmludmVyc2VQYXRjaGVzX1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG4gIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8oc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaChcbiAgICAgIHZhbHVlLFxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKVxuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICB9XG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcbiAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5jb3B5XztcbiAgICBsZXQgcmVzdWx0RWFjaCA9IHJlc3VsdDtcbiAgICBsZXQgaXNTZXQyID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlLnR5cGVfID09PSAzIC8qIFNldCAqLykge1xuICAgICAgcmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KTtcbiAgICAgIHJlc3VsdC5jbGVhcigpO1xuICAgICAgaXNTZXQyID0gdHJ1ZTtcbiAgICB9XG4gICAgZWFjaChcbiAgICAgIHJlc3VsdEVhY2gsXG4gICAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldDIpXG4gICAgKTtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpO1xuICAgIGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcm9vdFNjb3BlLnBhdGNoZXNfLFxuICAgICAgICByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgcGFyZW50U3RhdGUsIHRhcmdldE9iamVjdCwgcHJvcCwgY2hpbGRWYWx1ZSwgcm9vdFBhdGgsIHRhcmdldElzU2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KVxuICAgIGRpZSg1KTtcbiAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICBjb25zdCBwYXRoID0gcm9vdFBhdGggJiYgcGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUudHlwZV8gIT09IDMgLyogU2V0ICovICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgc2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKTtcbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XG4gICAgICByb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0YXJnZXRJc1NldCkge1xuICAgIHRhcmdldE9iamVjdC5hZGQoY2hpbGRWYWx1ZSk7XG4gIH1cbiAgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICAgIGlmICgoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgJiYgdHlwZW9mIHByb3AgIT09IFwic3ltYm9sXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldE9iamVjdCwgcHJvcCkpXG4gICAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZSwgdmFsdWUsIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoIXNjb3BlLnBhcmVudF8gJiYgc2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHNjb3BlLmNhbkF1dG9GcmVlemVfKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9wcm94eS50c1xuZnVuY3Rpb24gY3JlYXRlUHJveHlQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHR5cGVfOiBpc0FycmF5ID8gMSAvKiBBcnJheSAqLyA6IDAgLyogT2JqZWN0ICovLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgIC8vIFVzZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxuICAgIGFzc2lnbmVkXzoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgLy8gVGhlIGJhc2Ugc3RhdGUuXG4gICAgYmFzZV86IGJhc2UsXG4gICAgLy8gVGhlIGJhc2UgcHJveHkuXG4gICAgZHJhZnRfOiBudWxsLFxuICAgIC8vIHNldCBiZWxvd1xuICAgIC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXG4gICAgY29weV86IG51bGwsXG4gICAgLy8gQ2FsbGVkIGJ5IHRoZSBgcHJvZHVjZWAgZnVuY3Rpb24uXG4gICAgcmV2b2tlXzogbnVsbCxcbiAgICBpc01hbnVhbF86IGZhbHNlXG4gIH07XG4gIGxldCB0YXJnZXQgPSBzdGF0ZTtcbiAgbGV0IHRyYXBzID0gb2JqZWN0VHJhcHM7XG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH1cbiAgY29uc3QgeyByZXZva2UsIHByb3h5IH0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcyk7XG4gIHN0YXRlLmRyYWZ0XyA9IHByb3h5O1xuICBzdGF0ZS5yZXZva2VfID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG52YXIgb2JqZWN0VHJhcHMgPSB7XG4gIGdldChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSlcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGlmICghaGFzKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgIHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2VbcHJvcF07XG4gICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV9bcHJvcF0gPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGhhcyhzdGF0ZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XG4gIH0sXG4gIG93bktleXMoc3RhdGUpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xuICB9LFxuICBzZXQoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgaWYgKGRlc2M/LnNldCkge1xuICAgICAgZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgY29uc3QgY3VycmVudDIgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gY3VycmVudDI/LltEUkFGVF9TVEFURV07XG4gICAgICBpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzKHZhbHVlLCBjdXJyZW50MikgJiYgKHZhbHVlICE9PSB2b2lkIDAgfHwgaGFzKHN0YXRlLmJhc2VfLCBwcm9wKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29weV9bcHJvcF0gPT09IHZhbHVlICYmIC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIG5ldyBwcm9wcyB3aXRoIHZhbHVlICd1bmRlZmluZWQnXG4gICAgKHZhbHVlICE9PSB2b2lkIDAgfHwgcHJvcCBpbiBzdGF0ZS5jb3B5XykgfHwgLy8gc3BlY2lhbCBjYXNlOiBOYU5cbiAgICBOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc05hTihzdGF0ZS5jb3B5X1twcm9wXSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApICE9PSB2b2lkIDAgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlXykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5hc3NpZ25lZF9bcHJvcF07XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3B5Xykge1xuICAgICAgZGVsZXRlIHN0YXRlLmNvcHlfW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gTm90ZTogV2UgbmV2ZXIgY29lcmNlIGBkZXNjLnZhbHVlYCBpbnRvIGFuIEltbWVyIGRyYWZ0LCBiZWNhdXNlIHdlIGNhbid0IG1ha2VcbiAgLy8gdGhlIHNhbWUgZ3VhcmFudGVlIGluIEVTNSBtb2RlLlxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3RhdGUsIHByb3ApIHtcbiAgICBjb25zdCBvd25lciA9IGxhdGVzdChzdGF0ZSk7XG4gICAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG93bmVyLCBwcm9wKTtcbiAgICBpZiAoIWRlc2MpXG4gICAgICByZXR1cm4gZGVzYztcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHN0YXRlLnR5cGVfICE9PSAxIC8qIEFycmF5ICovIHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogb3duZXJbcHJvcF1cbiAgICB9O1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICBkaWUoMTEpO1xuICB9LFxuICBnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihzdGF0ZS5iYXNlXyk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mKCkge1xuICAgIGRpZSgxMik7XG4gIH1cbn07XG52YXIgYXJyYXlUcmFwcyA9IHt9O1xuZWFjaChvYmplY3RUcmFwcywgKGtleSwgZm4pID0+IHtcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24oc3RhdGUsIHByb3ApIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpXG4gICAgZGllKDEzKTtcbiAgcmV0dXJuIGFycmF5VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHZvaWQgMCk7XG59O1xuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTQpO1xuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XG59O1xuZnVuY3Rpb24gcGVlayhkcmFmdCwgcHJvcCkge1xuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgY29uc3Qgc291cmNlID0gc3RhdGUgPyBsYXRlc3Qoc3RhdGUpIDogZHJhZnQ7XG4gIHJldHVybiBzb3VyY2VbcHJvcF07XG59XG5mdW5jdGlvbiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKSB7XG4gIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gYHZhbHVlYCBpbiBkZXNjID8gZGVzYy52YWx1ZSA6IChcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG4gICAgLy8gcHJvdG90eXBlLCB3ZSBzaG91bGQgaW52b2tlIGl0IHdpdGggdGhlIGRyYWZ0IGFzIGNvbnRleHQhXG4gICAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxuICApIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApIHtcbiAgaWYgKCEocHJvcCBpbiBzb3VyY2UpKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGxldCBwcm90byA9IGdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gIHdoaWxlIChwcm90bykge1xuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbiAgICBpZiAoZGVzYylcbiAgICAgIHJldHVybiBkZXNjO1xuICAgIHByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZSkge1xuICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgIHN0YXRlLm1vZGlmaWVkXyA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudF8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUNvcHkoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgIHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoXG4gICAgICBzdGF0ZS5iYXNlXyxcbiAgICAgIHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9pbW1lckNsYXNzLnRzXG52YXIgSW1tZXIyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdHJ1ZTtcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuICAgICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xuICAgICAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxuICAgICAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG4gICAgICpcbiAgICAgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcbiAgICAgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuICAgICAqXG4gICAgICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXG4gICAgICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVjaXBlIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxuICAgICAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuICAgICAqL1xuICAgIHRoaXMucHJvZHVjZSA9IChiYXNlLCByZWNpcGUsIHBhdGNoTGlzdGVuZXIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBkZWZhdWx0QmFzZSA9IHJlY2lwZTtcbiAgICAgICAgcmVjaXBlID0gYmFzZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShiYXNlMiA9IGRlZmF1bHRCYXNlLCAuLi5hcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucHJvZHVjZShiYXNlMiwgKGRyYWZ0KSA9PiByZWNpcGUuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZGllKDYpO1xuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHZvaWQgMCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBkaWUoNyk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB2b2lkIDApO1xuICAgICAgICBsZXQgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XG4gICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoaGFzRXJyb3IpXG4gICAgICAgICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVhdmVTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWJhc2UgfHwgdHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORylcbiAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0aGlzLmF1dG9GcmVlemVfKVxuICAgICAgICAgIGZyZWV6ZShyZXN1bHQsIHRydWUpO1xuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgICAgICBjb25zdCBpcCA9IFtdO1xuICAgICAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2UsIHJlc3VsdCwgcCwgaXApO1xuICAgICAgICAgIHBhdGNoTGlzdGVuZXIocCwgaXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZGllKDEsIGJhc2UpO1xuICAgIH07XG4gICAgdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMgPSAoYmFzZSwgcmVjaXBlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gKHN0YXRlLCAuLi5hcmdzKSA9PiB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0KSA9PiBiYXNlKGRyYWZ0LCAuLi5hcmdzKSk7XG4gICAgICB9XG4gICAgICBsZXQgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXM7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2R1Y2UoYmFzZSwgcmVjaXBlLCAocCwgaXApID0+IHtcbiAgICAgICAgcGF0Y2hlcyA9IHA7XG4gICAgICAgIGludmVyc2VQYXRjaGVzID0gaXA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZz8uYXV0b0ZyZWV6ZSA9PT0gXCJib29sZWFuXCIpXG4gICAgICB0aGlzLnNldEF1dG9GcmVlemUoY29uZmlnLmF1dG9GcmVlemUpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnPy51c2VTdHJpY3RTaGFsbG93Q29weSA9PT0gXCJib29sZWFuXCIpXG4gICAgICB0aGlzLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5KGNvbmZpZy51c2VTdHJpY3RTaGFsbG93Q29weSk7XG4gIH1cbiAgY3JlYXRlRHJhZnQoYmFzZSkge1xuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpXG4gICAgICBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpXG4gICAgICBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB2b2lkIDApO1xuICAgIHByb3h5W0RSQUZUX1NUQVRFXS5pc01hbnVhbF8gPSB0cnVlO1xuICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfVxuICBmaW5pc2hEcmFmdChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xuICAgIGNvbnN0IHN0YXRlID0gZHJhZnQgJiYgZHJhZnRbRFJBRlRfU1RBVEVdO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsXylcbiAgICAgIGRpZSg5KTtcbiAgICBjb25zdCB7IHNjb3BlXzogc2NvcGUgfSA9IHN0YXRlO1xuICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdCh2b2lkIDAsIHNjb3BlKTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgc2V0QXV0b0ZyZWV6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGVuYWJsZSBzdHJpY3Qgc2hhbGxvdyBjb3B5LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbW1lciBkb2VzIG5vdCBjb3B5IHRoZSBvYmplY3QgZGVzY3JpcHRvcnMgc3VjaCBhcyBnZXR0ZXIsIHNldHRlciBhbmQgbm9uLWVudW1yYWJsZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkodmFsdWUpIHtcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IHZhbHVlO1xuICB9XG4gIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwICYmIHBhdGNoLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICBiYXNlID0gcGF0Y2gudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSk7XG4gICAgfVxuICAgIGNvbnN0IGFwcGx5UGF0Y2hlc0ltcGwgPSBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmFwcGx5UGF0Y2hlc187XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIHtcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGJhc2UsIHBhdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9kdWNlKFxuICAgICAgYmFzZSxcbiAgICAgIChkcmFmdCkgPT4gYXBwbHlQYXRjaGVzSW1wbChkcmFmdCwgcGF0Y2hlcylcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUHJveHkodmFsdWUsIHBhcmVudCkge1xuICBjb25zdCBkcmFmdCA9IGlzTWFwKHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudCkgOiBpc1NldCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KTtcbiAgY29uc3Qgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCk7XG4gIHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdCk7XG4gIHJldHVybiBkcmFmdDtcbn1cblxuLy8gc3JjL2NvcmUvY3VycmVudC50c1xuZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxMCwgdmFsdWUpO1xuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xufVxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkgfHwgaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGxldCBjb3B5O1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXylcbiAgICAgIHJldHVybiBzdGF0ZS5iYXNlXztcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfKTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHRydWUpO1xuICB9XG4gIGVhY2goY29weSwgKGtleSwgY2hpbGRWYWx1ZSkgPT4ge1xuICAgIHNldChjb3B5LCBrZXksIGN1cnJlbnRJbXBsKGNoaWxkVmFsdWUpKTtcbiAgfSk7XG4gIGlmIChzdGF0ZSkge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cblxuLy8gc3JjL3BsdWdpbnMvcGF0Y2hlcy50c1xuZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcbiAgY29uc3QgZXJyb3JPZmZzZXQgPSAxNjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuICAgICAgZnVuY3Rpb24ob3ApIHtcbiAgICAgICAgcmV0dXJuIFwiVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiBcIiArIG9wO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoO1xuICAgICAgfSxcbiAgICAgIFwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBSRVBMQUNFID0gXCJyZXBsYWNlXCI7XG4gIGNvbnN0IEFERCA9IFwiYWRkXCI7XG4gIGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCI7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMCAvKiBPYmplY3QgKi86XG4gICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXMsXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgICBwYXRjaGVzLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgYXNzaWduZWRfIH0gPSBzdGF0ZTtcbiAgICBsZXQgY29weV8gPSBzdGF0ZS5jb3B5XztcbiAgICBpZiAoY29weV8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG4gICAgICA7XG4gICAgICBbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dO1xuICAgICAgW3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGJhc2VfLmxlbmd0aDsgaSA8IGNvcHlfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoLFxuICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gY29weV8ubGVuZ3RoIC0gMTsgYmFzZV8ubGVuZ3RoIDw9IGk7IC0taSkge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGNvbnN0IHsgYmFzZV8sIGNvcHlfIH0gPSBzdGF0ZTtcbiAgICBlYWNoKHN0YXRlLmFzc2lnbmVkXywgKGtleSwgYXNzaWduZWRWYWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gZ2V0KGJhc2VfLCBrZXkpO1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQoY29weV8sIGtleSk7XG4gICAgICBjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERDtcbiAgICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XG4gICAgICBwYXRjaGVzLnB1c2gob3AgPT09IFJFTU9WRSA/IHsgb3AsIHBhdGggfSA6IHsgb3AsIHBhdGgsIHZhbHVlIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChcbiAgICAgICAgb3AgPT09IEFERCA/IHsgb3A6IFJFTU9WRSwgcGF0aCB9IDogb3AgPT09IFJFTU9WRSA/IHsgb3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfSA6IHsgb3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICBpID0gMDtcbiAgICBjb3B5Xy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHZvaWQgMCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5UGF0Y2hlc18oZHJhZnQsIHBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICBjb25zdCB7IHBhdGgsIG9wIH0gPSBwYXRjaDtcbiAgICAgIGxldCBiYXNlID0gZHJhZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgICAgbGV0IHAgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwID0gXCJcIiArIHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwYXJlbnRUeXBlID09PSAwIC8qIE9iamVjdCAqLyB8fCBwYXJlbnRUeXBlID09PSAxIC8qIEFycmF5ICovKSAmJiAocCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwID09PSBcImNvbnN0cnVjdG9yXCIpKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBiYXNlID0gZ2V0KGJhc2UsIHApO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMiwgcGF0aC5qb2luKFwiL1wiKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpO1xuICAgICAgY29uc3Qga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFJFUExBQ0U6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBREQ6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKVxuICAgICAgcmV0dXJuIG9iajtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XG4gICAgaWYgKGlzTWFwKG9iaikpXG4gICAgICByZXR1cm4gbmV3IE1hcChcbiAgICAgICAgQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuICAgICAgKTtcbiAgICBpZiAoaXNTZXQob2JqKSlcbiAgICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcbiAgICBpZiAoaGFzKG9iaiwgRFJBRlRBQkxFKSlcbiAgICAgIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvYmopIHtcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG9iajtcbiAgfVxuICBsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG4gICAgYXBwbHlQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzX1xuICB9KTtcbn1cblxuLy8gc3JjL3BsdWdpbnMvbWFwc2V0LnRzXG5mdW5jdGlvbiBlbmFibGVNYXBTZXQoKSB7XG4gIGNsYXNzIERyYWZ0TWFwIGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogMiAvKiBNYXAgKi8sXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5Xzogdm9pZCAwLFxuICAgICAgICBhc3NpZ25lZF86IHZvaWQgMCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlLFxuICAgICAgICByZXZva2VkXzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmNvcHlfLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBlYWNoKHN0YXRlLmJhc2VfLCAoa2V5KSA9PiB7XG4gICAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBsYXRlc3Qoc3RhdGUpLmZvckVhY2goKF92YWx1ZSwga2V5LCBfbWFwKSA9PiB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoa2V5KSwga2V5LCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KTtcbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJveHlNYXBfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRHJhZnRTZXQgZXh0ZW5kcyBTZXQge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAzIC8qIFNldCAqLyxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgZHJhZnRzXzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDogKFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmYWxzZVxuICAgICAgKSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy52YWx1ZXMoKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm94eVNldF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmNvcHlfID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgICAgc3RhdGUuZHJhZnRzXy5zZXQodmFsdWUsIGRyYWZ0KTtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQoZHJhZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pXG4gICAgICBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpO1xuICB9XG4gIGxvYWRQbHVnaW4oXCJNYXBTZXRcIiwgeyBwcm94eU1hcF8sIHByb3h5U2V0XyB9KTtcbn1cblxuLy8gc3JjL2ltbWVyLnRzXG52YXIgaW1tZXIgPSBuZXcgSW1tZXIyKCk7XG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID0gaW1tZXIucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoXG4gIGltbWVyXG4pO1xudmFyIHNldEF1dG9GcmVlemUgPSBpbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xudmFyIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5ID0gaW1tZXIuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkuYmluZChpbW1lcik7XG52YXIgYXBwbHlQYXRjaGVzID0gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xudmFyIGNyZWF0ZURyYWZ0ID0gaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcik7XG52YXIgZmluaXNoRHJhZnQgPSBpbW1lci5maW5pc2hEcmFmdC5iaW5kKGltbWVyKTtcbmZ1bmN0aW9uIGNhc3REcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjYXN0SW1tdXRhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCB7XG4gIEltbWVyMiBhcyBJbW1lcixcbiAgYXBwbHlQYXRjaGVzLFxuICBjYXN0RHJhZnQsXG4gIGNhc3RJbW11dGFibGUsXG4gIGNyZWF0ZURyYWZ0LFxuICBjdXJyZW50LFxuICBlbmFibGVNYXBTZXQsXG4gIGVuYWJsZVBhdGNoZXMsXG4gIGZpbmlzaERyYWZ0LFxuICBmcmVlemUsXG4gIERSQUZUQUJMRSBhcyBpbW1lcmFibGUsXG4gIGlzRHJhZnQsXG4gIGlzRHJhZnRhYmxlLFxuICBOT1RISU5HIGFzIG5vdGhpbmcsXG4gIG9yaWdpbmFsLFxuICBwcm9kdWNlLFxuICBwcm9kdWNlV2l0aFBhdGNoZXMsXG4gIHNldEF1dG9GcmVlemUsXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/immer/dist/immer.mjs\n"));

/***/ }),

/***/ "./node_modules/is-plain-object/dist/is-plain-object.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/is-plain-object/dist/is-plain-object.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject)\n/* harmony export */ });\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2Rpc3QvaXMtcGxhaW4tb2JqZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV5QiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9pcy1wbGFpbi1vYmplY3QvZGlzdC9pcy1wbGFpbi1vYmplY3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICB2YXIgY3Rvcixwcm90O1xuXG4gIGlmIChpc09iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcbiAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kXG4gIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7IGlzUGxhaW5PYmplY3QgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/is-plain-object/dist/is-plain-object.mjs\n"));

/***/ }),

/***/ "./node_modules/scroll-into-view-if-needed/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/scroll-into-view-if-needed/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ e)\n/* harmony export */ });\n/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-scroll-into-view */ \"./node_modules/compute-scroll-into-view/dist/index.js\");\nconst o=t=>!1===t?{block:\"end\",inline:\"nearest\"}:(t=>t===Object(t)&&0!==Object.keys(t).length)(t)?t:{block:\"start\",inline:\"nearest\"};function e(e,r){if(!e.isConnected||!(t=>{let o=t;for(;o&&o.parentNode;){if(o.parentNode===document)return!0;o=o.parentNode instanceof ShadowRoot?o.parentNode.host:o.parentNode}return!1})(e))return;const n=(t=>{const o=window.getComputedStyle(t);return{top:parseFloat(o.scrollMarginTop)||0,right:parseFloat(o.scrollMarginRight)||0,bottom:parseFloat(o.scrollMarginBottom)||0,left:parseFloat(o.scrollMarginLeft)||0}})(e);if((t=>\"object\"==typeof t&&\"function\"==typeof t.behavior)(r))return r.behavior((0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__.compute)(e,r));const l=\"boolean\"==typeof r||null==r?void 0:r.behavior;for(const{el:a,top:i,left:s}of (0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__.compute)(e,o(r))){const t=i-n.top+n.bottom,o=s-n.left+n.right;a.scroll({top:t,left:o,behavior:l})}}//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRCxtQkFBbUIsNkJBQTZCLHFEQUFxRCxnQ0FBZ0MsZ0JBQWdCLHlCQUF5QixRQUFRLEtBQUssZ0JBQWdCLEVBQUUsb0NBQW9DLG9FQUFvRSxTQUFTLFlBQVksYUFBYSxtQ0FBbUMsT0FBTyxpS0FBaUssS0FBSywrRUFBK0UsaUVBQUMsT0FBTyx1REFBdUQsVUFBVSxrQkFBa0IsR0FBRyxpRUFBQyxVQUFVLDRDQUE0QyxVQUFVLHdCQUF3QixHQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2ZhYmlvZXN0ZXZlcy9yZXBvcy91bmZvbGRyL25vZGVfbW9kdWxlcy9zY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtjb21wdXRlIGFzIHR9ZnJvbVwiY29tcHV0ZS1zY3JvbGwtaW50by12aWV3XCI7Y29uc3Qgbz10PT4hMT09PXQ/e2Jsb2NrOlwiZW5kXCIsaW5saW5lOlwibmVhcmVzdFwifToodD0+dD09PU9iamVjdCh0KSYmMCE9PU9iamVjdC5rZXlzKHQpLmxlbmd0aCkodCk/dDp7YmxvY2s6XCJzdGFydFwiLGlubGluZTpcIm5lYXJlc3RcIn07ZnVuY3Rpb24gZShlLHIpe2lmKCFlLmlzQ29ubmVjdGVkfHwhKHQ9PntsZXQgbz10O2Zvcig7byYmby5wYXJlbnROb2RlOyl7aWYoby5wYXJlbnROb2RlPT09ZG9jdW1lbnQpcmV0dXJuITA7bz1vLnBhcmVudE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290P28ucGFyZW50Tm9kZS5ob3N0Om8ucGFyZW50Tm9kZX1yZXR1cm4hMX0pKGUpKXJldHVybjtjb25zdCBuPSh0PT57Y29uc3Qgbz13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtyZXR1cm57dG9wOnBhcnNlRmxvYXQoby5zY3JvbGxNYXJnaW5Ub3ApfHwwLHJpZ2h0OnBhcnNlRmxvYXQoby5zY3JvbGxNYXJnaW5SaWdodCl8fDAsYm90dG9tOnBhcnNlRmxvYXQoby5zY3JvbGxNYXJnaW5Cb3R0b20pfHwwLGxlZnQ6cGFyc2VGbG9hdChvLnNjcm9sbE1hcmdpbkxlZnQpfHwwfX0pKGUpO2lmKCh0PT5cIm9iamVjdFwiPT10eXBlb2YgdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5iZWhhdmlvcikocikpcmV0dXJuIHIuYmVoYXZpb3IodChlLHIpKTtjb25zdCBsPVwiYm9vbGVhblwiPT10eXBlb2Ygcnx8bnVsbD09cj92b2lkIDA6ci5iZWhhdmlvcjtmb3IoY29uc3R7ZWw6YSx0b3A6aSxsZWZ0OnN9b2YgdChlLG8ocikpKXtjb25zdCB0PWktbi50b3Arbi5ib3R0b20sbz1zLW4ubGVmdCtuLnJpZ2h0O2Euc2Nyb2xsKHt0b3A6dCxsZWZ0Om8sYmVoYXZpb3I6bH0pfX1leHBvcnR7ZSBhcyBkZWZhdWx0fTsvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scroll-into-view-if-needed/dist/index.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["pages/_app","main"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Ffabioesteves%2Frepos%2Funfoldr%2Fsrc%2Fpages%2F%5BdocumentId%5D.tsx&page=%2F%5BdocumentId%5D!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);